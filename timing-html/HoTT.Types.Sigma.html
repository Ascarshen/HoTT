<html>
<head>
<title>Sigma.v</title>
<style>
.time {
  background-color: #ffaaaa;
  height: 100%;
  z-index: -1;
  position: absolute;
}
.code {
  z-index: 0;
  position: relative;
  border-style: solid;
  border-color: transparent;
  border-width: 1px;
}
.code:hover {
  border-style: solid;
  border-color: black;
  border-width: 1px;
}
pre {
  margin: 1px;
}
</style>
</head>
<body>
<h1>Timings for Sigma.v</h1>

<div class="code" title="File: Sigma.v
Line: 1
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>(* -*- mode: coq; mode: visual-line -*- *)
(** * Theorems about Sigma-types (dependent sums) *)

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 3
Time: 0.018s">
<div class="time" style="width: 60%"></div>
<pre>Require Import HoTT.Basics.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 3
Time: 0.009s">
<div class="time" style="width: 30%"></div>
<pre>
Require Import Types.Arrow Types.Prod Types.Paths Types.Unit.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 4
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Local Open Scope path_scope.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 5
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>


Generalizable Variables X A B C f g n.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 8
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Scheme sig_ind := Induction for sig Sort Type.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 10
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Scheme sig_rec := Minimality for sig Sort Type.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 11
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** In homotopy type theory, We think of elements of [Type] as spaces, homotopy types, or weak omega-groupoids. A type family [P : A -&gt; Type] corresponds to a fibration whose base is [A] and whose fiber over [x] is [P x].

From such a [P] we can build a total space over the base space [A] so that the fiber over [x : A] is [P x]. This is just Coq's dependent sum construction, written as [sigT P] or [{x : A &amp; P x}]. The elements of [{x : A &amp; P x}] are pairs, written [existT P x y] in Coq, where [x : A] and [y : P x].  In [Common.v] we defined the notation [(x;y)] to mean [existT _ x y].

The base and fiber components of a point in the total space are extracted with the two projections [pr1] and [pr2]. *)

(** ** Unpacking *)

(** Sometimes we would like to prove [Q u] where [u : {x : A &amp; P x}] by writing [u] as a pair [(pr1 u ; pr2 u)]. This is accomplished by [sigT_unpack]. We want tight control over the proof, so we just write it down even though is looks a bit scary. *)

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 22
Time: 0.001s">
<div class="time" style="width: 3.3333333333333%"></div>
<pre>Definition unpack_sigma `{P : A -&gt; Type} (Q : sigT P -&gt; Type) (u : sigT P)
: Q (u.1; u.2) -&gt; Q u
  := idmap.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 24
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Arguments unpack_sigma / .</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 26
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Eta conversion *)

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 29
Time: 0.001s">
<div class="time" style="width: 3.3333333333333%"></div>
<pre>Definition eta_sigma `{P : A -&gt; Type} (u : sigT P)
  : (u.1; u.2) = u
  := 1.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 31
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Arguments eta_sigma / .</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 33
Time: 0.002s">
<div class="time" style="width: 6.6666666666667%"></div>
<pre>

Definition eta2_sigma `{P : forall (a : A) (b : B a), Type}
           (u : sigT (fun a =&gt; sigT (P a)))
  : (u.1; u.2.1; u.2.2) = u
  := 1.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 38
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Arguments eta2_sigma / .</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 40
Time: 0.005s">
<div class="time" style="width: 16.666666666667%"></div>
<pre>

Definition eta3_sigma `{P : forall (a : A) (b : B a) (c : C a b), Type}
           (u : sigT (fun a =&gt; sigT (fun b =&gt; sigT (P a b))))
  : (u.1; u.2.1; u.2.2.1; u.2.2.2) = u
  := 1.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 45
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Arguments eta3_sigma / .</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 47
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Paths *)

(** A path in a total space is commonly shown component wise. Because we use this over and over, we write down the proofs by hand to make sure they are what we think they should be. *)

(** With this version of the function, we often have to give [u] and [v] explicitly, so we make them explicit arguments. *)</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 53
Time: 0.005s">
<div class="time" style="width: 16.666666666667%"></div>
<pre>Definition path_sigma_uncurried {A : Type} (P : A -&gt; Type) (u v : sigT P)
           (pq : {p : u.1 = v.1 &amp; p # u.2 = v.2})
: u = v
  := match pq.2 in (_ = v2) return u = (v.1; v2) with
       | 1 =&gt; match pq.1 as p in (_ = v1) return u = (v1; p # u.2) with
                | 1 =&gt; 1
              end
     end.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 60
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** This is the curried one you usually want to use in practice.  We define it in terms of the uncurried one, since it's the uncurried one that is proven below to be an equivalence. *)</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 62
Time: 0.002s">
<div class="time" style="width: 6.6666666666667%"></div>
<pre>Definition path_sigma {A : Type} (P : A -&gt; Type) (u v : sigT P)
           (p : u.1 = v.1) (q : p # u.2 = v.2)
: u = v
  := path_sigma_uncurried P u v (p;q).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 65
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** A contravariant instance of [path_sigma_uncurried] *)</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 67
Time: 0.004s">
<div class="time" style="width: 13.333333333333%"></div>
<pre>Definition path_sigma_uncurried_contra {A : Type} (P : A -&gt; Type) (u v : sigT P)
           (pq : {p : u.1 = v.1 &amp; u.2 = p^ # v.2})
: u = v
  := (path_sigma_uncurried P v u (pq.1^;pq.2^))^.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 70
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** A variant of [Forall.dpath_forall] from which uses dependent sums to package things. It cannot go into [Forall] because [Sigma] depends on [Forall]. *)

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 73
Time: 0.005s">
<div class="time" style="width: 16.666666666667%"></div>
<pre>Definition dpath_forall'
           {A : Type } (P : A -&gt; Type) (Q: sigT P -&gt; Type) {x y : A} (h : x = y)
           (f : forall p, Q (x ; p)) (g : forall p, Q (y ; p))
:
  (forall p, transport Q (path_sigma P (x ; p) (y; _) h 1) (f p) = g (h # p))
    &lt;~&gt;
    (forall p, transportD P (fun x =&gt; fun p =&gt; Q ( x ; p)) h p (f p) = g (transport P h p)).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 79
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 80
Time: 0.003s">
<div class="time" style="width: 10%"></div>
<pre>
  destruct h.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 81
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  apply 1%equiv.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 82
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.


(** This version produces only paths between pairs, as opposed to paths between arbitrary inhabitants of dependent sum types.  But it has the advantage that the components of those pairs can more often be inferred, so we make them implicit arguments. *)</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 86
Time: 0.002s">
<div class="time" style="width: 6.6666666666667%"></div>
<pre>Definition path_sigma' {A : Type} (P : A -&gt; Type) {x x' : A} {y : P x} {y' : P x'}
           (p : x = x') (q : p # y = y')
: (x;y) = (x';y')
  := path_sigma P (x;y) (x';y') p q.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 89
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>


(** Projections of paths from a total space. *)

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 93
Time: 0.001s">
<div class="time" style="width: 3.3333333333333%"></div>
<pre>Definition pr1_path `{P : A -&gt; Type} {u v : sigT P} (p : u = v)
: u.1 = v.1
  :=
    ap pr1 p.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 96
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
(* match p with idpath =&gt; 1 end. *)

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 98
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Notation "p ..1" := (pr1_path p) : fibration_scope.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 98
Time: 0.009s">
<div class="time" style="width: 30%"></div>
<pre>

Definition pr2_path `{P : A -&gt; Type} {u v : sigT P} (p : u = v)
: p..1 # u.2 = v.2
  := (transport_compose P pr1 p u.2)^
     @ (@apD {x:A &amp; P x} _ pr2 _ _ p).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 103
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Notation "p ..2" := (pr2_path p) : fibration_scope.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 105
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Now we show how these things compute. *)

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 108
Time: 0.002s">
<div class="time" style="width: 6.6666666666667%"></div>
<pre>Definition pr1_path_sigma_uncurried `{P : A -&gt; Type} {u v : sigT P}
           (pq : { p : u.1 = v.1 &amp; p # u.2 = v.2 })
: (path_sigma_uncurried _ _ _ pq)..1 = pq.1.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 110
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 111
Time: 0.002s">
<div class="time" style="width: 6.6666666666667%"></div>
<pre>
  destruct u as [u1 u2]; destruct v as [v1 v2]; simpl in *.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 112
Time: 0.001s">
<div class="time" style="width: 3.3333333333333%"></div>
<pre>
  destruct pq as [p q].</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 113
Time: 0.002s">
<div class="time" style="width: 6.6666666666667%"></div>
<pre>
  destruct p; simpl in q; destruct q; reflexivity.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 114
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 116
Time: 0.004s">
<div class="time" style="width: 13.333333333333%"></div>
<pre>Definition pr2_path_sigma_uncurried `{P : A -&gt; Type} {u v : sigT P}
           (pq : { p : u.1 = v.1 &amp; p # u.2 = v.2 })
: (path_sigma_uncurried _ _ _ pq)..2
  = ap (fun s =&gt; transport P s u.2) (pr1_path_sigma_uncurried pq) @ pq.2.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 119
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 120
Time: 0.005s">
<div class="time" style="width: 16.666666666667%"></div>
<pre>
  destruct u as [u1 u2]; destruct v as [v1 v2]; simpl in *.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 121
Time: 0.002s">
<div class="time" style="width: 6.6666666666667%"></div>
<pre>
  destruct pq as [p q].</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 122
Time: 0.008s">
<div class="time" style="width: 26.666666666667%"></div>
<pre>
  destruct p; simpl in q; destruct q; reflexivity.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 123
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 125
Time: 0.002s">
<div class="time" style="width: 6.6666666666667%"></div>
<pre>Definition eta_path_sigma_uncurried `{P : A -&gt; Type} {u v : sigT P}
           (p : u = v)
: path_sigma_uncurried _ _ _ (p..1; p..2) = p.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 127
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 128
Time: 0.001s">
<div class="time" style="width: 3.3333333333333%"></div>
<pre>
  destruct p.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 129
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> reflexivity.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 129
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 131
Time: 0.003s">
<div class="time" style="width: 10%"></div>
<pre>Lemma transport_pr1_path_sigma_uncurried
      `{P : A -&gt; Type} {u v : sigT P}
      (pq : { p : u.1 = v.1 &amp; transport P p u.2 = v.2 })
      Q
: transport (fun x =&gt; Q x.1) (@path_sigma_uncurried A P u v pq)
  = transport _ pq.1.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 136
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 137
Time: 0.004s">
<div class="time" style="width: 13.333333333333%"></div>
<pre>
  destruct pq as [p q], u, v; simpl in *.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 138
Time: 0.003s">
<div class="time" style="width: 10%"></div>
<pre>
  destruct p, q; simpl in *.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 139
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  reflexivity.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 140
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 142
Time: 0.003s">
<div class="time" style="width: 10%"></div>
<pre>Definition pr1_path_sigma `{P : A -&gt; Type} {u v : sigT P}
           (p : u.1 = v.1) (q : p # u.2 = v.2)
: (path_sigma _ _ _ p q)..1 = p
  := pr1_path_sigma_uncurried (p; q).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 145
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(* Writing it the other way can help [rewrite]. *)</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 147
Time: 0.003s">
<div class="time" style="width: 10%"></div>
<pre>Definition ap_pr1_path_sigma {A:Type} {P : A -&gt; Type} {u v : sigT P}
           (p : u.1 = v.1) (q : p # u.2 = v.2)
  : ap pr1 (path_sigma _ _ _ p q) = p
  := pr1_path_sigma p q.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 150
Time: 0.007s">
<div class="time" style="width: 23.333333333333%"></div>
<pre>

Definition pr2_path_sigma `{P : A -&gt; Type} {u v : sigT P}
           (p : u.1 = v.1) (q : p # u.2 = v.2)
: (path_sigma _ _ _ p q)..2
  = ap (fun s =&gt; transport P s u.2) (pr1_path_sigma p q) @ q
  := pr2_path_sigma_uncurried (p; q).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 156
Time: 0.002s">
<div class="time" style="width: 6.6666666666667%"></div>
<pre>

Definition eta_path_sigma `{P : A -&gt; Type} {u v : sigT P} (p : u = v)
: path_sigma _ _ _ (p..1) (p..2) = p
  := eta_path_sigma_uncurried p.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 160
Time: 0.004s">
<div class="time" style="width: 13.333333333333%"></div>
<pre>

Definition transport_pr1_path_sigma
           `{P : A -&gt; Type} {u v : sigT P}
           (p : u.1 = v.1) (q : p # u.2 = v.2)
           Q
: transport (fun x =&gt; Q x.1) (@path_sigma A P u v p q)
  = transport _ p
  := transport_pr1_path_sigma_uncurried (p; q) Q.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 168
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** This lets us identify the path space of a sigma-type, up to equivalence. *)

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 171
Time: 0.001s">
<div class="time" style="width: 3.3333333333333%"></div>
<pre>Global Instance isequiv_path_sigma `{P : A -&gt; Type} {u v : sigT P}
: IsEquiv (path_sigma_uncurried P u v) | 0.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 172
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 173
Time: 0.002s">
<div class="time" style="width: 6.6666666666667%"></div>
<pre>
  simple refine (BuildIsEquiv
            _ _
            _ (fun r =&gt; (r..1; r..2))
            eta_path_sigma
            _ _).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 178
Time: 0.029s">
<div class="time" style="width: 96.666666666667%"></div>
<pre>
  all: destruct u, v; intros [p q].</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 179
Time: 0.002s">
<div class="time" style="width: 6.6666666666667%"></div>
<pre>
  all: simpl in *.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 180
Time: 0.03s">
<div class="time" style="width: 100%"></div>
<pre>
  all: destruct q, p; simpl in *.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 181
Time: 0.001s">
<div class="time" style="width: 3.3333333333333%"></div>
<pre>
  all: reflexivity.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 182
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 184
Time: 0.005s">
<div class="time" style="width: 16.666666666667%"></div>
<pre>Definition equiv_path_sigma `(P : A -&gt; Type) (u v : sigT P)
: {p : u.1 = v.1 &amp;  p # u.2 = v.2} &lt;~&gt; (u = v)
  := BuildEquiv _ _ (path_sigma_uncurried P u v) _.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 186
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(* A contravariant version of [isequiv_path_sigma'] *)</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 188
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Instance isequiv_path_sigma_contra `{P : A -&gt; Type} {u v : sigT P}
  : IsEquiv (path_sigma_uncurried_contra P u v) | 0.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 189
Time: 0.002s">
<div class="time" style="width: 6.6666666666667%"></div>
<pre>
  apply (isequiv_adjointify (path_sigma_uncurried_contra P u v)
        (fun r =&gt; match r with idpath =&gt; (1; 1) end)).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 191
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
-</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 192
Time: 0.003s">
<div class="time" style="width: 10%"></div>
<pre> by intro r; induction r; destruct u as [u1 u2]; reflexivity.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 192
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
-</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 193
Time: 0.021s">
<div class="time" style="width: 70%"></div>
<pre> destruct u, v; intros [p q].</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 193
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  simpl in *.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 194
Time: 0.001s">
<div class="time" style="width: 3.3333333333333%"></div>
<pre>
  destruct p; simpl in q.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 195
Time: 0.001s">
<div class="time" style="width: 3.3333333333333%"></div>
<pre>
  destruct q; reflexivity.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 196
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.

(* A contravariant version of [equiv_path_sigma] *)</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 199
Time: 0.002s">
<div class="time" style="width: 6.6666666666667%"></div>
<pre>Definition equiv_path_sigma_contra {A : Type} `(P : A -&gt; Type) (u v : sigT P)
  : {p : u.1 = v.1 &amp; u.2 = p^ # v.2} &lt;~&gt; (u = v)
  := BuildEquiv _ _ (path_sigma_uncurried_contra P u v) _.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 201
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** This identification respects path concatenation. *)

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 204
Time: 0.003s">
<div class="time" style="width: 10%"></div>
<pre>Definition path_sigma_pp_pp {A : Type} (P : A -&gt; Type) {u v w : sigT P}
           (p1 : u.1 = v.1) (q1 : p1 # u.2 = v.2)
           (p2 : v.1 = w.1) (q2 : p2 # v.2 = w.2)
: path_sigma P u w (p1 @ p2)
             (transport_pp P p1 p2 u.2 @ ap (transport P p2) q1 @ q2)
  = path_sigma P u v p1 q1 @ path_sigma P v w p2 q2.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 209
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 210
Time: 0.004s">
<div class="time" style="width: 13.333333333333%"></div>
<pre>
  destruct u, v, w.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 211
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> simpl in *.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 211
Time: 0.005s">
<div class="time" style="width: 16.666666666667%"></div>
<pre>
  destruct p1, p2, q1, q2.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 212
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  reflexivity.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 213
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 215
Time: 0.005s">
<div class="time" style="width: 16.666666666667%"></div>
<pre>Definition path_sigma_pp_pp' {A : Type} (P : A -&gt; Type)
           {u1 v1 w1 : A} {u2 : P u1} {v2 : P v1} {w2 : P w1}
           (p1 : u1 = v1) (q1 : p1 # u2 = v2)
           (p2 : v1 = w1) (q2 : p2 # v2 = w2)
: path_sigma' P (p1 @ p2)
              (transport_pp P p1 p2 u2 @ ap (transport P p2) q1 @ q2)
  = path_sigma' P p1 q1 @ path_sigma' P p2 q2
  := @path_sigma_pp_pp A P (u1;u2) (v1;v2) (w1;w2) p1 q1 p2 q2.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 222
Time: 0.001s">
<div class="time" style="width: 3.3333333333333%"></div>
<pre>

Definition path_sigma_p1_1p' {A : Type} (P : A -&gt; Type)
           {u1 v1 : A} {u2 : P u1} {v2 : P v1}
           (p : u1 = v1) (q : p # u2 = v2)
: path_sigma' P p q
  = path_sigma' P p 1 @ path_sigma' P 1 q.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 228
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 229
Time: 0.001s">
<div class="time" style="width: 3.3333333333333%"></div>
<pre>
  destruct p, q.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 230
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  reflexivity.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 231
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.

(** [pr1_path] also commutes with the groupoid structure. *)

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 235
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Definition pr1_path_1 {A : Type} {P : A -&gt; Type} (u : sigT P)
: (idpath u) ..1 = idpath (u .1)
  := 1.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 237
Time: 0.002s">
<div class="time" style="width: 6.6666666666667%"></div>
<pre>

Definition pr1_path_pp {A : Type} {P : A -&gt; Type} {u v w : sigT P}
           (p : u = v) (q : v = w)
: (p @ q) ..1 = (p ..1) @ (q ..1)
  := ap_pp _ _ _.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 242
Time: 0.001s">
<div class="time" style="width: 3.3333333333333%"></div>
<pre>

Definition pr1_path_V {A : Type} {P : A -&gt; Type} {u v : sigT P} (p : u = v)
: p^ ..1 = (p ..1)^
  := ap_V _ _.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 246
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Applying [existT] to one argument is the same as [path_sigma] with reflexivity in the first place. *)

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 249
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Definition ap_existT {A : Type} (P : A -&gt; Type) (x : A) (y1 y2 : P x)
           (q : y1 = y2)
: ap (existT P x) q = path_sigma' P 1 q.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 251
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 252
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  destruct q; reflexivity.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 253
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.

(** Dependent transport is the same as transport along a [path_sigma]. *)

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 257
Time: 0.001s">
<div class="time" style="width: 3.3333333333333%"></div>
<pre>Definition transportD_is_transport
           {A:Type} (B:A-&gt;Type) (C:sigT B -&gt; Type)
           (x1 x2:A) (p:x1=x2) (y:B x1) (z:C (x1;y))
: transportD B (fun a b =&gt; C (a;b)) p y z
  = transport C (path_sigma' B p 1) z.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 261
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 262
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  destruct p.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 263
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> reflexivity.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 263
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.


(** Applying a two variable function to a [path_sigma]. *)

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 268
Time: 0.004s">
<div class="time" style="width: 13.333333333333%"></div>
<pre>Definition ap_path_sigma {A B} (P : A -&gt; Type) (F : forall a : A, P a -&gt; B)
           {x x' : A} {y : P x} {y' : P x'} (p : x = x') (q : p # y = y')
  : ap (fun w =&gt; F w.1 w.2) (path_sigma' P p q)
    = ap _ (moveL_transport_V _ p _ _ q)
         @ (transport_arrow_toconst _ _ _)^ @ ap10 (apD F p) y'.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 272
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 273
Time: 0.003s">
<div class="time" style="width: 10%"></div>
<pre>
  destruct p, q; reflexivity.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 274
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.
(* Remark: this is also equal to: *)
(*     = ap10 (apD F p^)^ y @ transport_arrow_toconst _ _ _ *)
(*                          @ ap (F x') (transport2 _ (inv_V p) y @ q). *)



(** And we can simplify when the first equality is [1]. *)</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 282
Time: 0.001s">
<div class="time" style="width: 3.3333333333333%"></div>
<pre>Lemma ap_path_sigma_1p {A B : Type} {P : A -&gt; Type} (F : forall a, P a -&gt; B)
      (a : A) {x y : P a} (p : x = y)
  : ap (fun w =&gt; F w.1 w.2) (path_sigma' P 1 p) = ap (fun z =&gt; F a z) p.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 284
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 285
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  destruct p; reflexivity.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 286
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.


(** Applying a function constructed with [sigT_ind] to a [path_sigma] can be computed.  Technically this computation should probably go by way of a 2-variable [ap], and should be done in the dependently typed case. *)

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 291
Time: 0.006s">
<div class="time" style="width: 20%"></div>
<pre>Definition ap_sigT_rec_path_sigma {A : Type} (P : A -&gt; Type) {Q : Type}
           (x1 x2:A) (p:x1=x2) (y1:P x1) (y2:P x2) (q:p # y1 = y2)
           (d : forall a, P a -&gt; Q)
: ap (sigT_ind (fun _ =&gt; Q) d) (path_sigma' P p q)
  = (transport_const p _)^
    @ (ap ((transport (fun _ =&gt; Q) p) o (d x1)) (transport_Vp _ p y1))^

    @ (transport_arrow p _ _)^
    @ ap10 (apD d p) (p # y1)
      @ ap (d x2) q.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 300
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 301
Time: 0.002s">
<div class="time" style="width: 6.6666666666667%"></div>
<pre>
  destruct p.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 302
Time: 0.008s">
<div class="time" style="width: 26.666666666667%"></div>
<pre> destruct q.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 302
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> reflexivity.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 302
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.


(** A path between paths in a total space is commonly shown component wise. *)

(** With this version of the function, we often have to give [u] and [v] explicitly, so we make them explicit arguments. *)</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 308
Time: 0.002s">
<div class="time" style="width: 6.6666666666667%"></div>
<pre>Definition path_path_sigma_uncurried {A : Type} (P : A -&gt; Type) (u v : sigT P)
           (p q : u = v)
           (rs : {r : p..1 = q..1 &amp; transport (fun x =&gt; transport P x u.2 = v.2) r p..2 = q..2})
: p = q.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 311
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 312
Time: 0.002s">
<div class="time" style="width: 6.6666666666667%"></div>
<pre>
  destruct rs, p, u.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 313
Time: 0.001s">
<div class="time" style="width: 3.3333333333333%"></div>
<pre>
  etransitivity; [ | apply eta_path_sigma ].</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 314
Time: 0.003s">
<div class="time" style="width: 10%"></div>
<pre>
  path_induction.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 315
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  reflexivity.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 316
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.

(** This is the curried one you usually want to use in practice.  We define it in terms of the uncurried one, since it's the uncurried one that is proven below to be an equivalence. *)</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 319
Time: 0.004s">
<div class="time" style="width: 13.333333333333%"></div>
<pre>Definition path_path_sigma {A : Type} (P : A -&gt; Type) (u v : sigT P)
           (p q : u = v)
           (r : p..1 = q..1)
           (s : transport (fun x =&gt; transport P x u.2 = v.2) r p..2 = q..2)
: p = q
  := path_path_sigma_uncurried P u v p q (r; s).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 324
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Transport *)

(** The concrete description of transport in sigmas (and also pis) is rather trickier than in the other types.  In particular, these cannot be described just in terms of transport in simpler types; they require also the dependent transport [transportD].

  In particular, this indicates why "transport" alone cannot be fully defined by induction on the structure of types, although Id-elim/transportD can be (cf. Observational Type Theory).  A more thorough set of lemmas, along the lines of the present ones but dealing with Id-elim rather than just transport, might be nice to have eventually? *)

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 331
Time: 0.001s">
<div class="time" style="width: 3.3333333333333%"></div>
<pre>Definition transport_sigma {A : Type} {B : A -&gt; Type} {C : forall a:A, B a -&gt; Type}
           {x1 x2 : A} (p : x1 = x2) (yz : { y : B x1 &amp; C x1 y })
: transport (fun x =&gt; { y : B x &amp; C x y }) p yz
  = (p # yz.1 ; transportD _ _ p yz.1 yz.2).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 334
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 335
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  destruct p.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 336
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>  destruct yz as [y z].</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 336
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> reflexivity.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 336
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.

(** The special case when the second variable doesn't depend on the first is simpler. *)</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 339
Time: 0.001s">
<div class="time" style="width: 3.3333333333333%"></div>
<pre>Definition transport_sigma' {A B : Type} {C : A -&gt; B -&gt; Type}
           {x1 x2 : A} (p : x1 = x2) (yz : { y : B &amp; C x1 y })
: transport (fun x =&gt; { y : B &amp; C x y }) p yz =
  (yz.1 ; transport (fun x =&gt; C x yz.1) p yz.2).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 342
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 343
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  destruct p.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 344
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> destruct yz.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 344
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> reflexivity.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 344
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.

(** Or if the second variable contains a first component that doesn't depend on the first.  Need to think about the naming of these. *)

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 348
Time: 0.002s">
<div class="time" style="width: 6.6666666666667%"></div>
<pre>Definition transport_sigma_' {A : Type} {B C : A -&gt; Type}
           {D : forall a:A, B a -&gt; C a -&gt; Type}
           {x1 x2 : A} (p : x1 = x2)
           (yzw : { y : B x1 &amp; { z : C x1 &amp; D x1 y z } })
: transport (fun x =&gt; { y : B x &amp; { z : C x &amp; D x y z } }) p yzw
  = (p # yzw.1 ; p # yzw.2.1 ; transportD2 _ _ _ p yzw.1 yzw.2.1 yzw.2.2).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 353
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 354
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  destruct p.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 355
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> reflexivity.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 355
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.

(** ** Functorial action *)

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 359
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Definition functor_sigma `{P : A -&gt; Type} `{Q : B -&gt; Type}
           (f : A -&gt; B) (g : forall a, P a -&gt; Q (f a))
: sigT P -&gt; sigT Q
  := fun u =&gt; (f u.1 ; g u.1 u.2).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 362
Time: 0.004s">
<div class="time" style="width: 13.333333333333%"></div>
<pre>

Definition ap_functor_sigma `{P : A -&gt; Type} `{Q : B -&gt; Type}
           (f : A -&gt; B) (g : forall a, P a -&gt; Q (f a))
           (u v : sigT P) (p : u.1 = v.1) (q : p # u.2 = v.2)
: ap (functor_sigma f g) (path_sigma P u v p q)
  = path_sigma Q (functor_sigma f g u) (functor_sigma f g v)
               (ap f p)
               ((transport_compose Q f p (g u.1 u.2))^
                @ (@ap_transport _ P (fun x =&gt; Q (f x)) _ _ p g u.2)^
                @ ap (g v.1) q).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 372
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 373
Time: 0.004s">
<div class="time" style="width: 13.333333333333%"></div>
<pre>
  destruct u as [u1 u2]; destruct v as [v1 v2]; simpl in p, q.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 374
Time: 0.002s">
<div class="time" style="width: 6.6666666666667%"></div>
<pre>
  destruct p; simpl in q.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 375
Time: 0.002s">
<div class="time" style="width: 6.6666666666667%"></div>
<pre>
  destruct q.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 376
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  reflexivity.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 377
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.

(** ** Equivalences *)

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 381
Time: 0.001s">
<div class="time" style="width: 3.3333333333333%"></div>
<pre>Global Instance isequiv_functor_sigma `{P : A -&gt; Type} `{Q : B -&gt; Type}
         `{IsEquiv A B f} `{forall a, @IsEquiv (P a) (Q (f a)) (g a)}
: IsEquiv (functor_sigma f g) | 1000.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 383
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 384
Time: 0.002s">
<div class="time" style="width: 6.6666666666667%"></div>
<pre>
  refine (isequiv_adjointify (functor_sigma f g)
                             (functor_sigma (f^-1)
                                            (fun x y =&gt; ((g (f^-1 x))^-1 ((eisretr f x)^ # y)))) _ _);
  intros [x y].</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 388
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 389
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> refine (path_sigma' _ (eisretr f x) _); simpl.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 389
Time: 0.002s">
<div class="time" style="width: 6.6666666666667%"></div>
<pre>
    abstract (
        rewrite (eisretr (g (f^-1 x)));
        apply transport_pV
      ).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 393
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 394
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> refine (path_sigma' _ (eissect f x) _); simpl.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 394
Time: 0.001s">
<div class="time" style="width: 3.3333333333333%"></div>
<pre>
    refine ((ap_transport (eissect f x) (fun x' =&gt; (g x') ^-1)
                          (transport Q (eisretr f (f x)) ^ (g x y)))^ @ _).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 396
Time: 0.004s">
<div class="time" style="width: 13.333333333333%"></div>
<pre>
    abstract (
        rewrite transport_compose, eisadj, transport_pV;
        apply eissect
      ).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 400
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 402
Time: 0.004s">
<div class="time" style="width: 13.333333333333%"></div>
<pre>Definition equiv_functor_sigma `{P : A -&gt; Type} `{Q : B -&gt; Type}
           (f : A -&gt; B) `{IsEquiv A B f}
           (g : forall a, P a -&gt; Q (f a))
           `{forall a, @IsEquiv (P a) (Q (f a)) (g a)}
: sigT P &lt;~&gt; sigT Q
  := BuildEquiv _ _ (functor_sigma f g) _.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 407
Time: 0.003s">
<div class="time" style="width: 10%"></div>
<pre>

Definition equiv_functor_sigma' `{P : A -&gt; Type} `{Q : B -&gt; Type}
           (f : A &lt;~&gt; B)
           (g : forall a, P a &lt;~&gt; Q (f a))
: sigT P &lt;~&gt; sigT Q
  := equiv_functor_sigma f g.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 413
Time: 0.001s">
<div class="time" style="width: 3.3333333333333%"></div>
<pre>

Definition equiv_functor_sigma_id `{P : A -&gt; Type} `{Q : A -&gt; Type}
           (g : forall a, P a &lt;~&gt; Q a)
: sigT P &lt;~&gt; sigT Q
  := equiv_functor_sigma' 1 g.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 418
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Lemma 3.11.9(i): Summing up a contractible family of types does nothing. *)

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 421
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Global Instance isequiv_pr1_contr {A} {P : A -&gt; Type}
         `{forall a, Contr (P a)}
: IsEquiv (@pr1 A P) | 100.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 423
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 424
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  refine (isequiv_adjointify (@pr1 A P)
                             (fun a =&gt; (a ; center (P a))) _ _).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 426
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 427
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros a; reflexivity.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 427
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 428
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros [a p].</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 428
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    refine (path_sigma' P 1 (contr _)).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 429
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 431
Time: 0.001s">
<div class="time" style="width: 3.3333333333333%"></div>
<pre>Definition equiv_sigma_contr {A : Type} (P : A -&gt; Type)
           `{forall a, Contr (P a)}
: sigT P &lt;~&gt; A
  := BuildEquiv _ _ pr1 _.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 434
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Lemma 3.11.9(ii): Dually, summing up over a contractible type does nothing. *)

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 437
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Definition equiv_contr_sigma {A : Type} (P : A -&gt; Type) `{Contr A}
: { x : A &amp; P x } &lt;~&gt; P (center A).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 438
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 439
Time: 0.001s">
<div class="time" style="width: 3.3333333333333%"></div>
<pre>
  refine (equiv_adjointify (fun xp =&gt; (contr xp.1)^ # xp.2)
                           (fun p =&gt; (center A ; p)) _ _).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 441
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 442
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros p; simpl.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 442
Time: 0.001s">
<div class="time" style="width: 3.3333333333333%"></div>
<pre>
    exact (ap (fun q =&gt; q # p) (path_contr _ 1)).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 443
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 444
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros [a p].</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 444
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    refine (path_sigma' _ (contr a) _).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 445
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply transport_pV.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 446
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.

(** ** Associativity *)

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 450
Time: 0.011s">
<div class="time" style="width: 36.666666666667%"></div>
<pre>Definition equiv_sigma_assoc `(P : A -&gt; Type) (Q : {a : A &amp; P a} -&gt; Type)
: {a : A &amp; {p : P a &amp; Q (a;p)}} &lt;~&gt; sigT Q
  := @BuildEquiv
       _ _ _
       (@BuildIsEquiv
          {a : A &amp; {p : P a &amp; Q (a;p)}} (sigT Q)
          (fun apq =&gt; ((apq.1; apq.2.1); apq.2.2))
          (fun apq =&gt; (apq.1.1; (apq.1.2; apq.2)))
          (fun _ =&gt; 1)
          (fun _ =&gt; 1)
          (fun _ =&gt; 1)).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 460
Time: 0.008s">
<div class="time" style="width: 26.666666666667%"></div>
<pre>

Definition equiv_sigma_prod `(Q : (A * B) -&gt; Type)
: {a : A &amp; {b : B &amp; Q (a,b)}} &lt;~&gt; sigT Q
  := @BuildEquiv
       _ _ _
       (@BuildIsEquiv
          {a : A &amp; {b : B &amp; Q (a,b)}} (sigT Q)
          (fun apq =&gt; ((apq.1, apq.2.1); apq.2.2))
          (fun apq =&gt; (fst apq.1; (snd apq.1; apq.2)))
          (fun _ =&gt; 1)
          (fun _ =&gt; 1)
          (fun _ =&gt; 1)).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 472
Time: 0.003s">
<div class="time" style="width: 10%"></div>
<pre>

Definition equiv_sigma_prod0 A B
: {a : A &amp; B} &lt;~&gt; A * B
  := BuildEquiv _ _ _
       (BuildIsEquiv
          {a : A &amp; B} (A * B)
          (fun (ab : {a:A &amp; B}) =&gt; (ab.1 , ab.2))
          (fun (ab : A*B) =&gt; (fst ab ; snd ab))
          (fun _ =&gt; 1) (fun _ =&gt; 1) (fun _ =&gt; 1)).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 481
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Symmetry *)

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 484
Time: 0.003s">
<div class="time" style="width: 10%"></div>
<pre>Definition equiv_sigma_symm `(P : A -&gt; B -&gt; Type)
: {a : A &amp; {b : B &amp; P a b}} &lt;~&gt; {b : B &amp; {a : A &amp; P a b}}
  := ((equiv_sigma_prod (fun x =&gt; P (snd x) (fst x)))^-1)
       oE (equiv_functor_sigma' (equiv_prod_symm A B)
                                (fun x =&gt; equiv_idmap (P (fst x) (snd x))))
       oE (equiv_sigma_prod (fun x =&gt; P (fst x) (snd x))).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 489
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Definition equiv_sigma_symm0 (A B : Type)
: {a : A &amp; B} &lt;~&gt; {b : B &amp; A}.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 492
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 493
Time: 0.002s">
<div class="time" style="width: 6.6666666666667%"></div>
<pre>
  refine (BuildEquiv _ _ (fun (w:{a:A &amp; B}) =&gt; (w.2 ; w.1)) _).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 494
Time: 0.003s">
<div class="time" style="width: 10%"></div>
<pre>
  simple refine (BuildIsEquiv _ _ _ (fun (z:{b:B &amp; A}) =&gt; (z.2 ; z.1))
                       _ _ _); intros [x y]; reflexivity.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 496
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.

(** ** Universal mapping properties *)

(** *** The positive universal property. *)</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 501
Time: 0.002s">
<div class="time" style="width: 6.6666666666667%"></div>
<pre>Global Instance isequiv_sigT_ind `{P : A -&gt; Type}
         (Q : sigT P -&gt; Type)
: IsEquiv (sigT_ind Q) | 0
  := BuildIsEquiv
       _ _
       (sigT_ind Q)
       (fun f x y =&gt; f (x;y))
       (fun _ =&gt; 1)
       (fun _ =&gt; 1)
       (fun _ =&gt; 1).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 510
Time: 0.001s">
<div class="time" style="width: 3.3333333333333%"></div>
<pre>

Definition equiv_sigT_ind `{P : A -&gt; Type}
           (Q : sigT P -&gt; Type)
: (forall (x:A) (y:P x), Q (x;y)) &lt;~&gt; (forall xy, Q xy)
  := BuildEquiv _ _ (sigT_ind Q) _.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 515
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** *** The negative universal property. *)

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 518
Time: 0.001s">
<div class="time" style="width: 3.3333333333333%"></div>
<pre>Definition sigT_coind_uncurried
           `{A : X -&gt; Type} (P : forall x, A x -&gt; Type)
: { f : forall x, A x &amp; forall x, P x (f x) }
  -&gt; (forall x, sigT (P x))
  := fun fg =&gt; fun x =&gt; (fg.1 x ; fg.2 x).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 522
Time: 0.001s">
<div class="time" style="width: 3.3333333333333%"></div>
<pre>

Definition sigT_coind
           `{A : X -&gt; Type} (P : forall x, A x -&gt; Type)
           (f : forall x, A x) (g : forall x, P x (f x))
: (forall x, sigT (P x))
  := sigT_coind_uncurried P (f;g).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 528
Time: 0.004s">
<div class="time" style="width: 13.333333333333%"></div>
<pre>

Global Instance isequiv_sigT_coind
         `{A : X -&gt; Type} {P : forall x, A x -&gt; Type}
: IsEquiv (sigT_coind_uncurried P) | 0
  := BuildIsEquiv
       _ _
       (sigT_coind_uncurried P)
       (fun h =&gt; existT (fun f =&gt; forall x, P x (f x))
                        (fun x =&gt; (h x).1)
                        (fun x =&gt; (h x).2))
       (fun _ =&gt; 1)
       (fun _ =&gt; 1)
       (fun _ =&gt; 1).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 541
Time: 0.001s">
<div class="time" style="width: 3.3333333333333%"></div>
<pre>

Definition equiv_sigT_coind
           `(A : X -&gt; Type) (P : forall x, A x -&gt; Type)
: { f : forall x, A x &amp; forall x, P x (f x) }
    &lt;~&gt; (forall x, sigT (P x))
  := BuildEquiv _ _ (sigT_coind_uncurried P) _.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 547
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Sigmas preserve truncation *)

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 550
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Global Instance trunc_sigma `{P : A -&gt; Type}
         `{IsTrunc n A} `{forall a, IsTrunc n (P a)}
: IsTrunc n (sigT P) | 100.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 552
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 553
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  generalize dependent A.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 554
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  induction n; simpl; intros A P ac Pc.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 555
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  {</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 556
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> exists (center A; center (P (center A))).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 556
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    intros [a ?].</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 557
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    refine (path_sigma' P (contr a) (path_contr _ _)).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 558
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> }</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 558
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  {</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 559
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros u v.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 559
Time: 0.002s">
<div class="time" style="width: 6.6666666666667%"></div>
<pre>
    refine (trunc_equiv _ (path_sigma_uncurried P u v)).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 560
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> }</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 560
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.

(** The sigma of an arbitrary family of *disjoint* hprops is an hprop. *)</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 563
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Definition ishprop_sigma_disjoint
           `{P : A -&gt; Type} `{forall a, IsHProp (P a)}
: (forall x y, P x -&gt; P y -&gt; x = y) -&gt; IsHProp { x : A &amp; P x }.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 565
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 566
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  intros dj; apply hprop_allpath; intros [x px] [y py].</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 567
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  refine (path_sigma' P (dj x y px py) _).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 568
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  apply path_ishprop.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 569
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.

(** ** Subtypes (sigma types whose second components are hprops) *)

(** To prove equality in a subtype, we only need equality of the first component. *)</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 574
Time: 0.003s">
<div class="time" style="width: 10%"></div>
<pre>Definition path_sigma_hprop {A : Type} {P : A -&gt; Type}
           `{forall x, IsHProp (P x)}
           (u v : sigT P)
: u.1 = v.1 -&gt; u = v
  := path_sigma_uncurried P u v o pr1^-1.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 578
Time: 0.003s">
<div class="time" style="width: 10%"></div>
<pre>

Global Instance isequiv_path_sigma_hprop {A P} `{forall x : A, IsHProp (P x)} {u v : sigT P}
: IsEquiv (@path_sigma_hprop A P _ u v) | 100
  := isequiv_compose.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 582
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Hint Immediate isequiv_path_sigma_hprop : typeclass_instances.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 584
Time: 0.011s">
<div class="time" style="width: 36.666666666667%"></div>
<pre>

Definition equiv_path_sigma_hprop {A : Type} {P : A -&gt; Type}
           {HP : forall a, IsHProp (P a)} (u v : sigT P)
: (u.1 = v.1) &lt;~&gt; (u = v)
  := BuildEquiv _ _ (path_sigma_hprop _ _) _.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 589
Time: 0.009s">
<div class="time" style="width: 30%"></div>
<pre>

Definition isequiv_pr1_path_hprop {A} {P : A -&gt; Type}
         `{forall a, IsHProp (P a)}
         x y
: IsEquiv (@pr1_path A P x y)
  := _ : IsEquiv (path_sigma_hprop x y)^-1.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 595
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Hint Immediate isequiv_pr1_path_hprop : typeclass_instances.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 597
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** We define this for ease of [SearchAbout IsEquiv ap pr1] *)</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 599
Time: 0.002s">
<div class="time" style="width: 6.6666666666667%"></div>
<pre>Definition isequiv_ap_pr1_hprop {A} {P : A -&gt; Type}
           `{forall a, IsHProp (P a)}
           x y
: IsEquiv (@ap _ _ (@pr1 A P) x y)
  := _.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 603
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>


(** [path_sigma_hprop] is functorial *)</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 606
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Definition path_sigma_hprop_1 {A : Type} {P : A -&gt; Type}
           `{forall x, IsHProp (P x)} (u : sigT P)
: path_sigma_hprop u u 1 = 1.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 608
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 609
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  unfold path_sigma_hprop.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 610
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  unfold isequiv_pr1_contr; simpl.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 611
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  (** Ugh *)
 </pre>
</div>
<div class="code" title="File: Sigma.v
Line: 613
Time: 0.001s">
<div class="time" style="width: 3.3333333333333%"></div>
<pre>refine (ap (fun p =&gt; match p in (_ = v2) return (u = (u.1; v2)) with 1 =&gt; 1 end)
             (contr (idpath u.2))).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 614
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 616
Time: 0.001s">
<div class="time" style="width: 3.3333333333333%"></div>
<pre>Definition path_sigma_hprop_V {A : Type} {P : A -&gt; Type}
           `{forall x, IsHProp (P x)} {a b : A} (p : a = b)
           (x : P a) (y : P b)
: path_sigma_hprop (b;y) (a;x) p^ = (path_sigma_hprop (a;x) (b;y) p)^.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 619
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 620
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  destruct p; simpl.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 621
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  rewrite (path_ishprop x y).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 622
Time: 0.001s">
<div class="time" style="width: 3.3333333333333%"></div>
<pre>
  refine (path_sigma_hprop_1 _ @ (ap inverse (path_sigma_hprop_1 _))^).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 623
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Qed.

</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 625
Time: 0.002s">
<div class="time" style="width: 6.6666666666667%"></div>
<pre>Definition path_sigma_hprop_pp
           {A : Type}
           {P : A -&gt; Type}
           `{forall x, IsHProp (P x)}
           {a b c : A}
           (p : a = b) (q : b = c)
           (x : P a) (y : P b) (z : P c)
: path_sigma_hprop (a;x) (c;z) (p @ q)
    =
  path_sigma_hprop (a;x) (b;y) p @ path_sigma_hprop (b;y) (c;z) q.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 634
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 635
Time: 0.001s">
<div class="time" style="width: 3.3333333333333%"></div>
<pre>
  destruct p, q.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 636
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  rewrite (path_ishprop y x).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 637
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  rewrite (path_ishprop z x).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 638
Time: 0.001s">
<div class="time" style="width: 3.3333333333333%"></div>
<pre>
  refine (_ @ (ap (fun z =&gt; z @ _) (path_sigma_hprop_1 _))^).</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 639
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  apply (concat_1p _)^.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 640
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Qed.

(** The inverse of [path_sigma_hprop] has its own name, so we give special names to the section and retraction homotopies to help [rewrite] out. *)</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 643
Time: 0.009s">
<div class="time" style="width: 30%"></div>
<pre>Definition path_sigma_hprop_ap_pr1 {A : Type} {P : A -&gt; Type}
           `{forall x, IsHProp (P x)} (u v : sigT P) (p : u = v)
: path_sigma_hprop u v (ap pr1 p) = p
  := eisretr (path_sigma_hprop u v) p.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 646
Time: 0.009s">
<div class="time" style="width: 30%"></div>
<pre>
Definition path_sigma_hprop_pr1_path {A : Type} {P : A -&gt; Type}
           `{forall x, IsHProp (P x)} (u v : sigT P) (p : u = v)
: path_sigma_hprop u v p..1 = p
  := eisretr (path_sigma_hprop u v) p.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 650
Time: 0.005s">
<div class="time" style="width: 16.666666666667%"></div>
<pre>
Definition ap_pr1_path_sigma_hprop {A : Type} {P : A -&gt; Type}
           `{forall x, IsHProp (P x)} (u v : sigT P) (p : u.1 = v.1)
: ap pr1 (path_sigma_hprop u v p) = p
  := eissect (path_sigma_hprop u v) p.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 654
Time: 0.005s">
<div class="time" style="width: 16.666666666667%"></div>
<pre>
Definition pr1_path_path_sigma_hprop {A : Type} {P : A -&gt; Type}
           `{forall x, IsHProp (P x)} (u v : sigT P) (p : u.1 = v.1)
: (path_sigma_hprop u v p)..1 = p
  := eissect (path_sigma_hprop u v) p.</pre>
</div>
<div class="code" title="File: Sigma.v
Line: 659
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

</pre>
</div>
</body>
</html>

