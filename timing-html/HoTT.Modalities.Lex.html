<html>
<head>
<title>Lex.v</title>
<style>
.time {
  background-color: #ffaaaa;
  height: 100%;
  z-index: -1;
  position: absolute;
}
.code {
  z-index: 0;
  position: relative;
  border-style: solid;
  border-color: transparent;
  border-width: 1px;
}
.code:hover {
  border-style: solid;
  border-color: black;
  border-width: 1px;
}
pre {
  margin: 1px;
}
</style>
</head>
<body>
<h1>Timings for Lex.v</h1>

<div class="code" title="File: Lex.v
Line: 1
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>(* -*- mode: coq; mode: visual-line -*- *)</pre>
</div>
<div class="code" title="File: Lex.v
Line: 1
Time: 0.04s">
<div class="time" style="width: 3.147128245476%"></div>
<pre>Require Import HoTT.Basics HoTT.Types.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 1
Time: 0.023s">
<div class="time" style="width: 1.8095987411487%"></div>
<pre>
Require Import EquivalenceVarieties Fibrations Extensions Pullback NullHomotopy Factorization UnivalenceImpliesFunext.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 2
Time: 0.02s">
<div class="time" style="width: 1.573564122738%"></div>
<pre>
Require Import Modality Accessible.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 3
Time: 0.001s">
<div class="time" style="width: 0.0786782061369%"></div>
<pre>
Require Import HoTT.Tactics.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 4
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Local Open Scope path_scope.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 6
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>


(** * Lex modalities *)

(** ** Basic theory *)

(** A lex modality is one that preserves finite limits, or equivalently pullbacks.  It turns out that a more basic and useful way to say this is that all path-spaces of connected types are connected.  Note how different this is from the behavior of, say, truncation modalities!

  This is a "large" definition, and we don't know of any small one that's equivalent to it (see &lt;https://mathoverflow.net/questions/185980/a-small-definition-of-sub-âˆž-1-topoi&gt;.  However, so far we never need to apply it "at multiple universes at once".  Thus, rather than making it a module type, we can make it a typeclass and rely on ordinary universe polymorphism. *)

</pre>
</div>
<div class="code" title="File: Lex.v
Line: 16
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Module Lex_Modalities_Theory (Os : Modalities).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 16
Time: 0.149s">
<div class="time" style="width: 11.723052714398%"></div>
<pre>

  Module Export Os_Theory := Modalities_Theory Os.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 18
Time: 0.002s">
<div class="time" style="width: 0.1573564122738%"></div>
<pre>

  Class Lex (O : Modality@{u a})
    := isconnected_paths : forall (A : Type@{i}) (x y : A),
                             IsConnected@{u a i} O A -&gt;
                             IsConnected@{u a i} O (x = y).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 23
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  Global Existing Instance isconnected_paths.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 25
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** The following numbered lemmas are all actually equivalent characterizations of lex-ness.  We prove this for some of them, but we don't make the reverse implications Instances; usually [isconnected_paths] is the easier way to prove lexness. *)

  (** 1. Every map between connected types is a connected map. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 30
Time: 0.001s">
<div class="time" style="width: 0.0786782061369%"></div>
<pre>Global Instance conn_map_lex {O : Modality} `{Lex O}
         {A : Type@{i}} {B : Type@{j}} {f : A -&gt; B}
         `{IsConnected O A} `{IsConnected O B}
  : IsConnMap O f.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 33
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 34
Time: 0.013s">
<div class="time" style="width: 1.0228166797797%"></div>
<pre>
    intros b; refine (isconnected_sigma O).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 35
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 36
Time: 0.001s">
<div class="time" style="width: 0.0786782061369%"></div>
<pre>

  Definition lex_from_conn_map_lex {O : Modality}
             (H : forall A B (f : A -&gt; B),
                         (IsConnected O A) -&gt; (IsConnected O B) -&gt;
                         IsConnMap O f)
    : Lex O.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 42
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 43
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    intros A x y AC.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 44
Time: 0.002s">
<div class="time" style="width: 0.1573564122738%"></div>
<pre>
    refine (isconnected_equiv' O (hfiber (unit_name x) y) _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 45
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    unfold hfiber.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 46
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    refine (equiv_contr_sigma (fun _ =&gt; x = y)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 47
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 48
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** 2. Connected maps are left- as well as right-cancellable. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 51
Time: 0.002s">
<div class="time" style="width: 0.1573564122738%"></div>
<pre>Definition cancelL_conn_map (O : Modality) `{Lex O}
             {A B C : Type} (f : A -&gt; B) (g : B -&gt; C)
  : IsConnMap O g -&gt; IsConnMap O (g o f) -&gt; IsConnMap O f.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 53
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 54
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    intros ? ? b.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 55
Time: 0.043s">
<div class="time" style="width: 3.3831628638867%"></div>
<pre>
    refine (isconnected_equiv O _ (hfiber_hfiber_compose_map f g b) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 56
Time: 0.001s">
<div class="time" style="width: 0.0786782061369%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 57
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** 3. Every map inverted by [O] is [O]-connected. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 60
Time: 0.001s">
<div class="time" style="width: 0.0786782061369%"></div>
<pre>Definition isconnected_O_inverts (O : Modality) `{Lex O}
             {A B : Type} (f : A -&gt; B) `{O_inverts O f}
  : IsConnMap O f.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 62
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 63
Time: 0.07s">
<div class="time" style="width: 5.507474429583%"></div>
<pre>
    refine (cancelL_conn_map O f (to O B) _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 64
Time: 0.024s">
<div class="time" style="width: 1.8882769472856%"></div>
<pre>
    refine (conn_map_homotopic O _ _ (to_O_natural O f) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 65
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    (** Typeclass magic! *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 67
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 67
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** 4. Connected types are closed under pullbacks.  (Closure under fibers is [conn_map_lex] above. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 70
Time: 0.001s">
<div class="time" style="width: 0.0786782061369%"></div>
<pre>Global Instance isconnected_pullback (O : Modality) `{Lex O}
         {A B C : Type} {f : A -&gt; C} {g : B -&gt; C}
         `{IsConnected O A} `{IsConnected O B} `{IsConnected O C}
  : IsConnected O (Pullback f g).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 73
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 74
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply isconnected_sigma; [ exact _ | intros a ].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 75
Time: 0.009s">
<div class="time" style="width: 0.7081038552321%"></div>
<pre>
    refine (isconnected_equiv O (hfiber g (f a))
                              (equiv_functor_sigma' (equiv_idmap _)
                              (fun b =&gt; equiv_path_inverse _ _))
                              _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 79
Time: 0.001s">
<div class="time" style="width: 0.0786782061369%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 80
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** 5. The reflector preserves pullbacks.  This justifies the terminology "lex". *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 83
Time: 0.003s">
<div class="time" style="width: 0.2360346184107%"></div>
<pre>Definition O_functor_pullback (O : Modality) `{Lex O}
             {A B C} (f : B -&gt; A) (g : C -&gt; A)
  : IsPullback (O_functor_square O _ _ _ _ (pullback_commsq f g)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 85
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 86
Time: 0.168s">
<div class="time" style="width: 13.217938630999%"></div>
<pre>
    refine (isequiv_O_inverts O _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 87
Time: 0.05s">
<div class="time" style="width: 3.933910306845%"></div>
<pre>
    refine (O_inverts_conn_map O _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 88
Time: 0.245s">
<div class="time" style="width: 19.276160503541%"></div>
<pre>
    refine (cancelR_conn_map O (to O (Pullback f g)) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 89
Time: 0.121s">
<div class="time" style="width: 9.5200629425649%"></div>
<pre>
    refine (conn_map_homotopic O
             (functor_pullback f g (O_functor O f) (O_functor O g)
                               (to O A) (to O B) (to O C)
                               (to_O_natural O f) (to_O_natural O g))
             _ _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 94
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    (** This *seems* like it ought to be the easier goal, but it turns out to involve lots of naturality wrangling.  If we ever want to make real use of this theorem, we might want to separate out this goal into an opaque lemma so we could make the main theorem transparent. *)
   </pre>
</div>
<div class="code" title="File: Lex.v
Line: 96
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>-</pre>
</div>
<div class="code" title="File: Lex.v
Line: 96
Time: 0.005s">
<div class="time" style="width: 0.3933910306845%"></div>
<pre> intros [b [c e]];
        unfold functor_pullback, functor_sigma, pullback_corec;
        simpl.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 98
Time: 0.003s">
<div class="time" style="width: 0.2360346184107%"></div>
<pre>
      refine (path_sigma' _ (to_O_natural O pullback_pr1 (b;(c;e)))^ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 99
Time: 0.01s">
<div class="time" style="width: 0.786782061369%"></div>
<pre>
      rewrite transport_sigma'; simpl.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 100
Time: 0.002s">
<div class="time" style="width: 0.1573564122738%"></div>
<pre>
      refine (path_sigma' _ (to_O_natural O pullback_pr2 (b;(c;e)))^ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 101
Time: 0.007s">
<div class="time" style="width: 0.5507474429583%"></div>
<pre>
      rewrite transport_paths_Fl.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 102
Time: 0.007s">
<div class="time" style="width: 0.5507474429583%"></div>
<pre>
      rewrite transport_paths_Fr.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 103
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      Open Scope long_path_scope.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 104
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      unfold O_functor_square.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 105
Time: 0.14s">
<div class="time" style="width: 11.014948859166%"></div>
<pre>
      rewrite ap_V, inv_V, O_functor_homotopy_beta, !concat_p_pp.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 106
Time: 0.024s">
<div class="time" style="width: 1.8882769472856%"></div>
<pre>
      unfold pullback_commsq; simpl.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 107
Time: 0.154s">
<div class="time" style="width: 12.116443745083%"></div>
<pre>
      rewrite to_O_natural_compose, !concat_pp_p.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 108
Time: 0.016s">
<div class="time" style="width: 1.2588512981904%"></div>
<pre>
      do 3 apply whiskerL.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 109
Time: 0.014s">
<div class="time" style="width: 1.1014948859166%"></div>
<pre>
      rewrite ap_V, &lt;- inv_pp.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 110
Time: 0.021s">
<div class="time" style="width: 1.6522423288749%"></div>
<pre>
      rewrite &lt;- (inv_V (O_functor_compose _ _ _ _)), &lt;- inv_pp.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 111
Time: 0.004s">
<div class="time" style="width: 0.3147128245476%"></div>
<pre>
      apply inverse2, to_O_natural_compose.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 112
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      Close Scope long_path_scope.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 113
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    (** By contrast, this goal, which seems to contain all the mathematical content, is solved fairly easily by [hfiber_functor_pullback] and typeclass magic invoking [isconnected_pullback]. *)
   </pre>
</div>
<div class="code" title="File: Lex.v
Line: 115
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>-</pre>
</div>
<div class="code" title="File: Lex.v
Line: 115
Time: 0.003s">
<div class="time" style="width: 0.2360346184107%"></div>
<pre> intros [ob [oc oe]].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 115
Time: 1.271s">
<div class="time" style="width: 100%"></div>
<pre>
      refine (isconnected_equiv O _
                (hfiber_functor_pullback _ _ _ _ _ _ _ _ _ _)^-1 _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 117
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre></pre>
</div>
<div class="code" title="File: Lex.v
Line: 117
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      unfold O_functor_square.
      rewrite ap_V, inv_V, O_functor_homotopy_beta, !concat_p_pp.
      unfold pullback_commsq; simpl.
      rewrite to_O_natural_compose, !concat_pp_p.
      do 3 apply whiskerL.
      rewrite ap_V, &lt;- inv_pp.
      rewrite &lt;- (inv_V (O_functor_compose _ _ _ _)), &lt;- inv_pp.
      apply inverse2, to_O_natural_compose.
     </pre>
</div>
<div class="code" title="File: Lex.v
Line: 126
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Close Scope long_path_scope.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 126
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    (** By contrast, this goal, which seems to contain all the mathematical content, is solved fairly easily by [hfiber_functor_pullback] and typeclass magic invoking [isconnected_pullback]. *)
    - intros [ob [oc oe]].
      refine (isconnected_equiv O _
                (hfiber_functor_pullback _ _ _ _ _ _ _ _ _ _)^-1 _).
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 131
Time: 0.316s">
<div class="time" style="width: 24.86231313926%"></div>
<pre>Qed.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 131
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** 6. The reflector preserves fibers.  This is a slightly simpler version of the previous. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 134
Time: 0.001s">
<div class="time" style="width: 0.0786782061369%"></div>
<pre>Global Instance isequiv_O_functor_hfiber (O : Modality) `{Lex O}
             {A B} (f : A -&gt; B) (b : B)
  : IsEquiv (O_functor_hfiber O f b).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 136
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 137
Time: 0.185s">
<div class="time" style="width: 14.555468135327%"></div>
<pre>
    refine (isequiv_O_inverts O _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 138
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply O_inverts_conn_map.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 139
Time: 0.299s">
<div class="time" style="width: 23.524783634933%"></div>
<pre>
    refine (cancelR_conn_map O (to O _) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 140
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    unfold O_functor_hfiber.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 141
Time: 0.154s">
<div class="time" style="width: 12.116443745083%"></div>
<pre>
    refine (conn_map_homotopic O
             (@functor_hfiber _ _ _ _ f (O_functor O f)
                               (to O A) (to O B)
                               (fun x =&gt; (to_O_natural O f x)^) b)
             _ _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 146
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 147
Time: 0.002s">
<div class="time" style="width: 0.1573564122738%"></div>
<pre> intros [a p].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 147
Time: 0.003s">
<div class="time" style="width: 0.2360346184107%"></div>
<pre>
      rewrite O_rec_beta.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 148
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      unfold functor_hfiber, functor_sigma.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 149
Time: 0.005s">
<div class="time" style="width: 0.3933910306845%"></div>
<pre> apply ap.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 149
Time: 0.001s">
<div class="time" style="width: 0.0786782061369%"></div>
<pre>
      apply whiskerR, inv_V.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 150
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 151
Time: 0.001s">
<div class="time" style="width: 0.0786782061369%"></div>
<pre> intros [oa p].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 151
Time: 0.39s">
<div class="time" style="width: 30.684500393391%"></div>
<pre>
      refine (isconnected_equiv O _
               (hfiber_functor_hfiber _ _ _ _)^-1 _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 153
Time: 0.013s">
<div class="time" style="width: 1.0228166797797%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 154
Time: 0.01s">
<div class="time" style="width: 0.786782061369%"></div>
<pre>

  Definition equiv_O_functor_hfiber (O : Modality) `{Lex O}
             {A B} (f : A -&gt; B) (b : B)
  : O (hfiber f b) &lt;~&gt; hfiber (O_functor O f) (to O B b)
    := Build_Equiv _ _ (O_functor_hfiber O f b) _.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 159
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** 7. Lex modalities preserve path-spaces. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 162
Time: 0.003s">
<div class="time" style="width: 0.2360346184107%"></div>
<pre>Definition O_path_cmp (O : Modality) {A} (x y : A)
  : O (x = y) -&gt; (to O A x = to O A y)
    := O_rec (ap (to O A)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 164
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  Global Instance isequiv_O_path_cmp {O : Modality} `{Lex O} {A} (x y : A)
  : IsEquiv (O_path_cmp O x y).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 167
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 168
Time: 0.082s">
<div class="time" style="width: 6.4516129032258%"></div>
<pre>
    refine (isequiv_conn_ino_map O _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 169
Time: 0.223s">
<div class="time" style="width: 17.545239968529%"></div>
<pre>
    refine (cancelR_conn_map O (to O (x = y)) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 170
Time: 0.036s">
<div class="time" style="width: 2.8324154209284%"></div>
<pre>
    refine (conn_map_homotopic O (ap (to O A)) _ _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 171
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 172
Time: 0.002s">
<div class="time" style="width: 0.1573564122738%"></div>
<pre> intros ?; symmetry; by apply O_rec_beta.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 172
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 173
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros p.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 173
Time: 0.199s">
<div class="time" style="width: 15.656963021243%"></div>
<pre>
      refine (isconnected_equiv O _ (hfiber_ap p)^-1 _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 174
Time: 0.003s">
<div class="time" style="width: 0.2360346184107%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 175
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** 8. Any modal map between connected types is an equivalence. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 178
Time: 0.001s">
<div class="time" style="width: 0.0786782061369%"></div>
<pre>Global Instance isequiv_ismodal_isconnected_types
         {O : Modality} `{Lex O} {A B} {f : A -&gt; B}
         `{IsConnected O A} `{IsConnected O B} `{MapIn O _ _ f}
    : IsEquiv f.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 181
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 182
Time: 0.005s">
<div class="time" style="width: 0.3933910306845%"></div>
<pre>
    apply (isequiv_conn_ino_map O); exact _.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 183
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 184
Time: 0.001s">
<div class="time" style="width: 0.0786782061369%"></div>
<pre>

  Definition lex_from_isequiv_ismodal_isconnected_types
             {O : Modality}
             (H : forall A B (f : A -&gt; B),
                         (IsConnected O A) -&gt; (IsConnected O B) -&gt; 
                         (MapIn O f) -&gt; IsEquiv f)
    : Lex O.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 191
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 192
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply lex_from_conn_map_lex.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 193
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    intros A B f AC BC.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 194
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply (conn_map_homotopic O _ _ (fact_factors (image O f))).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 195
Time: 0.001s">
<div class="time" style="width: 0.0786782061369%"></div>
<pre>
    apply conn_map_compose; [ exact _ | ].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 196
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply conn_map_isequiv.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 197
Time: 0.001s">
<div class="time" style="width: 0.0786782061369%"></div>
<pre>
    apply H; [ | exact _ | exact _ ].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 198
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply isconnected_conn_map_to_unit.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 199
Time: 0.003s">
<div class="time" style="width: 0.2360346184107%"></div>
<pre>
    apply (cancelR_conn_map O (factor1 (image O f)) (const tt)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 200
Time: 0.001s">
<div class="time" style="width: 0.0786782061369%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 201
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** 9. Any commutative square with connected maps in one direction and modal ones in the other must necessarily be a pullback. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 204
Time: 0.003s">
<div class="time" style="width: 0.2360346184107%"></div>
<pre>Definition ispullback_connmap_mapino_commsq (O : Modality) `{Lex O} {A B C D}
             {f : A -&gt; B} {g : C -&gt; D} {h : A -&gt; C} {k : B -&gt; D}
             `{IsConnMap O _ _ f} `{IsConnMap O _ _ g}
             `{MapIn O _ _ h} `{MapIn O _ _ k}
             (p : k o f == g o h)
  : IsPullback p.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 209
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 210
Time: 0.036s">
<div class="time" style="width: 2.8324154209284%"></div>
<pre>
    refine (isequiv_conn_ino_map O (pullback_corec p)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 211
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 212
Time: 0.014s">
<div class="time" style="width: 1.1014948859166%"></div>
<pre> refine (cancelL_conn_map O (pullback_corec p) (k^* g) _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 212
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 213
Time: 0.114s">
<div class="time" style="width: 8.9693154996066%"></div>
<pre> refine (cancelL_mapinO O _ (equiv_pullback_symm k g) _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 213
Time: 0.003s">
<div class="time" style="width: 0.2360346184107%"></div>
<pre>
      refine (cancelL_mapinO O _ (g^* k) _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 214
Time: 0.002s">
<div class="time" style="width: 0.1573564122738%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 215
Time: 0.003s">
<div class="time" style="width: 0.2360346184107%"></div>
<pre>

  Definition lex_from_ispullback_connmap_mapino_commsq (O : Modality)
             (H : forall {A B C D}
                         (f : A -&gt; B) (g : C -&gt; D) (h : A -&gt; C) (k : B -&gt; D),
                 (IsConnMap O f) -&gt; (IsConnMap O g) -&gt;
                 (MapIn O h) -&gt; (MapIn O k) -&gt;
                 forall (p : k o f == g o h), IsPullback p)
    : Lex O.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 223
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 224
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply lex_from_isequiv_ismodal_isconnected_types.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 225
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    intros A B f AC BC fM.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 226
Time: 0.005s">
<div class="time" style="width: 0.3933910306845%"></div>
<pre>
    specialize (H A Unit B Unit (const tt) (const tt) f idmap _ _ _ _
               (fun _ =&gt; 1)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 228
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    unfold IsPullback, pullback_corec in H.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 229
Time: 0.013s">
<div class="time" style="width: 1.0228166797797%"></div>
<pre>
    refine (@isequiv_compose _ _ _ H _ (fun x =&gt; x.2.1) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 230
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    unfold Pullback.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 231
Time: 0.05s">
<div class="time" style="width: 3.933910306845%"></div>
<pre>
    refine (@isequiv_compose _ {b:Unit &amp; B}
                             (functor_sigma idmap (fun a =&gt; pr1))
                             _ _ pr2 _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 234
Time: 0.011s">
<div class="time" style="width: 0.8654602675059%"></div>
<pre>
    refine (@isequiv_compose _ _ (equiv_sigma_prod0 Unit B)
                             _ _ snd _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 236
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply (equiv_isequiv (prod_unit_l B)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 237
Time: 0.002s">
<div class="time" style="width: 0.1573564122738%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 238
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** 10. Families of modal types indexed by connected types are constant. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 241
Time: 0.001s">
<div class="time" style="width: 0.0786782061369%"></div>
<pre>Definition modal_over_connected_isconst_lex (O : Modality) `{Lex O}
             (A : Type) `{IsConnected O A} (P : A -&gt; Type) `{forall x, In O (P x)}
    : {Q : Type &amp; In O Q * forall x, P x &lt;~&gt; Q}.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 243
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 244
Time: 0.001s">
<div class="time" style="width: 0.0786782061369%"></div>
<pre>
    exists (O {x:A &amp; P x}); split; [ exact _ | intros x].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 245
Time: 0.033s">
<div class="time" style="width: 2.5963808025177%"></div>
<pre>
    refine (Build_Equiv _ _ (fun p =&gt; to O _ (x ; p)) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 246
Time: 0.03s">
<div class="time" style="width: 2.360346184107%"></div>
<pre>
    refine (isequiv_conn_map_ino O _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 247
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    revert x.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 248
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply conn_map_fiber.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 249
Time: 0.066s">
<div class="time" style="width: 5.1927616050354%"></div>
<pre>
    refine (cancelL_conn_map O _ (fun z:{x:A &amp; O {x : A &amp; P x}} =&gt; z.2) _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 250
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    intros z.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 251
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    refine (isconnected_equiv' O A _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 252
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    unfold hfiber.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 253
Time: 0.001s">
<div class="time" style="width: 0.0786782061369%"></div>
<pre>
    refine (equiv_adjointify (fun x =&gt; ((x ; z) ; 1))
                             (fun y =&gt; y.1.1) _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 255
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> 
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 256
Time: 0.007s">
<div class="time" style="width: 0.5507474429583%"></div>
<pre> intros [[x y] []]; reflexivity.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 256
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 257
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros x; reflexivity.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 257
Time: 0.007s">
<div class="time" style="width: 0.5507474429583%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 258
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** And conversely. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 261
Time: 0.001s">
<div class="time" style="width: 0.0786782061369%"></div>
<pre>Definition lex_from_modal_over_connected_isconst (O : Modality)
             (H : forall (A : Type) (P : A -&gt; Type),
                 (IsConnected O A) -&gt; (forall x, In O (P x)) -&gt;
                 {Q : Type &amp; In O Q * forall x, P x &lt;~&gt; Q})
    : Lex O.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 265
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 266
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    intros A x y ?.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 267
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply isconnected_from_elim_to_O.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 268
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    (** By assumption, [fun y =&gt; O (x = y) : A -&gt; Type_ O] is constant.  Thus, [to O (x=x) 1] can be transported around to make it contractible everywhere. *)
   </pre>
</div>
<div class="code" title="File: Lex.v
Line: 270
Time: 0.003s">
<div class="time" style="width: 0.2360346184107%"></div>
<pre>specialize (H A (fun z =&gt; O (x = z)) _ _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 270
Time: 0.001s">
<div class="time" style="width: 0.0786782061369%"></div>
<pre>
    destruct H as [Q [? H]].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 271
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    unfold NullHomotopy.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 272
Time: 0.002s">
<div class="time" style="width: 0.1573564122738%"></div>
<pre>
    exists ((H y)^-1 ((H x) (to O _ 1))).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 273
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    intros [].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 274
Time: 0.001s">
<div class="time" style="width: 0.0786782061369%"></div>
<pre>
    symmetry; apply eissect.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 275
Time: 0.001s">
<div class="time" style="width: 0.0786782061369%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 276
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** Lex modalities preserve [n]-types for all [n].  This is definitely not equivalent to lex-ness, since it is true for the truncation modalities that are not lex.  But it is also not true of all modalities; e.g. the shape modality in a cohesive topos can take 0-types to [oo]-types. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 279
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Global Instance istrunc_O_lex `{Funext} {O : Modality} `{Lex O}
         {n} {A} `{IsTrunc n A}
  : IsTrunc n (O A).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 281
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 282
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    generalize dependent A; simple_induction n n IHn; intros A ?.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 283
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 284
Time: 0.001s">
<div class="time" style="width: 0.0786782061369%"></div>
<pre> exact _.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 284
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>               (** Already proven for all modalities. *)
   </pre>
</div>
<div class="code" title="File: Lex.v
Line: 285
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>-</pre>
</div>
<div class="code" title="File: Lex.v
Line: 285
Time: 0.015s">
<div class="time" style="width: 1.1801730920535%"></div>
<pre> refine (O_ind (fun x =&gt; forall y, IsTrunc n (x = y)) _); intros x.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 285
Time: 0.006s">
<div class="time" style="width: 0.4720692368214%"></div>
<pre>
      refine (O_ind (fun y =&gt; IsTrunc n (to O A x = y)) _); intros y.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 286
Time: 0.006s">
<div class="time" style="width: 0.4720692368214%"></div>
<pre>
      refine (trunc_equiv _ (O_path_cmp O x y)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 287
Time: 0.002s">
<div class="time" style="width: 0.1573564122738%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 288
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

End Lex_Modalities_Theory.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 290
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Lex reflective subuniverses *)

(** A reflective subuniverse that preserves fibers is in fact a modality (and hence lex). *)</pre>
</div>
<div class="code" title="File: Lex.v
Line: 294
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Module Type Preserves_Fibers (Os : ReflectiveSubuniverses).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 294
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  Export Os.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 296
Time: 0.103s">
<div class="time" style="width: 8.1038552321007%"></div>
<pre>
  Module Export Os_Theory := ReflectiveSubuniverses_Theory Os.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 297
Time: 0.001s">
<div class="time" style="width: 0.0786782061369%"></div>
<pre>

  Parameter isequiv_O_functor_hfiber :
     forall (O : ReflectiveSubuniverse) {A B} (f : A -&gt; B) (b : B),
       IsEquiv (O_functor_hfiber O f b).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 301
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Existing Instance isequiv_O_functor_hfiber.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 302
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

End Preserves_Fibers.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 304
Time: 0.016s">
<div class="time" style="width: 1.2588512981904%"></div>
<pre>

Module Lex_Reflective_Subuniverses
       (Os : ReflectiveSubuniverses) (Opf : Preserves_Fibers Os)
  &lt;: SigmaClosed Os.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 308
Time: 0.001s">
<div class="time" style="width: 0.0786782061369%"></div>
<pre>

  Import Opf.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 310
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  Definition inO_sigma@{u a i j k} (O : ReflectiveSubuniverse@{u a})
             (A:Type@{i}) (B:A -&gt; Type@{j})
             (A_inO : In@{u a i} O A)
             (B_inO : forall a, In@{u a j} O (B a))
  : In@{u a k} O {x:A &amp; B x}.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 316
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 317
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    pose (g := O_rec@{u a k i k k i} pr1 : O {x : A &amp; B x} -&gt; A).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 318
Time: 0.005s">
<div class="time" style="width: 0.3933910306845%"></div>
<pre>
    transparent assert (p : (forall x, g (to O _ x) = x.1)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 319
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    {</pre>
</div>
<div class="code" title="File: Lex.v
Line: 320
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros x; subst g; apply O_rec_beta.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 320
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> }</pre>
</div>
<div class="code" title="File: Lex.v
Line: 320
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply inO_isequiv_to_O@{u a k k}.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 321
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply isequiv_fcontr; intros x.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 322
Time: 0.045s">
<div class="time" style="width: 3.5405192761605%"></div>
<pre>
    refine (contr_equiv' _ (hfiber_hfiber_compose_map@{k k i k k k k k} _ g x)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 323
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply fcontr_isequiv.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 324
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    unfold hfiber_compose_map.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 325
Time: 0.02s">
<div class="time" style="width: 1.573564122738%"></div>
<pre>
    transparent assert (h : (Equiv@{k k} (hfiber@{k i} (@pr1 A B) (g x))
                                         (hfiber@{k i} g (g x)))).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 327
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    {</pre>
</div>
<div class="code" title="File: Lex.v
Line: 328
Time: 0.002s">
<div class="time" style="width: 0.1573564122738%"></div>
<pre> refine (_ oE equiv_to_O@{u a k k} O _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 328
Time: 0.002s">
<div class="time" style="width: 0.1573564122738%"></div>
<pre>
      refine (_ oE Build_Equiv _ _
                (O_functor_hfiber O (@pr1 A B) (g x)) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 330
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      unfold hfiber.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 331
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      refine (equiv_functor_sigma' 1 _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 332
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros y; cbn.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 332
Time: 0.003s">
<div class="time" style="width: 0.2360346184107%"></div>
<pre>
      refine (_ oE (equiv_moveR_equiv_V _ _)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 333
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      apply equiv_concat_l.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 334
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      apply moveL_equiv_V.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 335
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      unfold g, O_functor.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 336
Time: 0.002s">
<div class="time" style="width: 0.1573564122738%"></div>
<pre>
      revert y; apply O_indpaths@{u a k i i k k}; intros [a q]; cbn.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 337
Time: 0.001s">
<div class="time" style="width: 0.0786782061369%"></div>
<pre>
      refine (_ @ (O_rec_beta _ _)^).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 338
Time: 0.001s">
<div class="time" style="width: 0.0786782061369%"></div>
<pre>
      apply ap, O_rec_beta.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 339
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> }</pre>
</div>
<div class="code" title="File: Lex.v
Line: 339
Time: 0.014s">
<div class="time" style="width: 1.1014948859166%"></div>
<pre>
    refine (isequiv_homotopic (h oE equiv_hfiber_homotopic _ _ p (g x)) _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 340
Time: 0.012s">
<div class="time" style="width: 0.9441384736428%"></div>
<pre>
    intros [[a b] q]; cbn.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 341
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> clear h.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 341
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    unfold O_functor_hfiber.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 342
Time: 0.014s">
<div class="time" style="width: 1.1014948859166%"></div>
<pre>
    rewrite O_rec_beta.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 343
Time: 0.006s">
<div class="time" style="width: 0.4720692368214%"></div>
<pre>
    unfold functor_sigma; cbn.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 344
Time: 0.001s">
<div class="time" style="width: 0.0786782061369%"></div>
<pre>
    refine (path_sigma' _ 1 _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 345
Time: 0.012s">
<div class="time" style="width: 0.9441384736428%"></div>
<pre>
    rewrite O_indpaths_beta; cbn.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 346
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    unfold moveL_equiv_V, moveR_equiv_V.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 347
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    Open Scope long_path_scope.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 348
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    Local Opaque eissect.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 349
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> (* work around bug 4533 *)
   </pre>
</div>
<div class="code" title="File: Lex.v
Line: 350
Time: 0.013s">
<div class="time" style="width: 1.0228166797797%"></div>
<pre>set (k := @eissect); change @eissect with k; subst k.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 350
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> (* work around bug 4543 *)
   </pre>
</div>
<div class="code" title="File: Lex.v
Line: 351
Time: 0.113s">
<div class="time" style="width: 8.8906372934697%"></div>
<pre>rewrite !ap_pp, !concat_p_pp, !ap_V.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 351
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    unfold to_O_natural.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 352
Time: 0.007s">
<div class="time" style="width: 0.5507474429583%"></div>
<pre>
    rewrite concat_pV_p.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 353
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    subst p.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 354
Time: 0.005s">
<div class="time" style="width: 0.3933910306845%"></div>
<pre>
    rewrite concat_pp_V.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 355
Time: 0.003s">
<div class="time" style="width: 0.2360346184107%"></div>
<pre>
    rewrite concat_pp_p; apply moveR_Vp.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 356
Time: 0.006s">
<div class="time" style="width: 0.4720692368214%"></div>
<pre>
    rewrite &lt;- !(ap_compose (to O A) (to O A)^-1).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 357
Time: 0.006s">
<div class="time" style="width: 0.4720692368214%"></div>
<pre>
    rapply @concat_A1p.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 358
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    Local Transparent eissect.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 359
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> (* work around bug 4533 *)
   </pre>
</div>
<div class="code" title="File: Lex.v
Line: 360
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Close Scope long_path_scope.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 360
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre></pre>
</div>
<div class="code" title="File: Lex.v
Line: 360
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    Local Opaque eissect.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 361
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> (* work around bug 4533 *)
    set (k := @eissect); change @eissect with k; subst k. (* work around bug 4543 *)
    rewrite !ap_pp, !concat_p_pp, !ap_V.
    unfold to_O_natural.
    rewrite concat_pV_p.
    subst p.
    rewrite concat_pp_V.
    rewrite concat_pp_p; apply moveR_Vp.
    rewrite &lt;- !(ap_compose (to O A) (to O A)^-1).
    rapply @concat_A1p.
   </pre>
</div>
<div class="code" title="File: Lex.v
Line: 371
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Local Transparent eissect.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 371
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> (* work around bug 4533 *)
   </pre>
</div>
<div class="code" title="File: Lex.v
Line: 372
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Close Scope long_path_scope.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 372
Time: 0.113s">
<div class="time" style="width: 8.8906372934697%"></div>
<pre>
  Qed.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 373
Time: 0.029s">
<div class="time" style="width: 2.2816679779701%"></div>
<pre>

End Lex_Reflective_Subuniverses.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 375
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Accessible lex modalities *)

(** We now restrict to lex modalities that are also accessible. *)</pre>
</div>
<div class="code" title="File: Lex.v
Line: 379
Time: 0.025s">
<div class="time" style="width: 1.9669551534225%"></div>
<pre>Module Accessible_Lex_Modalities_Theory
       (Os : Modalities)
       (Acc : Accessible_Modalities Os).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 381
Time: 0.151s">
<div class="time" style="width: 11.880409126672%"></div>
<pre>

  Module Export Acc_Theory := Accessible_Modalities_Theory Os Acc.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 383
Time: 0.136s">
<div class="time" style="width: 10.700236034618%"></div>
<pre>
  Module Export Lex_Theory := Lex_Modalities_Theory Os.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 384
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** Unfortunately, another subtlety of modules bites us here.  It appears that each application of a parametrized module to arguments creates a *new* module, and Coq has no algorithm (not even syntactic identity) for considering two such modules "the same".  In particular, the applications [Module Os_Theory := Modalities_Theory Os] that occur in both [Accessible_Modalities_Theory Os Acc] and [Lex_Modalities_Theory Os] create two *different* modules, which appear here as [Acc_Theory.Os_Theory] and [Lex_Theory.Os_Theory].  Thus, for instance, we have two different definitions [Acc_Theory.Os_Theory.O_ind] and [Lex_Theory.Os_Theory.O_ind], etc.

  Fortunately, since these duplicate pairs of definitions each have the same body *and are (usually) transparent*, Coq is willing to consider them identical.  Thus, this doesn't cause a great deal of trouble.  However, there are certain contexts in which this doesn't apply.  For instance, if any definition in [Modalities_Theory] is opaque, then Coq will be unable to notice that its duplicate copies in [Acc_Theory.Os_Theory] and [Lex_Theory.Os_Theory] were identical, potentially causing problems.  But since we generally only make definitions opaque if we aren't going to depend on their actual value anywhere else, this is unlikely to be much of an issue.

  A more serious issue is that there are some declarations that function up to a syntactic equality that is stricter than judgmental conversion.  For instance, [Inductive] and [Record] definitions, like modules, always create a new object not convertible to any previously existing one.  There are no [Inductive] or [Record] definitions in [Modalities_Theory], but there are [Class] declarations, and these function similarly.  In particular, typeclass search is unable to use [Instance]s defined in [Acc_Theory] to instantiate typeclasses from [Modalities_Theory] (such as [IsConnected]) needed by functions in [Lex_Theory], and vice versa.

  Fortunately, all the typeclasses defined in [Modalities_Theory] are *singleton* or *definitional* classes (defined with `:= unique_field` rather than `{ field1 ; field2 ; ... }`), which means that they do not actually introduce a new record wrapper.  Thus, the [Instance]s from [Acc_Theory] can in fact be typechecked to *belong* to the typeclasses needed by [Lex_Theory], and hence can be supplied (or [assert]ed) explicitly. *)

  (** Probably the most important thing about an accessible lex modality is that the universe of modal types is again modal.  Here by "the universe" we mean a universe large enough to contain the generating family; this is why we need accessibility. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 395
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Global Instance inO_typeO `{Univalence} (O : Modality) `{Lex O}
  : In O (Type_ O).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 396
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 397
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply (snd (inO_iff_isnull O _)); intros i n; simpl in *.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 398
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    assert (Lex_Theory.Os_Theory.RSU.IsConnected O (acc_gen O i))
      by exact (isconnected_acc_gen O i).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 400
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    destruct n; [ exact tt | split ].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 401
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 402
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros P.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 402
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      (** The case [n=0] is basically just one of the above characterizations of lex-ness. *)
     </pre>
</div>
<div class="code" title="File: Lex.v
Line: 404
Time: 0.005s">
<div class="time" style="width: 0.3933910306845%"></div>
<pre>destruct (modal_over_connected_isconst_lex O (acc_gen O i) P)
        as [Q [QinO f]].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 405
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      exists (fun _ =&gt; (Q ; QinO)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 406
Time: 0.002s">
<div class="time" style="width: 0.1573564122738%"></div>
<pre>
      intros x; symmetry; apply path_TypeO.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 407
Time: 0.003s">
<div class="time" style="width: 0.2360346184107%"></div>
<pre> 
      refine (path_universe (f x)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 408
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    -</pre>
</div>
<div class="code" title="File: Lex.v
Line: 409
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros A B.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 409
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      (** The case [n&gt;0] is actually quite easy, using univalence and the fact that modal types are closed under [Equiv]. *)
     </pre>
</div>
<div class="code" title="File: Lex.v
Line: 411
Time: 0.002s">
<div class="time" style="width: 0.1573564122738%"></div>
<pre>refine (extendable_postcompose' n _ _ _
                (fun b =&gt; (equiv_path_TypeO O (A b) (B b))
                            oE (equiv_path_universe (A b) (B b)))
                _).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 414
Time: 0.014s">
<div class="time" style="width: 1.1014948859166%"></div>
<pre>
      refine (extendable_conn_map_inO O n (@const (acc_gen O i) Unit tt)
                                      (fun b =&gt; A b &lt;~&gt; B b)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 416
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      (** Typeclass magic! *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 418
Time: 0.003s">
<div class="time" style="width: 0.2360346184107%"></div>
<pre>Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 418
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

  (** [inO_typeO] is also an equivalent characterization of lex-ness for a modality, by the converse of the characterization of lex-ness we used above. *)
 </pre>
</div>
<div class="code" title="File: Lex.v
Line: 421
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Definition lex_inO_typeO (O : Modality) `{In O (Type_ O)}
  : Lex O.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 422
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  Proof.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 423
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply lex_from_modal_over_connected_isconst.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 424
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    intros A P ? PO.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 425
Time: 0.002s">
<div class="time" style="width: 0.1573564122738%"></div>
<pre>
    destruct (isconnected_elim O (Type_ O) (fun x =&gt; (P x ; PO x)))
      as [Q f].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 427
Time: 0.001s">
<div class="time" style="width: 0.0786782061369%"></div>
<pre>
    exists Q; split; [ exact _ | intros x ].</pre>
</div>
<div class="code" title="File: Lex.v
Line: 428
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    apply equiv_path.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 429
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> 
    exact (ap pr1 (f x)).</pre>
</div>
<div class="code" title="File: Lex.v
Line: 430
Time: 0.001s">
<div class="time" style="width: 0.0786782061369%"></div>
<pre>
  Defined.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 431
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

End Accessible_Lex_Modalities_Theory.</pre>
</div>
<div class="code" title="File: Lex.v
Line: 434
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

</pre>
</div>
</body>
</html>

