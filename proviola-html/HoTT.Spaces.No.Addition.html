<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="coqdoc.css" type="text/css" rel="stylesheet">
<link href="proviola.css" type="text/css" rel="stylesheet">
<script type="text/javascript">
        var responses = new Array();

        function mouseover(id, scene) {
          set_response(get_response(id), scene);
        };

        function mouseout(scene) {
          set_response("", scene);
        };

        function set_array() {
          

            i = 0;
            data = "";
            responses[i]=data;
          

            i = 1;
            data = "";
            responses[i]=data;
          

            i = 2;
            data = "";
            responses[i]=data;
          

            i = 3;
            data = "";
            responses[i]=data;
          

            i = 4;
            data = "";
            responses[i]=data;
          

            i = 5;
            data = "";
            responses[i]=data;
          

            i = 6;
            data = "";
            responses[i]=data;
          

            i = 7;
            data = "";
            responses[i]=data;
          

            i = 8;
            data = "";
            responses[i]=data;
          

            i = 9;
            data = "";
            responses[i]=data;
          

            i = 10;
            data = "";
            responses[i]=data;
          

            i = 11;
            data = "";
            responses[i]=data;
          

            i = 12;
            data = "";
            responses[i]=data;
          

            i = 13;
            data = "";
            responses[i]=data;
          

            i = 14;
            data = "";
            responses[i]=data;
          

            i = 15;
            data = "";
            responses[i]=data;
          

            i = 16;
            data = "";
            responses[i]=data;
          

            i = 17;
            data = "";
            responses[i]=data;
          

            i = 18;
            data = "";
            responses[i]=data;
          

            i = 19;
            data = "<infomsg>HasAddition is defined</infomsg>	<infomsg>HasAddition_rect is defined</infomsg>	<infomsg>HasAddition_ind is defined</infomsg>	<infomsg>HasAddition_rec is defined</infomsg>	<infomsg>HasAddition_sind is defined</infomsg>	<infomsg>empty_options is defined</infomsg>	<infomsg>sum_options is defined</infomsg>	";
            responses[i]=data;
          

            i = 20;
            data = "";
            responses[i]=data;
          

            i = 21;
            data = "";
            responses[i]=data;
          

            i = 22;
            data = "<infomsg>hasaddition_maxsort is defined</infomsg>	";
            responses[i]=data;
          

            i = 23;
            data = "<infomsg>hasaddition_ordsort is defined</infomsg>	";
            responses[i]=data;
          

            i = 24;
            data = "1 subgoal (ID 18)	  	  ============================	  HasAddition DecSort	";
            responses[i]=data;
          

            i = 25;
            data = "";
            responses[i]=data;
          

            i = 26;
            data = "2 subgoals (ID 20)	  	  ============================	  InSort DecSort Empty Empty		subgoal 2 (ID 21) is:	 forall L R L' R' : Type,	 InSort DecSort L R ->	 InSort DecSort L' R' -> InSort DecSort (L + L') (R + R')	";
            responses[i]=data;
          

            i = 27;
            data = "1 subgoal (ID 20)	  	  ============================	  InSort DecSort Empty Empty	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 21)		subgoal 1 (ID 21) is:	 forall L R L' R' : Type,	 InSort DecSort L R ->	 InSort DecSort L' R' -> InSort DecSort (L + L') (R + R')	";
            responses[i]=data;
          

            i = 28;
            data = "1 subgoal (ID 21)	  	  ============================	  forall L R L' R' : Type,	  InSort DecSort L R ->	  InSort DecSort L' R' -> InSort DecSort (L + L') (R + R')	No more subgoals.	";
            responses[i]=data;
          

            i = 29;
            data = "";
            responses[i]=data;
          

            i = 30;
            data = "";
            responses[i]=data;
          

            i = 31;
            data = "<infomsg>H is declared</infomsg>	";
            responses[i]=data;
          

            i = 32;
            data = "<infomsg>S is declared</infomsg>	<infomsg>H0 is declared</infomsg>	";
            responses[i]=data;
          

            i = 33;
            data = "<infomsg>No is defined</infomsg>	";
            responses[i]=data;
          

            i = 34;
            data = "";
            responses[i]=data;
          

            i = 35;
            data = "<infomsg>L is declared</infomsg>	<infomsg>R is declared</infomsg>	<infomsg>Sx is declared</infomsg>	<infomsg>xL is declared</infomsg>	<infomsg>xR is declared</infomsg>	<infomsg>xcut is declared</infomsg>	";
            responses[i]=data;
          

            i = 36;
            data = "<infomsg>A is defined</infomsg>	";
            responses[i]=data;
          

            i = 37;
            data = "<infomsg>xL_plus is declared</infomsg>	<infomsg>xR_plus is declared</infomsg>	<infomsg>xL_lt_xR_plus is declared</infomsg>	";
            responses[i]=data;
          

            i = 38;
            data = "1 subgoal (ID 52)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  ============================	  {g	  : forall y : No,	    {x_plus_y : No &	    (forall l : L, (xL_plus l).1 y < x_plus_y) *	    (forall r : R, x_plus_y < (xR_plus r).1 y)} &	  (forall y z : No, y <= z -> (g y).1 <= (g z).1) *	  (forall y z : No, y < z -> (g y).1 < (g z).1)}	";
            responses[i]=data;
          

            i = 39;
            data = "";
            responses[i]=data;
          

            i = 40;
            data = "5 subgoals (ID 87)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  ============================	  forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	  (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	  (fxL : forall l : L0,	         (fun y : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	           (xL0 l))	  (fxR : forall r : R0,	         (fun y : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	           (xR0 r)),	  (forall (l : L0) (r : R0),	   (fun (x y : GenNo S) (_ : x < y)	      (z : (fun y0 : GenNo S =>	            {x_plus_y : No &	            (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	            (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	      (w : (fun y0 : GenNo S =>	            {x_plus_y : No &	            (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	            (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	    z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) (fxL l) 	     (fxR r)) ->	  (fun y : GenNo S =>	   {x_plus_y : No &	   (forall l : L, (xL_plus l).1 y < x_plus_y) *	   (forall r : R, x_plus_y < (xR_plus r).1 y)}) {{ xL0 | xR0 // xcut0 }}		subgoal 2 (ID 89) is:	 forall (x y : GenNo S)	 (a : (fun y0 : GenNo S =>	       {x_plus_y : No &	       (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	       (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	 (b : (fun y0 : GenNo S =>	       {x_plus_y : No &	       (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	       (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) 	 (p : x <= y) (q : y <= x),	 (fun (x0 y0 : GenNo S) (_ : x0 <= y0)	    (z : (fun y1 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y1)}) x0)	    (w : (fun y1 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y1)}) y0) => 	  z.1 <= w.1) x y p a b ->	 (fun (x0 y0 : GenNo S) (_ : x0 <= y0)	    (z : (fun y1 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y1)}) x0)	    (w : (fun y1 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y1)}) y0) => 	  z.1 <= w.1) y x q b a ->	 transport	   (fun y0 : GenNo S =>	    {x_plus_y : No &	    (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	    (forall r : R, x_plus_y < (xR_plus r).1 y0)}) 	   (path_No x y p q) a = b	subgoal 3 (ID 91) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (p : forall l : L0, xL0 l < {{ yL | yR // ycut }}),	 (forall l : L0,	  (fun (x y : GenNo S) (_ : x < y)	     (z : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	     (w : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	   z.1 < w.1) (xL0 l) {{ yL | yR // ycut }} (p l) 	    (fxL l) (?dcut L' R' s' yL yR ycut fyL fyR fycut)) ->	 forall q : forall r : R', {{ xL0 | xR0 // xcut0 }} < yR r,	 (forall r : R',	  (fun (x y : GenNo S) (_ : x < y)	     (z : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	           (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	     (w : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	           (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	   z.1 < w.1) {{ xL0 | xR0 // xcut0 }} (yR r) (q r)	    (?dcut L0 R0 s xL0 xR0 xcut0 fxL fxR fxcut) (fyR r)) ->	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 <= w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (le_lr xL0 xR0 xcut0 yL yR ycut p q)	   (?dcut L0 R0 s xL0 xR0 xcut0 fxL fxR fxcut)	   (?dcut L' R' s' yL yR ycut fyL fyR fycut)	subgoal 4 (ID 93) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (l : L') (p : {{ xL0 | xR0 // xcut0 }} <= yL l),	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 <= w.1) {{ xL0 | xR0 // xcut0 }} (yL l) p	   (?dcut L0 R0 s xL0 xR0 xcut0 fxL fxR fxcut) (fyL l) ->	 (fun (x y : GenNo S) (_ : x < y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 < w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (lt_l xL0 xR0 xcut0 yL yR ycut l p)	   (?dcut L0 R0 s xL0 xR0 xcut0 fxL fxR fxcut)	   (?dcut L' R' s' yL yR ycut fyL fyR fycut)	subgoal 5 (ID 95) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (r : R0) (p : xR0 r <= {{ yL | yR // ycut }}),	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	  z.1 <= w.1) (xR0 r) {{ yL | yR // ycut }} p (fxR r)	   (?dcut L' R' s' yL yR ycut fyL fyR fycut) ->	 (fun (x y : GenNo S) (_ : x < y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	  z.1 < w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (lt_r xL0 xR0 xcut0 yL yR ycut r p)	   (?dcut L0 R0 s xL0 xR0 xcut0 fxL fxR fxcut)	   (?dcut L' R' s' yL yR ycut fyL fyR fycut)	";
            responses[i]=data;
          

            i = 41;
            data = "1 subgoal (ID 87)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  ============================	  forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	  (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	  (fxL : forall l : L0,	         (fun y : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	           (xL0 l))	  (fxR : forall r : R0,	         (fun y : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	           (xR0 r)),	  (forall (l : L0) (r : R0),	   (fun (x y : GenNo S) (_ : x < y)	      (z : (fun y0 : GenNo S =>	            {x_plus_y : No &	            (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	            (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	      (w : (fun y0 : GenNo S =>	            {x_plus_y : No &	            (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	            (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	    z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) (fxL l) 	     (fxR r)) ->	  (fun y : GenNo S =>	   {x_plus_y : No &	   (forall l : L, (xL_plus l).1 y < x_plus_y) *	   (forall r : R, x_plus_y < (xR_plus r).1 y)}) {{ xL0 | xR0 // xcut0 }}	1 subgoal (ID 174)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  s : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  x_plus_yL : forall l : L',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	               (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                (yL l)	  x_plus_yR : forall r : R',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l : L, (xL_plus l).1 y < x_plus_y) *	               (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                (yR r)	  x_plus_yL_lt_yR : forall (l : L') (r : R'),	                    (fun (x y : GenNo S) (_ : x < y)	                       (z : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              x)	                       (w : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              y) => z.1 < w.1) (yL l) 	                      (yR r) (ycut l r) (x_plus_yL l) 	                      (x_plus_yR r)	  ============================	  (fun y : GenNo S =>	   {x_plus_y : No &	   (forall l : L, (xL_plus l).1 y < x_plus_y) *	   (forall r : R, x_plus_y < (xR_plus r).1 y)}) {{ yL | yR // ycut }}	";
            responses[i]=data;
          

            i = 42;
            data = "1 subgoal (ID 175)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  s : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  x_plus_yL : forall l : L',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	               (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                (yL l)	  x_plus_yR : forall r : R',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l : L, (xL_plus l).1 y < x_plus_y) *	               (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                (yR r)	  x_plus_yL_lt_yR : forall (l : L') (r : R'),	                    (fun (x y : GenNo S) (_ : x < y)	                       (z : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              x)	                       (w : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              y) => z.1 < w.1) (yL l) 	                      (yR r) (ycut l r) (x_plus_yL l) 	                      (x_plus_yR r)	  L'' := L + L' : Type	  ============================	  (fun y : GenNo S =>	   {x_plus_y : No &	   (forall l : L, (xL_plus l).1 y < x_plus_y) *	   (forall r : R, x_plus_y < (xR_plus r).1 y)}) {{ yL | yR // ycut }}	";
            responses[i]=data;
          

            i = 43;
            data = "1 subgoal (ID 176)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  s : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  x_plus_yL : forall l : L',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	               (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                (yL l)	  x_plus_yR : forall r : R',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l : L, (xL_plus l).1 y < x_plus_y) *	               (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                (yR r)	  x_plus_yL_lt_yR : forall (l : L') (r : R'),	                    (fun (x y : GenNo S) (_ : x < y)	                       (z : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              x)	                       (w : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              y) => z.1 < w.1) (yL l) 	                      (yR r) (ycut l r) (x_plus_yL l) 	                      (x_plus_yR r)	  L'' := L + L' : Type	  R'' := R + R' : Type	  ============================	  (fun y : GenNo S =>	   {x_plus_y : No &	   (forall l : L, (xL_plus l).1 y < x_plus_y) *	   (forall r : R, x_plus_y < (xR_plus r).1 y)}) {{ yL | yR // ycut }}	";
            responses[i]=data;
          

            i = 44;
            data = "1 subgoal (ID 190)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  s : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  x_plus_yL : forall l : L',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	               (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                (yL l)	  x_plus_yR : forall r : R',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l : L, (xL_plus l).1 y < x_plus_y) *	               (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                (yR r)	  x_plus_yL_lt_yR : forall (l : L') (r : R'),	                    (fun (x y : GenNo S) (_ : x < y)	                       (z : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              x)	                       (w : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              y) => z.1 < w.1) (yL l) 	                      (yR r) (ycut l r) (x_plus_yL l) 	                      (x_plus_yR r)	  L'' := L + L' : Type	  R'' := R + R' : Type	  zL := (sum_ind (fun _ : L + L' => No)	           (fun l : L => (xL_plus l).1 {{ yL | yR // ycut }})	           (fun l : L' => (x_plus_yL l).1)	         :	         L'' -> No) : L'' -> No	  ============================	  (fun y : GenNo S =>	   {x_plus_y : No &	   (forall l : L, (xL_plus l).1 y < x_plus_y) *	   (forall r : R, x_plus_y < (xR_plus r).1 y)}) {{ yL | yR // ycut }}	";
            responses[i]=data;
          

            i = 45;
            data = "1 subgoal (ID 204)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  s : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  x_plus_yL : forall l : L',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	               (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                (yL l)	  x_plus_yR : forall r : R',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l : L, (xL_plus l).1 y < x_plus_y) *	               (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                (yR r)	  x_plus_yL_lt_yR : forall (l : L') (r : R'),	                    (fun (x y : GenNo S) (_ : x < y)	                       (z : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              x)	                       (w : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              y) => z.1 < w.1) (yL l) 	                      (yR r) (ycut l r) (x_plus_yL l) 	                      (x_plus_yR r)	  L'' := L + L' : Type	  R'' := R + R' : Type	  zL := (sum_ind (fun _ : L + L' => No)	           (fun l : L => (xL_plus l).1 {{ yL | yR // ycut }})	           (fun l : L' => (x_plus_yL l).1)	         :	         L'' -> No) : L'' -> No	  zR := (sum_ind (fun _ : R + R' => No)	           (fun r : R => (xR_plus r).1 {{ yL | yR // ycut }})	           (fun r : R' => (x_plus_yR r).1)	         :	         R'' -> No) : R'' -> No	  ============================	  (fun y : GenNo S =>	   {x_plus_y : No &	   (forall l : L, (xL_plus l).1 y < x_plus_y) *	   (forall r : R, x_plus_y < (xR_plus r).1 y)}) {{ yL | yR // ycut }}	";
            responses[i]=data;
          

            i = 46;
            data = "2 subgoals (ID 206)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  s : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  x_plus_yL : forall l : L',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	               (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                (yL l)	  x_plus_yR : forall r : R',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l : L, (xL_plus l).1 y < x_plus_y) *	               (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                (yR r)	  x_plus_yL_lt_yR : forall (l : L') (r : R'),	                    (fun (x y : GenNo S) (_ : x < y)	                       (z : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              x)	                       (w : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              y) => z.1 < w.1) (yL l) 	                      (yR r) (ycut l r) (x_plus_yL l) 	                      (x_plus_yR r)	  L'' := L + L' : Type	  R'' := R + R' : Type	  zL := (sum_ind (fun _ : L + L' => No)	           (fun l : L => (xL_plus l).1 {{ yL | yR // ycut }})	           (fun l : L' => (x_plus_yL l).1)	         :	         L'' -> No) : L'' -> No	  zR := (sum_ind (fun _ : R + R' => No)	           (fun r : R => (xR_plus r).1 {{ yL | yR // ycut }})	           (fun r : R' => (x_plus_yR r).1)	         :	         R'' -> No) : R'' -> No	  ============================	  forall (l : L'') (r : R''), zL l < zR r		subgoal 2 (ID 208) is:	 (fun y : GenNo S =>	  {x_plus_y : No &	  (forall l : L, (xL_plus l).1 y < x_plus_y) *	  (forall r : R, x_plus_y < (xR_plus r).1 y)}) {{ yL | yR // ycut }}	";
            responses[i]=data;
          

            i = 47;
            data = "1 subgoal (ID 206)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  s : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  x_plus_yL : forall l : L',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	               (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                (yL l)	  x_plus_yR : forall r : R',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l : L, (xL_plus l).1 y < x_plus_y) *	               (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                (yR r)	  x_plus_yL_lt_yR : forall (l : L') (r : R'),	                    (fun (x y : GenNo S) (_ : x < y)	                       (z : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              x)	                       (w : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              y) => z.1 < w.1) (yL l) 	                      (yR r) (ycut l r) (x_plus_yL l) 	                      (x_plus_yR r)	  L'' := L + L' : Type	  R'' := R + R' : Type	  zL := (sum_ind (fun _ : L + L' => No)	           (fun l : L => (xL_plus l).1 {{ yL | yR // ycut }})	           (fun l : L' => (x_plus_yL l).1)	         :	         L'' -> No) : L'' -> No	  zR := (sum_ind (fun _ : R + R' => No)	           (fun r : R => (xR_plus r).1 {{ yL | yR // ycut }})	           (fun r : R' => (x_plus_yR r).1)	         :	         R'' -> No) : R'' -> No	  ============================	  forall (l : L'') (r : R''), zL l < zR r	<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	5 subgoals (ID 208)		subgoal 1 (ID 208) is:	 (fun y : GenNo S =>	  {x_plus_y : No &	  (forall l : L, (xL_plus l).1 y < x_plus_y) *	  (forall r : R, x_plus_y < (xR_plus r).1 y)}) {{ yL | yR // ycut }}	subgoal 2 (ID 89) is:	 forall (x y : GenNo S)	 (a : (fun y0 : GenNo S =>	       {x_plus_y : No &	       (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	       (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	 (b : (fun y0 : GenNo S =>	       {x_plus_y : No &	       (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	       (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) 	 (p : x <= y) (q : y <= x),	 (fun (x0 y0 : GenNo S) (_ : x0 <= y0)	    (z : (fun y1 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y1)}) x0)	    (w : (fun y1 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y1)}) y0) => 	  z.1 <= w.1) x y p a b ->	 (fun (x0 y0 : GenNo S) (_ : x0 <= y0)	    (z : (fun y1 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y1)}) x0)	    (w : (fun y1 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y1)}) y0) => 	  z.1 <= w.1) y x q b a ->	 transport	   (fun y0 : GenNo S =>	    {x_plus_y : No &	    (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	    (forall r : R, x_plus_y < (xR_plus r).1 y0)}) 	   (path_No x y p q) a = b	subgoal 3 (ID 91) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (p : forall l : L0, xL0 l < {{ yL | yR // ycut }}),	 (forall l : L0,	  (fun (x y : GenNo S) (_ : x < y)	     (z : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	     (w : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	   z.1 < w.1) (xL0 l) {{ yL | yR // ycut }} (p l) 	    (fxL l)	    ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	        (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	        (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	        (x_plus_yL : forall l0 : L'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                      (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                       (yL0 l0))	        (x_plus_yR : forall r : R'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                      (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                       (yR0 r))	        (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                           (fun (x y : GenNo S) (_ : x < y)	                              (z : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l1 : L,	                                     (xL_plus l1).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) x)	                              (w : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l1 : L,	                                     (xL_plus l1).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) y) =>	                            z.1 < w.1) (yL0 l0) (yR0 r) 	                             (ycut0 l0 r) (x_plus_yL l0) 	                             (x_plus_yR r)) =>	      let L'' := L + L'0 in	      let R'' := R + R'0 in	      let zL :=	        sum_ind (fun _ : L + L'0 => No)	          (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	          (fun l0 : L'0 => (x_plus_yL l0).1)	        :	        L'' -> No in	      let zR :=	        sum_ind (fun _ : R + R'0 => No)	          (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	          (fun r : R'0 => (x_plus_yR r).1)	        :	        R'' -> No in	      let zcut :=	        plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	          x_plus_yL_lt_yR in	      ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}) L' R'	       s' yL yR ycut fyL fyR fycut)) ->	 forall q : forall r : R', {{ xL0 | xR0 // xcut0 }} < yR r,	 (forall r : R',	  (fun (x y : GenNo S) (_ : x < y)	     (z : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	           (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	     (w : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	           (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	   z.1 < w.1) {{ xL0 | xR0 // xcut0 }} (yR r) (q r)	    ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	        (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	        (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	        (x_plus_yL : forall l : L'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                      (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                       (yL0 l))	        (x_plus_yR : forall r0 : R'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l : L, (xL_plus l).1 y < x_plus_y) *	                      (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                       (yR0 r0))	        (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                           (fun (x y : GenNo S) (_ : x < y)	                              (z : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r1 : R,	                                     x_plus_y < (xR_plus r1).1 y0)}) x)	                              (w : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r1 : R,	                                     x_plus_y < (xR_plus r1).1 y0)}) y) =>	                            z.1 < w.1) (yL0 l) (yR0 r0) 	                             (ycut0 l r0) (x_plus_yL l) 	                             (x_plus_yR r0)) =>	      let L'' := L + L'0 in	      let R'' := R + R'0 in	      let zL :=	        sum_ind (fun _ : L + L'0 => No)	          (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	          (fun l : L'0 => (x_plus_yL l).1)	        :	        L'' -> No in	      let zR :=	        sum_ind (fun _ : R + R'0 => No)	          (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	          (fun r0 : R'0 => (x_plus_yR r0).1)	        :	        R'' -> No in	      let zcut :=	        plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	          x_plus_yL_lt_yR in	      ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}) L0 R0 s	       xL0 xR0 xcut0 fxL fxR fxcut) (fyR r)) ->	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 <= w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (le_lr xL0 xR0 xcut0 yL yR ycut p q)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r : R'0), yL0 l < yR0 r)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r) 	                            (ycut0 l r) (x_plus_yL l) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}) L0 R0 s	      xL0 xR0 xcut0 fxL fxR fxcut)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r : R'0), yL0 l < yR0 r)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r) 	                            (ycut0 l r) (x_plus_yL l) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}) L' R' s'	      yL yR ycut fyL fyR fycut)	subgoal 4 (ID 93) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (l : L') (p : {{ xL0 | xR0 // xcut0 }} <= yL l),	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 <= w.1) {{ xL0 | xR0 // xcut0 }} (yL l) p	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	       (x_plus_yL : forall l0 : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l0))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l0) (yR0 r) 	                            (ycut0 l0 r) (x_plus_yL l0) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	         (fun l0 : L'0 => (x_plus_yL l0).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}) L0 R0 s	      xL0 xR0 xcut0 fxL fxR fxcut) (fyL l) ->	 (fun (x y : GenNo S) (_ : x < y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 < w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (lt_l xL0 xR0 xcut0 yL yR ycut l p)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	       (x_plus_yL : forall l0 : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l0))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l0) (yR0 r) 	                            (ycut0 l0 r) (x_plus_yL l0) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	         (fun l0 : L'0 => (x_plus_yL l0).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}) L0 R0 s	      xL0 xR0 xcut0 fxL fxR fxcut)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	       (x_plus_yL : forall l0 : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l0))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l0) (yR0 r) 	                            (ycut0 l0 r) (x_plus_yL l0) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	         (fun l0 : L'0 => (x_plus_yL l0).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}) L' R' s'	      yL yR ycut fyL fyR fycut)	subgoal 5 (ID 95) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (r : R0) (p : xR0 r <= {{ yL | yR // ycut }}),	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	  z.1 <= w.1) (xR0 r) {{ yL | yR // ycut }} p (fxR r)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}) L' R' s'	      yL yR ycut fyL fyR fycut) ->	 (fun (x y : GenNo S) (_ : x < y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	  z.1 < w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (lt_r xL0 xR0 xcut0 yL yR ycut r p)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}) L0 R0 s	      xL0 xR0 xcut0 fxL fxR fxcut)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}) L' R' s'	      yL yR ycut fyL fyR fycut)	";
            responses[i]=data;
          

            i = 48;
            data = "1 subgoal (ID 208)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  s : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  x_plus_yL : forall l : L',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	               (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                (yL l)	  x_plus_yR : forall r : R',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l : L, (xL_plus l).1 y < x_plus_y) *	               (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                (yR r)	  x_plus_yL_lt_yR : forall (l : L') (r : R'),	                    (fun (x y : GenNo S) (_ : x < y)	                       (z : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              x)	                       (w : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              y) => z.1 < w.1) (yL l) 	                      (yR r) (ycut l r) (x_plus_yL l) 	                      (x_plus_yR r)	  L'' := L + L' : Type	  R'' := R + R' : Type	  zL := (sum_ind (fun _ : L + L' => No)	           (fun l : L => (xL_plus l).1 {{ yL | yR // ycut }})	           (fun l : L' => (x_plus_yL l).1)	         :	         L'' -> No) : L'' -> No	  zR := (sum_ind (fun _ : R + R' => No)	           (fun r : R => (xR_plus r).1 {{ yL | yR // ycut }})	           (fun r : R' => (x_plus_yR r).1)	         :	         R'' -> No) : R'' -> No	  zcut : forall (l : L'') (r : R''), zL l < zR r	  ============================	  (fun y : GenNo S =>	   {x_plus_y : No &	   (forall l : L, (xL_plus l).1 y < x_plus_y) *	   (forall r : R, x_plus_y < (xR_plus r).1 y)}) {{ yL | yR // ycut }}	1 subgoal (ID 325)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  s : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  x_plus_yL : forall l : L',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	               (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                (yL l)	  x_plus_yR : forall r : R',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l : L, (xL_plus l).1 y < x_plus_y) *	               (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                (yR r)	  x_plus_yL_lt_yR : forall (l : L') (r : R'),	                    (fun (x y : GenNo S) (_ : x < y)	                       (z : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              x)	                       (w : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              y) => z.1 < w.1) (yL l) 	                      (yR r) (ycut l r) (x_plus_yL l) 	                      (x_plus_yR r)	  L'' := L + L' : Type	  R'' := R + R' : Type	  zL := (sum_ind (fun _ : L + L' => No)	           (fun l : L => (xL_plus l).1 {{ yL | yR // ycut }})	           (fun l : L' => (x_plus_yL l).1)	         :	         L'' -> No) : L'' -> No	  zR := (sum_ind (fun _ : R + R' => No)	           (fun r : R => (xR_plus r).1 {{ yL | yR // ycut }})	           (fun r : R' => (x_plus_yR r).1)	         :	         R'' -> No) : R'' -> No	  zcut : forall (l : L'') (r : R''), zL l < zR r	  X : InSort S L'' R''	  ============================	  (fun y : GenNo S =>	   {x_plus_y : No &	   (forall l : L, (xL_plus l).1 y < x_plus_y) *	   (forall r : R, x_plus_y < (xR_plus r).1 y)}) {{ yL | yR // ycut }}	";
            responses[i]=data;
          

            i = 49;
            data = "2 subgoals (ID 339)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  s : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  x_plus_yL : forall l : L',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	               (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                (yL l)	  x_plus_yR : forall r : R',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l : L, (xL_plus l).1 y < x_plus_y) *	               (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                (yR r)	  x_plus_yL_lt_yR : forall (l : L') (r : R'),	                    (fun (x y : GenNo S) (_ : x < y)	                       (z : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              x)	                       (w : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              y) => z.1 < w.1) (yL l) 	                      (yR r) (ycut l r) (x_plus_yL l) 	                      (x_plus_yR r)	  L'' := L + L' : Type	  R'' := R + R' : Type	  zL := (sum_ind (fun _ : L + L' => No)	           (fun l : L => (xL_plus l).1 {{ yL | yR // ycut }})	           (fun l : L' => (x_plus_yL l).1)	         :	         L'' -> No) : L'' -> No	  zR := (sum_ind (fun _ : R + R' => No)	           (fun r : R => (xR_plus r).1 {{ yL | yR // ycut }})	           (fun r : R' => (x_plus_yR r).1)	         :	         R'' -> No) : R'' -> No	  zcut : forall (l : L'') (r : R''), zL l < zR r	  X : InSort S L'' R''	  ============================	  forall l : L, (xL_plus l).1 {{ yL | yR // ycut }} < {{ zL | zR // zcut }}		subgoal 2 (ID 340) is:	 forall r : R, {{ zL | zR // zcut }} < (xR_plus r).1 {{ yL | yR // ycut }}	";
            responses[i]=data;
          

            i = 50;
            data = "1 subgoal (ID 339)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  s : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  x_plus_yL : forall l : L',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	               (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                (yL l)	  x_plus_yR : forall r : R',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l : L, (xL_plus l).1 y < x_plus_y) *	               (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                (yR r)	  x_plus_yL_lt_yR : forall (l : L') (r : R'),	                    (fun (x y : GenNo S) (_ : x < y)	                       (z : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              x)	                       (w : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              y) => z.1 < w.1) (yL l) 	                      (yR r) (ycut l r) (x_plus_yL l) 	                      (x_plus_yR r)	  L'' := L + L' : Type	  R'' := R + R' : Type	  zL := (sum_ind (fun _ : L + L' => No)	           (fun l : L => (xL_plus l).1 {{ yL | yR // ycut }})	           (fun l : L' => (x_plus_yL l).1)	         :	         L'' -> No) : L'' -> No	  zR := (sum_ind (fun _ : R + R' => No)	           (fun r : R => (xR_plus r).1 {{ yL | yR // ycut }})	           (fun r : R' => (x_plus_yR r).1)	         :	         R'' -> No) : R'' -> No	  zcut : forall (l : L'') (r : R''), zL l < zR r	  X : InSort S L'' R''	  ============================	  forall l : L, (xL_plus l).1 {{ yL | yR // ycut }} < {{ zL | zR // zcut }}	1 subgoal (ID 341)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  s : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  x_plus_yL : forall l : L',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	               (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                (yL l)	  x_plus_yR : forall r : R',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l : L, (xL_plus l).1 y < x_plus_y) *	               (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                (yR r)	  x_plus_yL_lt_yR : forall (l : L') (r : R'),	                    (fun (x y : GenNo S) (_ : x < y)	                       (z : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              x)	                       (w : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              y) => z.1 < w.1) (yL l) 	                      (yR r) (ycut l r) (x_plus_yL l) 	                      (x_plus_yR r)	  L'' := L + L' : Type	  R'' := R + R' : Type	  zL := (sum_ind (fun _ : L + L' => No)	           (fun l : L => (xL_plus l).1 {{ yL | yR // ycut }})	           (fun l : L' => (x_plus_yL l).1)	         :	         L'' -> No) : L'' -> No	  zR := (sum_ind (fun _ : R + R' => No)	           (fun r : R => (xR_plus r).1 {{ yL | yR // ycut }})	           (fun r : R' => (x_plus_yR r).1)	         :	         R'' -> No) : R'' -> No	  zcut : forall (l : L'') (r : R''), zL l < zR r	  X : InSort S L'' R''	  l : L	  ============================	  (xL_plus l).1 {{ yL | yR // ycut }} < {{ zL | zR // zcut }}	";
            responses[i]=data;
          

            i = 51;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	5 subgoals (ID 340)		subgoal 1 (ID 340) is:	 forall r : R, {{ zL | zR // zcut }} < (xR_plus r).1 {{ yL | yR // ycut }}	subgoal 2 (ID 89) is:	 forall (x y : GenNo S)	 (a : (fun y0 : GenNo S =>	       {x_plus_y : No &	       (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	       (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	 (b : (fun y0 : GenNo S =>	       {x_plus_y : No &	       (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	       (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) 	 (p : x <= y) (q : y <= x),	 (fun (x0 y0 : GenNo S) (_ : x0 <= y0)	    (z : (fun y1 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y1)}) x0)	    (w : (fun y1 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y1)}) y0) => 	  z.1 <= w.1) x y p a b ->	 (fun (x0 y0 : GenNo S) (_ : x0 <= y0)	    (z : (fun y1 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y1)}) x0)	    (w : (fun y1 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y1)}) y0) => 	  z.1 <= w.1) y x q b a ->	 transport	   (fun y0 : GenNo S =>	    {x_plus_y : No &	    (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	    (forall r : R, x_plus_y < (xR_plus r).1 y0)}) 	   (path_No x y p q) a = b	subgoal 3 (ID 91) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (p : forall l : L0, xL0 l < {{ yL | yR // ycut }}),	 (forall l : L0,	  (fun (x y : GenNo S) (_ : x < y)	     (z : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	     (w : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	   z.1 < w.1) (xL0 l) {{ yL | yR // ycut }} (p l) 	    (fxL l)	    ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	        (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	        (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	        (x_plus_yL : forall l0 : L'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                      (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                       (yL0 l0))	        (x_plus_yR : forall r : R'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                      (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                       (yR0 r))	        (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                           (fun (x y : GenNo S) (_ : x < y)	                              (z : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l1 : L,	                                     (xL_plus l1).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) x)	                              (w : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l1 : L,	                                     (xL_plus l1).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) y) =>	                            z.1 < w.1) (yL0 l0) (yR0 r) 	                             (ycut0 l0 r) (x_plus_yL l0) 	                             (x_plus_yR r)) =>	      let L'' := L + L'0 in	      let R'' := R + R'0 in	      let zL :=	        sum_ind (fun _ : L + L'0 => No)	          (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	          (fun l0 : L'0 => (x_plus_yL l0).1)	        :	        L'' -> No in	      let zR :=	        sum_ind (fun _ : R + R'0 => No)	          (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	          (fun r : R'0 => (x_plus_yR r).1)	        :	        R'' -> No in	      let zcut :=	        plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	          x_plus_yL_lt_yR in	      let X := sum_options L R L'0 R'0 Sx s0 in	      ({{ zL | zR // zcut }};	      (fun l0 : L => lt_lopt zL zR zcut (inl l0),	      ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}))) L' R'	       s' yL yR ycut fyL fyR fycut)) ->	 forall q : forall r : R', {{ xL0 | xR0 // xcut0 }} < yR r,	 (forall r : R',	  (fun (x y : GenNo S) (_ : x < y)	     (z : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	           (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	     (w : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	           (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	   z.1 < w.1) {{ xL0 | xR0 // xcut0 }} (yR r) (q r)	    ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	        (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	        (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	        (x_plus_yL : forall l : L'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                      (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                       (yL0 l))	        (x_plus_yR : forall r0 : R'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l : L, (xL_plus l).1 y < x_plus_y) *	                      (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                       (yR0 r0))	        (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                           (fun (x y : GenNo S) (_ : x < y)	                              (z : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r1 : R,	                                     x_plus_y < (xR_plus r1).1 y0)}) x)	                              (w : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r1 : R,	                                     x_plus_y < (xR_plus r1).1 y0)}) y) =>	                            z.1 < w.1) (yL0 l) (yR0 r0) 	                             (ycut0 l r0) (x_plus_yL l) 	                             (x_plus_yR r0)) =>	      let L'' := L + L'0 in	      let R'' := R + R'0 in	      let zL :=	        sum_ind (fun _ : L + L'0 => No)	          (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	          (fun l : L'0 => (x_plus_yL l).1)	        :	        L'' -> No in	      let zR :=	        sum_ind (fun _ : R + R'0 => No)	          (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	          (fun r0 : R'0 => (x_plus_yR r0).1)	        :	        R'' -> No in	      let zcut :=	        plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	          x_plus_yL_lt_yR in	      let X := sum_options L R L'0 R'0 Sx s0 in	      ({{ zL | zR // zcut }};	      (fun l : L => lt_lopt zL zR zcut (inl l),	      ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}))) L0 R0	       s xL0 xR0 xcut0 fxL fxR fxcut) (fyR r)) ->	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 <= w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (le_lr xL0 xR0 xcut0 yL yR ycut p q)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r : R'0), yL0 l < yR0 r)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r) 	                            (ycut0 l r) (x_plus_yL l) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}))) L0 R0	      s xL0 xR0 xcut0 fxL fxR fxcut)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r : R'0), yL0 l < yR0 r)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r) 	                            (ycut0 l r) (x_plus_yL l) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}))) L' R'	      s' yL yR ycut fyL fyR fycut)	subgoal 4 (ID 93) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (l : L') (p : {{ xL0 | xR0 // xcut0 }} <= yL l),	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 <= w.1) {{ xL0 | xR0 // xcut0 }} (yL l) p	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	       (x_plus_yL : forall l0 : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l0))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l0) (yR0 r) 	                            (ycut0 l0 r) (x_plus_yL l0) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	         (fun l0 : L'0 => (x_plus_yL l0).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l0 : L => lt_lopt zL zR zcut (inl l0),	     ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}))) L0 R0	      s xL0 xR0 xcut0 fxL fxR fxcut) (fyL l) ->	 (fun (x y : GenNo S) (_ : x < y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 < w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (lt_l xL0 xR0 xcut0 yL yR ycut l p)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	       (x_plus_yL : forall l0 : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l0))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l0) (yR0 r) 	                            (ycut0 l0 r) (x_plus_yL l0) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	         (fun l0 : L'0 => (x_plus_yL l0).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l0 : L => lt_lopt zL zR zcut (inl l0),	     ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}))) L0 R0	      s xL0 xR0 xcut0 fxL fxR fxcut)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	       (x_plus_yL : forall l0 : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l0))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l0) (yR0 r) 	                            (ycut0 l0 r) (x_plus_yL l0) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	         (fun l0 : L'0 => (x_plus_yL l0).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l0 : L => lt_lopt zL zR zcut (inl l0),	     ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}))) L' R'	      s' yL yR ycut fyL fyR fycut)	subgoal 5 (ID 95) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (r : R0) (p : xR0 r <= {{ yL | yR // ycut }}),	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	  z.1 <= w.1) (xR0 r) {{ yL | yR // ycut }} p (fxR r)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}))) L' R'	      s' yL yR ycut fyL fyR fycut) ->	 (fun (x y : GenNo S) (_ : x < y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	  z.1 < w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (lt_r xL0 xR0 xcut0 yL yR ycut r p)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}))) L0 R0	      s xL0 xR0 xcut0 fxL fxR fxcut)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     ?Goal@{L':=L'0; R':=R'0; s:=s0; yL:=yL0; yR:=yR0; ycut:=ycut0}))) L' R'	      s' yL yR ycut fyL fyR fycut)	";
            responses[i]=data;
          

            i = 52;
            data = "1 subgoal (ID 340)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  s : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  x_plus_yL : forall l : L',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	               (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                (yL l)	  x_plus_yR : forall r : R',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l : L, (xL_plus l).1 y < x_plus_y) *	               (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                (yR r)	  x_plus_yL_lt_yR : forall (l : L') (r : R'),	                    (fun (x y : GenNo S) (_ : x < y)	                       (z : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              x)	                       (w : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              y) => z.1 < w.1) (yL l) 	                      (yR r) (ycut l r) (x_plus_yL l) 	                      (x_plus_yR r)	  L'' := L + L' : Type	  R'' := R + R' : Type	  zL := (sum_ind (fun _ : L + L' => No)	           (fun l : L => (xL_plus l).1 {{ yL | yR // ycut }})	           (fun l : L' => (x_plus_yL l).1)	         :	         L'' -> No) : L'' -> No	  zR := (sum_ind (fun _ : R + R' => No)	           (fun r : R => (xR_plus r).1 {{ yL | yR // ycut }})	           (fun r : R' => (x_plus_yR r).1)	         :	         R'' -> No) : R'' -> No	  zcut : forall (l : L'') (r : R''), zL l < zR r	  X : InSort S L'' R''	  ============================	  forall r : R, {{ zL | zR // zcut }} < (xR_plus r).1 {{ yL | yR // ycut }}	1 subgoal (ID 352)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  s : InSort S L' R'	  yL : L' -> GenNo S	  yR : R' -> GenNo S	  ycut : forall (l : L') (r : R'), yL l < yR r	  x_plus_yL : forall l : L',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	               (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                (yL l)	  x_plus_yR : forall r : R',	              (fun y : GenNo S =>	               {x_plus_y : No &	               (forall l : L, (xL_plus l).1 y < x_plus_y) *	               (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                (yR r)	  x_plus_yL_lt_yR : forall (l : L') (r : R'),	                    (fun (x y : GenNo S) (_ : x < y)	                       (z : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              x)	                       (w : (fun y0 : GenNo S =>	                             {x_plus_y : No &	                             (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                             (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)})	                              y) => z.1 < w.1) (yL l) 	                      (yR r) (ycut l r) (x_plus_yL l) 	                      (x_plus_yR r)	  L'' := L + L' : Type	  R'' := R + R' : Type	  zL := (sum_ind (fun _ : L + L' => No)	           (fun l : L => (xL_plus l).1 {{ yL | yR // ycut }})	           (fun l : L' => (x_plus_yL l).1)	         :	         L'' -> No) : L'' -> No	  zR := (sum_ind (fun _ : R + R' => No)	           (fun r : R => (xR_plus r).1 {{ yL | yR // ycut }})	           (fun r : R' => (x_plus_yR r).1)	         :	         R'' -> No) : R'' -> No	  zcut : forall (l : L'') (r : R''), zL l < zR r	  X : InSort S L'' R''	  r : R	  ============================	  {{ zL | zR // zcut }} < (xR_plus r).1 {{ yL | yR // ycut }}	";
            responses[i]=data;
          

            i = 53;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	4 subgoals (ID 89)		subgoal 1 (ID 89) is:	 forall (x y : GenNo S)	 (a : (fun y0 : GenNo S =>	       {x_plus_y : No &	       (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	       (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	 (b : (fun y0 : GenNo S =>	       {x_plus_y : No &	       (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	       (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) 	 (p : x <= y) (q : y <= x),	 (fun (x0 y0 : GenNo S) (_ : x0 <= y0)	    (z : (fun y1 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y1)}) x0)	    (w : (fun y1 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y1)}) y0) => 	  z.1 <= w.1) x y p a b ->	 (fun (x0 y0 : GenNo S) (_ : x0 <= y0)	    (z : (fun y1 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y1)}) x0)	    (w : (fun y1 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y1)}) y0) => 	  z.1 <= w.1) y x q b a ->	 transport	   (fun y0 : GenNo S =>	    {x_plus_y : No &	    (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	    (forall r : R, x_plus_y < (xR_plus r).1 y0)}) 	   (path_No x y p q) a = b	subgoal 2 (ID 91) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (p : forall l : L0, xL0 l < {{ yL | yR // ycut }}),	 (forall l : L0,	  (fun (x y : GenNo S) (_ : x < y)	     (z : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	     (w : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	   z.1 < w.1) (xL0 l) {{ yL | yR // ycut }} (p l) 	    (fxL l)	    ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	        (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	        (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	        (x_plus_yL : forall l0 : L'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                      (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                       (yL0 l0))	        (x_plus_yR : forall r : R'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                      (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                       (yR0 r))	        (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                           (fun (x y : GenNo S) (_ : x < y)	                              (z : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l1 : L,	                                     (xL_plus l1).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) x)	                              (w : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l1 : L,	                                     (xL_plus l1).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) y) =>	                            z.1 < w.1) (yL0 l0) (yR0 r) 	                             (ycut0 l0 r) (x_plus_yL l0) 	                             (x_plus_yR r)) =>	      let L'' := L + L'0 in	      let R'' := R + R'0 in	      let zL :=	        sum_ind (fun _ : L + L'0 => No)	          (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	          (fun l0 : L'0 => (x_plus_yL l0).1)	        :	        L'' -> No in	      let zR :=	        sum_ind (fun _ : R + R'0 => No)	          (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	          (fun r : R'0 => (x_plus_yR r).1)	        :	        R'' -> No in	      let zcut :=	        plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	          x_plus_yL_lt_yR in	      let X := sum_options L R L'0 R'0 Sx s0 in	      ({{ zL | zR // zcut }};	      (fun l0 : L => lt_lopt zL zR zcut (inl l0),	      fun r : R => lt_ropt zL zR zcut (inl r)))) L' R' s' yL yR ycut fyL fyR	       fycut)) ->	 forall q : forall r : R', {{ xL0 | xR0 // xcut0 }} < yR r,	 (forall r : R',	  (fun (x y : GenNo S) (_ : x < y)	     (z : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	           (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	     (w : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	           (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	   z.1 < w.1) {{ xL0 | xR0 // xcut0 }} (yR r) (q r)	    ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	        (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	        (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	        (x_plus_yL : forall l : L'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                      (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                       (yL0 l))	        (x_plus_yR : forall r0 : R'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l : L, (xL_plus l).1 y < x_plus_y) *	                      (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                       (yR0 r0))	        (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                           (fun (x y : GenNo S) (_ : x < y)	                              (z : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r1 : R,	                                     x_plus_y < (xR_plus r1).1 y0)}) x)	                              (w : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r1 : R,	                                     x_plus_y < (xR_plus r1).1 y0)}) y) =>	                            z.1 < w.1) (yL0 l) (yR0 r0) 	                             (ycut0 l r0) (x_plus_yL l) 	                             (x_plus_yR r0)) =>	      let L'' := L + L'0 in	      let R'' := R + R'0 in	      let zL :=	        sum_ind (fun _ : L + L'0 => No)	          (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	          (fun l : L'0 => (x_plus_yL l).1)	        :	        L'' -> No in	      let zR :=	        sum_ind (fun _ : R + R'0 => No)	          (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	          (fun r0 : R'0 => (x_plus_yR r0).1)	        :	        R'' -> No in	      let zcut :=	        plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	          x_plus_yL_lt_yR in	      let X := sum_options L R L'0 R'0 Sx s0 in	      ({{ zL | zR // zcut }};	      (fun l : L => lt_lopt zL zR zcut (inl l),	      fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L0 R0 s xL0 xR0 xcut0 fxL	       fxR fxcut) (fyR r)) ->	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 <= w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (le_lr xL0 xR0 xcut0 yL yR ycut p q)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r : R'0), yL0 l < yR0 r)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r) 	                            (ycut0 l r) (x_plus_yL l) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     fun r : R => lt_ropt zL zR zcut (inl r)))) L0 R0 s xL0 xR0 xcut0 fxL fxR	      fxcut)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r : R'0), yL0 l < yR0 r)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r) 	                            (ycut0 l r) (x_plus_yL l) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     fun r : R => lt_ropt zL zR zcut (inl r)))) L' R' s' yL yR ycut fyL fyR	      fycut)	subgoal 3 (ID 93) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (l : L') (p : {{ xL0 | xR0 // xcut0 }} <= yL l),	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 <= w.1) {{ xL0 | xR0 // xcut0 }} (yL l) p	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	       (x_plus_yL : forall l0 : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l0))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l0) (yR0 r) 	                            (ycut0 l0 r) (x_plus_yL l0) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	         (fun l0 : L'0 => (x_plus_yL l0).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l0 : L => lt_lopt zL zR zcut (inl l0),	     fun r : R => lt_ropt zL zR zcut (inl r)))) L0 R0 s xL0 xR0 xcut0 fxL fxR	      fxcut) (fyL l) ->	 (fun (x y : GenNo S) (_ : x < y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 < w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (lt_l xL0 xR0 xcut0 yL yR ycut l p)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	       (x_plus_yL : forall l0 : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l0))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l0) (yR0 r) 	                            (ycut0 l0 r) (x_plus_yL l0) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	         (fun l0 : L'0 => (x_plus_yL l0).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l0 : L => lt_lopt zL zR zcut (inl l0),	     fun r : R => lt_ropt zL zR zcut (inl r)))) L0 R0 s xL0 xR0 xcut0 fxL fxR	      fxcut)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	       (x_plus_yL : forall l0 : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l0))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l0) (yR0 r) 	                            (ycut0 l0 r) (x_plus_yL l0) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	         (fun l0 : L'0 => (x_plus_yL l0).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l0 : L => lt_lopt zL zR zcut (inl l0),	     fun r : R => lt_ropt zL zR zcut (inl r)))) L' R' s' yL yR ycut fyL fyR	      fycut)	subgoal 4 (ID 95) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (r : R0) (p : xR0 r <= {{ yL | yR // ycut }}),	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	  z.1 <= w.1) (xR0 r) {{ yL | yR // ycut }} p (fxR r)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L' R' s' yL yR ycut fyL fyR	      fycut) ->	 (fun (x y : GenNo S) (_ : x < y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	  z.1 < w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (lt_r xL0 xR0 xcut0 yL yR ycut r p)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L0 R0 s xL0 xR0 xcut0 fxL	      fxR fxcut)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L' R' s' yL yR ycut fyL fyR	      fycut)	";
            responses[i]=data;
          

            i = 54;
            data = "1 subgoal (ID 89)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  ============================	  forall (x y : GenNo S)	  (a : (fun y0 : GenNo S =>	        {x_plus_y : No &	        (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	        (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	  (b : (fun y0 : GenNo S =>	        {x_plus_y : No &	        (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	        (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) 	  (p : x <= y) (q : y <= x),	  (fun (x0 y0 : GenNo S) (_ : x0 <= y0)	     (z : (fun y1 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y1)}) x0)	     (w : (fun y1 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y1)}) y0) => 	   z.1 <= w.1) x y p a b ->	  (fun (x0 y0 : GenNo S) (_ : x0 <= y0)	     (z : (fun y1 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y1)}) x0)	     (w : (fun y1 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y1 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y1)}) y0) => 	   z.1 <= w.1) y x q b a ->	  transport	    (fun y0 : GenNo S =>	     {x_plus_y : No &	     (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	     (forall r : R, x_plus_y < (xR_plus r).1 y0)}) 	    (path_No x y p q) a = b	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	3 subgoals (ID 91)		subgoal 1 (ID 91) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (p : forall l : L0, xL0 l < {{ yL | yR // ycut }}),	 (forall l : L0,	  (fun (x y : GenNo S) (_ : x < y)	     (z : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	     (w : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	   z.1 < w.1) (xL0 l) {{ yL | yR // ycut }} (p l) 	    (fxL l)	    ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	        (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	        (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	        (x_plus_yL : forall l0 : L'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                      (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                       (yL0 l0))	        (x_plus_yR : forall r : R'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                      (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                       (yR0 r))	        (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                           (fun (x y : GenNo S) (_ : x < y)	                              (z : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l1 : L,	                                     (xL_plus l1).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) x)	                              (w : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l1 : L,	                                     (xL_plus l1).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) y) =>	                            z.1 < w.1) (yL0 l0) (yR0 r) 	                             (ycut0 l0 r) (x_plus_yL l0) 	                             (x_plus_yR r)) =>	      let L'' := L + L'0 in	      let R'' := R + R'0 in	      let zL :=	        sum_ind (fun _ : L + L'0 => No)	          (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	          (fun l0 : L'0 => (x_plus_yL l0).1)	        :	        L'' -> No in	      let zR :=	        sum_ind (fun _ : R + R'0 => No)	          (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	          (fun r : R'0 => (x_plus_yR r).1)	        :	        R'' -> No in	      let zcut :=	        plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	          x_plus_yL_lt_yR in	      let X := sum_options L R L'0 R'0 Sx s0 in	      ({{ zL | zR // zcut }};	      (fun l0 : L => lt_lopt zL zR zcut (inl l0),	      fun r : R => lt_ropt zL zR zcut (inl r)))) L' R' s' yL yR ycut fyL fyR	       fycut)) ->	 forall q : forall r : R', {{ xL0 | xR0 // xcut0 }} < yR r,	 (forall r : R',	  (fun (x y : GenNo S) (_ : x < y)	     (z : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	           (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	     (w : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	           (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	   z.1 < w.1) {{ xL0 | xR0 // xcut0 }} (yR r) (q r)	    ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	        (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	        (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	        (x_plus_yL : forall l : L'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                      (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                       (yL0 l))	        (x_plus_yR : forall r0 : R'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l : L, (xL_plus l).1 y < x_plus_y) *	                      (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                       (yR0 r0))	        (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                           (fun (x y : GenNo S) (_ : x < y)	                              (z : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r1 : R,	                                     x_plus_y < (xR_plus r1).1 y0)}) x)	                              (w : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r1 : R,	                                     x_plus_y < (xR_plus r1).1 y0)}) y) =>	                            z.1 < w.1) (yL0 l) (yR0 r0) 	                             (ycut0 l r0) (x_plus_yL l) 	                             (x_plus_yR r0)) =>	      let L'' := L + L'0 in	      let R'' := R + R'0 in	      let zL :=	        sum_ind (fun _ : L + L'0 => No)	          (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	          (fun l : L'0 => (x_plus_yL l).1)	        :	        L'' -> No in	      let zR :=	        sum_ind (fun _ : R + R'0 => No)	          (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	          (fun r0 : R'0 => (x_plus_yR r0).1)	        :	        R'' -> No in	      let zcut :=	        plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	          x_plus_yL_lt_yR in	      let X := sum_options L R L'0 R'0 Sx s0 in	      ({{ zL | zR // zcut }};	      (fun l : L => lt_lopt zL zR zcut (inl l),	      fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L0 R0 s xL0 xR0 xcut0 fxL	       fxR fxcut) (fyR r)) ->	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 <= w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (le_lr xL0 xR0 xcut0 yL yR ycut p q)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r : R'0), yL0 l < yR0 r)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r) 	                            (ycut0 l r) (x_plus_yL l) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     fun r : R => lt_ropt zL zR zcut (inl r)))) L0 R0 s xL0 xR0 xcut0 fxL fxR	      fxcut)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r : R'0), yL0 l < yR0 r)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r) 	                            (ycut0 l r) (x_plus_yL l) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     fun r : R => lt_ropt zL zR zcut (inl r)))) L' R' s' yL yR ycut fyL fyR	      fycut)	subgoal 2 (ID 93) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (l : L') (p : {{ xL0 | xR0 // xcut0 }} <= yL l),	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 <= w.1) {{ xL0 | xR0 // xcut0 }} (yL l) p	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	       (x_plus_yL : forall l0 : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l0))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l0) (yR0 r) 	                            (ycut0 l0 r) (x_plus_yL l0) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	         (fun l0 : L'0 => (x_plus_yL l0).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l0 : L => lt_lopt zL zR zcut (inl l0),	     fun r : R => lt_ropt zL zR zcut (inl r)))) L0 R0 s xL0 xR0 xcut0 fxL fxR	      fxcut) (fyL l) ->	 (fun (x y : GenNo S) (_ : x < y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 < w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (lt_l xL0 xR0 xcut0 yL yR ycut l p)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	       (x_plus_yL : forall l0 : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l0))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l0) (yR0 r) 	                            (ycut0 l0 r) (x_plus_yL l0) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	         (fun l0 : L'0 => (x_plus_yL l0).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l0 : L => lt_lopt zL zR zcut (inl l0),	     fun r : R => lt_ropt zL zR zcut (inl r)))) L0 R0 s xL0 xR0 xcut0 fxL fxR	      fxcut)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	       (x_plus_yL : forall l0 : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l0))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l0) (yR0 r) 	                            (ycut0 l0 r) (x_plus_yL l0) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	         (fun l0 : L'0 => (x_plus_yL l0).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l0 : L => lt_lopt zL zR zcut (inl l0),	     fun r : R => lt_ropt zL zR zcut (inl r)))) L' R' s' yL yR ycut fyL fyR	      fycut)	subgoal 3 (ID 95) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (r : R0) (p : xR0 r <= {{ yL | yR // ycut }}),	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	  z.1 <= w.1) (xR0 r) {{ yL | yR // ycut }} p (fxR r)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L' R' s' yL yR ycut fyL fyR	      fycut) ->	 (fun (x y : GenNo S) (_ : x < y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	  z.1 < w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (lt_r xL0 xR0 xcut0 yL yR ycut r p)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L0 R0 s xL0 xR0 xcut0 fxL	      fxR fxcut)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L' R' s' yL yR ycut fyL fyR	      fycut)	";
            responses[i]=data;
          

            i = 55;
            data = "1 subgoal (ID 91)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  ============================	  forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	  (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	  (fxL : forall l : L0,	         (fun y : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	           (xL0 l))	  (fxR : forall r : R0,	         (fun y : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	           (xR0 r))	  (fxcut : forall (l : L0) (r : R0),	           (fun (x y : GenNo S) (_ : x < y)	              (z : (fun y0 : GenNo S =>	                    {x_plus_y : No &	                    (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                    (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	              (w : (fun y0 : GenNo S =>	                    {x_plus_y : No &	                    (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                    (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	            z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	             (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	  (yL : L' -> GenNo S) (yR : R' -> GenNo S)	  (ycut : forall (l : L') (r : R'), yL l < yR r)	  (fyL : forall l : L',	         (fun y : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	           (yL l))	  (fyR : forall r : R',	         (fun y : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	           (yR r))	  (fycut : forall (l : L') (r : R'),	           (fun (x y : GenNo S) (_ : x < y)	              (z : (fun y0 : GenNo S =>	                    {x_plus_y : No &	                    (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                    (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	              (w : (fun y0 : GenNo S =>	                    {x_plus_y : No &	                    (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                    (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	            z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	             (fyR r)) (p : forall l : L0, xL0 l < {{ yL | yR // ycut }}),	  (forall l : L0,	   (fun (x y : GenNo S) (_ : x < y)	      (z : (fun y0 : GenNo S =>	            {x_plus_y : No &	            (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	            (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	      (w : (fun y0 : GenNo S =>	            {x_plus_y : No &	            (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	            (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	    z.1 < w.1) (xL0 l) {{ yL | yR // ycut }} (p l) 	     (fxL l)	     ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	         (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	         (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	         (x_plus_yL : forall l0 : L'0,	                      (fun y : GenNo S =>	                       {x_plus_y : No &	                       (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                       (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                        (yL0 l0))	         (x_plus_yR : forall r : R'0,	                      (fun y : GenNo S =>	                       {x_plus_y : No &	                       (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                       (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                        (yR0 r))	         (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                            (fun (x y : GenNo S) (_ : x < y)	                               (z : (fun y0 : GenNo S =>	                                     {x_plus_y : No &	                                     (forall l1 : L,	                                      (xL_plus l1).1 y0 < x_plus_y) *	                                     (forall r0 : R,	                                      x_plus_y < (xR_plus r0).1 y0)}) x)	                               (w : (fun y0 : GenNo S =>	                                     {x_plus_y : No &	                                     (forall l1 : L,	                                      (xL_plus l1).1 y0 < x_plus_y) *	                                     (forall r0 : R,	                                      x_plus_y < (xR_plus r0).1 y0)}) y) =>	                             z.1 < w.1) (yL0 l0) (yR0 r) 	                              (ycut0 l0 r) (x_plus_yL l0) 	                              (x_plus_yR r)) =>	       let L'' := L + L'0 in	       let R'' := R + R'0 in	       let zL :=	         sum_ind (fun _ : L + L'0 => No)	           (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	           (fun l0 : L'0 => (x_plus_yL l0).1)	         :	         L'' -> No in	       let zR :=	         sum_ind (fun _ : R + R'0 => No)	           (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	           (fun r : R'0 => (x_plus_yR r).1)	         :	         R'' -> No in	       let zcut :=	         plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	           x_plus_yL_lt_yR in	       let X := sum_options L R L'0 R'0 Sx s0 in	       ({{ zL | zR // zcut }};	       (fun l0 : L => lt_lopt zL zR zcut (inl l0),	       fun r : R => lt_ropt zL zR zcut (inl r)))) L' R' s' yL yR ycut fyL fyR	        fycut)) ->	  forall q : forall r : R', {{ xL0 | xR0 // xcut0 }} < yR r,	  (forall r : R',	   (fun (x y : GenNo S) (_ : x < y)	      (z : (fun y0 : GenNo S =>	            {x_plus_y : No &	            (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	            (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	      (w : (fun y0 : GenNo S =>	            {x_plus_y : No &	            (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	            (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	    z.1 < w.1) {{ xL0 | xR0 // xcut0 }} (yR r) (q r)	     ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	         (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	         (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	         (x_plus_yL : forall l : L'0,	                      (fun y : GenNo S =>	                       {x_plus_y : No &	                       (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                       (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                        (yL0 l))	         (x_plus_yR : forall r0 : R'0,	                      (fun y : GenNo S =>	                       {x_plus_y : No &	                       (forall l : L, (xL_plus l).1 y < x_plus_y) *	                       (forall r1 : R, x_plus_y < (xR_plus r1).1 y)})	                        (yR0 r0))	         (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                            (fun (x y : GenNo S) (_ : x < y)	                               (z : (fun y0 : GenNo S =>	                                     {x_plus_y : No &	                                     (forall l0 : L,	                                      (xL_plus l0).1 y0 < x_plus_y) *	                                     (forall r1 : R,	                                      x_plus_y < (xR_plus r1).1 y0)}) x)	                               (w : (fun y0 : GenNo S =>	                                     {x_plus_y : No &	                                     (forall l0 : L,	                                      (xL_plus l0).1 y0 < x_plus_y) *	                                     (forall r1 : R,	                                      x_plus_y < (xR_plus r1).1 y0)}) y) =>	                             z.1 < w.1) (yL0 l) (yR0 r0) 	                              (ycut0 l r0) (x_plus_yL l) 	                              (x_plus_yR r0)) =>	       let L'' := L + L'0 in	       let R'' := R + R'0 in	       let zL :=	         sum_ind (fun _ : L + L'0 => No)	           (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	           (fun l : L'0 => (x_plus_yL l).1)	         :	         L'' -> No in	       let zR :=	         sum_ind (fun _ : R + R'0 => No)	           (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	           (fun r0 : R'0 => (x_plus_yR r0).1)	         :	         R'' -> No in	       let zcut :=	         plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	           x_plus_yL_lt_yR in	       let X := sum_options L R L'0 R'0 Sx s0 in	       ({{ zL | zR // zcut }};	       (fun l : L => lt_lopt zL zR zcut (inl l),	       fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L0 R0 s xL0 xR0 xcut0 fxL	        fxR fxcut) (fyR r)) ->	  (fun (x y : GenNo S) (_ : x <= y)	     (z : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	     (w : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	   z.1 <= w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	    (le_lr xL0 xR0 xcut0 yL yR ycut p q)	    ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	        (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	        (ycut0 : forall (l : L'0) (r : R'0), yL0 l < yR0 r)	        (x_plus_yL : forall l : L'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                      (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                       (yL0 l))	        (x_plus_yR : forall r : R'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l : L, (xL_plus l).1 y < x_plus_y) *	                      (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                       (yR0 r))	        (x_plus_yL_lt_yR : forall (l : L'0) (r : R'0),	                           (fun (x y : GenNo S) (_ : x < y)	                              (z : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) x)	                              (w : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) y) =>	                            z.1 < w.1) (yL0 l) (yR0 r) 	                             (ycut0 l r) (x_plus_yL l) 	                             (x_plus_yR r)) =>	      let L'' := L + L'0 in	      let R'' := R + R'0 in	      let zL :=	        sum_ind (fun _ : L + L'0 => No)	          (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	          (fun l : L'0 => (x_plus_yL l).1)	        :	        L'' -> No in	      let zR :=	        sum_ind (fun _ : R + R'0 => No)	          (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	          (fun r : R'0 => (x_plus_yR r).1)	        :	        R'' -> No in	      let zcut :=	        plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	          x_plus_yL_lt_yR in	      let X := sum_options L R L'0 R'0 Sx s0 in	      ({{ zL | zR // zcut }};	      (fun l : L => lt_lopt zL zR zcut (inl l),	      fun r : R => lt_ropt zL zR zcut (inl r)))) L0 R0 s xL0 xR0 xcut0 fxL	       fxR fxcut)	    ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	        (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	        (ycut0 : forall (l : L'0) (r : R'0), yL0 l < yR0 r)	        (x_plus_yL : forall l : L'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                      (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                       (yL0 l))	        (x_plus_yR : forall r : R'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l : L, (xL_plus l).1 y < x_plus_y) *	                      (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                       (yR0 r))	        (x_plus_yL_lt_yR : forall (l : L'0) (r : R'0),	                           (fun (x y : GenNo S) (_ : x < y)	                              (z : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) x)	                              (w : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) y) =>	                            z.1 < w.1) (yL0 l) (yR0 r) 	                             (ycut0 l r) (x_plus_yL l) 	                             (x_plus_yR r)) =>	      let L'' := L + L'0 in	      let R'' := R + R'0 in	      let zL :=	        sum_ind (fun _ : L + L'0 => No)	          (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	          (fun l : L'0 => (x_plus_yL l).1)	        :	        L'' -> No in	      let zR :=	        sum_ind (fun _ : R + R'0 => No)	          (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	          (fun r : R'0 => (x_plus_yR r).1)	        :	        R'' -> No in	      let zcut :=	        plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	          x_plus_yL_lt_yR in	      let X := sum_options L R L'0 R'0 Sx s0 in	      ({{ zL | zR // zcut }};	      (fun l : L => lt_lopt zL zR zcut (inl l),	      fun r : R => lt_ropt zL zR zcut (inl r)))) L' R' s' yL yR ycut fyL fyR	       fycut)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	2 subgoals (ID 93)		subgoal 1 (ID 93) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (l : L') (p : {{ xL0 | xR0 // xcut0 }} <= yL l),	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 <= w.1) {{ xL0 | xR0 // xcut0 }} (yL l) p	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	       (x_plus_yL : forall l0 : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l0))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l0) (yR0 r) 	                            (ycut0 l0 r) (x_plus_yL l0) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	         (fun l0 : L'0 => (x_plus_yL l0).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l0 : L => lt_lopt zL zR zcut (inl l0),	     fun r : R => lt_ropt zL zR zcut (inl r)))) L0 R0 s xL0 xR0 xcut0 fxL fxR	      fxcut) (fyL l) ->	 (fun (x y : GenNo S) (_ : x < y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	  z.1 < w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (lt_l xL0 xR0 xcut0 yL yR ycut l p)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	       (x_plus_yL : forall l0 : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l0))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l0) (yR0 r) 	                            (ycut0 l0 r) (x_plus_yL l0) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	         (fun l0 : L'0 => (x_plus_yL l0).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l0 : L => lt_lopt zL zR zcut (inl l0),	     fun r : R => lt_ropt zL zR zcut (inl r)))) L0 R0 s xL0 xR0 xcut0 fxL fxR	      fxcut)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	       (x_plus_yL : forall l0 : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                     (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                      (yL0 l0))	       (x_plus_yR : forall r : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yR0 r))	       (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l1 : L,	                                    (xL_plus l1).1 y0 < x_plus_y) *	                                   (forall r0 : R,	                                    x_plus_y < (xR_plus r0).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l0) (yR0 r) 	                            (ycut0 l0 r) (x_plus_yL l0) 	                            (x_plus_yR r)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	         (fun l0 : L'0 => (x_plus_yL l0).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	         (fun r : R'0 => (x_plus_yR r).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l0 : L => lt_lopt zL zR zcut (inl l0),	     fun r : R => lt_ropt zL zR zcut (inl r)))) L' R' s' yL yR ycut fyL fyR	      fycut)	subgoal 2 (ID 95) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (r : R0) (p : xR0 r <= {{ yL | yR // ycut }}),	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	  z.1 <= w.1) (xR0 r) {{ yL | yR // ycut }} p (fxR r)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L' R' s' yL yR ycut fyL fyR	      fycut) ->	 (fun (x y : GenNo S) (_ : x < y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	  z.1 < w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (lt_r xL0 xR0 xcut0 yL yR ycut r p)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L0 R0 s xL0 xR0 xcut0 fxL	      fxR fxcut)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L' R' s' yL yR ycut fyL fyR	      fycut)	";
            responses[i]=data;
          

            i = 56;
            data = "1 subgoal (ID 93)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  ============================	  forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	  (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	  (fxL : forall l : L0,	         (fun y : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	           (xL0 l))	  (fxR : forall r : R0,	         (fun y : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	           (xR0 r))	  (fxcut : forall (l : L0) (r : R0),	           (fun (x y : GenNo S) (_ : x < y)	              (z : (fun y0 : GenNo S =>	                    {x_plus_y : No &	                    (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                    (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	              (w : (fun y0 : GenNo S =>	                    {x_plus_y : No &	                    (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                    (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	            z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	             (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	  (yL : L' -> GenNo S) (yR : R' -> GenNo S)	  (ycut : forall (l : L') (r : R'), yL l < yR r)	  (fyL : forall l : L',	         (fun y : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	           (yL l))	  (fyR : forall r : R',	         (fun y : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	           (yR r))	  (fycut : forall (l : L') (r : R'),	           (fun (x y : GenNo S) (_ : x < y)	              (z : (fun y0 : GenNo S =>	                    {x_plus_y : No &	                    (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                    (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	              (w : (fun y0 : GenNo S =>	                    {x_plus_y : No &	                    (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                    (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	            z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	             (fyR r)) (l : L') (p : {{ xL0 | xR0 // xcut0 }} <= yL l),	  (fun (x y : GenNo S) (_ : x <= y)	     (z : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	     (w : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	   z.1 <= w.1) {{ xL0 | xR0 // xcut0 }} (yL l) p	    ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	        (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	        (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	        (x_plus_yL : forall l0 : L'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                      (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                       (yL0 l0))	        (x_plus_yR : forall r : R'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                      (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                       (yR0 r))	        (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                           (fun (x y : GenNo S) (_ : x < y)	                              (z : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l1 : L,	                                     (xL_plus l1).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) x)	                              (w : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l1 : L,	                                     (xL_plus l1).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) y) =>	                            z.1 < w.1) (yL0 l0) (yR0 r) 	                             (ycut0 l0 r) (x_plus_yL l0) 	                             (x_plus_yR r)) =>	      let L'' := L + L'0 in	      let R'' := R + R'0 in	      let zL :=	        sum_ind (fun _ : L + L'0 => No)	          (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	          (fun l0 : L'0 => (x_plus_yL l0).1)	        :	        L'' -> No in	      let zR :=	        sum_ind (fun _ : R + R'0 => No)	          (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	          (fun r : R'0 => (x_plus_yR r).1)	        :	        R'' -> No in	      let zcut :=	        plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	          x_plus_yL_lt_yR in	      let X := sum_options L R L'0 R'0 Sx s0 in	      ({{ zL | zR // zcut }};	      (fun l0 : L => lt_lopt zL zR zcut (inl l0),	      fun r : R => lt_ropt zL zR zcut (inl r)))) L0 R0 s xL0 xR0 xcut0 fxL	       fxR fxcut) (fyL l) ->	  (fun (x y : GenNo S) (_ : x < y)	     (z : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y0)}) x)	     (w : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	           (forall r : R, x_plus_y < (xR_plus r).1 y0)}) y) => 	   z.1 < w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	    (lt_l xL0 xR0 xcut0 yL yR ycut l p)	    ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	        (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	        (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	        (x_plus_yL : forall l0 : L'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                      (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                       (yL0 l0))	        (x_plus_yR : forall r : R'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                      (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                       (yR0 r))	        (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                           (fun (x y : GenNo S) (_ : x < y)	                              (z : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l1 : L,	                                     (xL_plus l1).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) x)	                              (w : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l1 : L,	                                     (xL_plus l1).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) y) =>	                            z.1 < w.1) (yL0 l0) (yR0 r) 	                             (ycut0 l0 r) (x_plus_yL l0) 	                             (x_plus_yR r)) =>	      let L'' := L + L'0 in	      let R'' := R + R'0 in	      let zL :=	        sum_ind (fun _ : L + L'0 => No)	          (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	          (fun l0 : L'0 => (x_plus_yL l0).1)	        :	        L'' -> No in	      let zR :=	        sum_ind (fun _ : R + R'0 => No)	          (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	          (fun r : R'0 => (x_plus_yR r).1)	        :	        R'' -> No in	      let zcut :=	        plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	          x_plus_yL_lt_yR in	      let X := sum_options L R L'0 R'0 Sx s0 in	      ({{ zL | zR // zcut }};	      (fun l0 : L => lt_lopt zL zR zcut (inl l0),	      fun r : R => lt_ropt zL zR zcut (inl r)))) L0 R0 s xL0 xR0 xcut0 fxL	       fxR fxcut)	    ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	        (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	        (ycut0 : forall (l0 : L'0) (r : R'0), yL0 l0 < yR0 r)	        (x_plus_yL : forall l0 : L'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l1 : L, (xL_plus l1).1 y < x_plus_y) *	                      (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	                       (yL0 l0))	        (x_plus_yR : forall r : R'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                      (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                       (yR0 r))	        (x_plus_yL_lt_yR : forall (l0 : L'0) (r : R'0),	                           (fun (x y : GenNo S) (_ : x < y)	                              (z : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l1 : L,	                                     (xL_plus l1).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) x)	                              (w : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l1 : L,	                                     (xL_plus l1).1 y0 < x_plus_y) *	                                    (forall r0 : R,	                                     x_plus_y < (xR_plus r0).1 y0)}) y) =>	                            z.1 < w.1) (yL0 l0) (yR0 r) 	                             (ycut0 l0 r) (x_plus_yL l0) 	                             (x_plus_yR r)) =>	      let L'' := L + L'0 in	      let R'' := R + R'0 in	      let zL :=	        sum_ind (fun _ : L + L'0 => No)	          (fun l0 : L => (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	          (fun l0 : L'0 => (x_plus_yL l0).1)	        :	        L'' -> No in	      let zR :=	        sum_ind (fun _ : R + R'0 => No)	          (fun r : R => (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	          (fun r : R'0 => (x_plus_yR r).1)	        :	        R'' -> No in	      let zcut :=	        plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	          x_plus_yL_lt_yR in	      let X := sum_options L R L'0 R'0 Sx s0 in	      ({{ zL | zR // zcut }};	      (fun l0 : L => lt_lopt zL zR zcut (inl l0),	      fun r : R => lt_ropt zL zR zcut (inl r)))) L' R' s' yL yR ycut fyL fyR	       fycut)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 95)		subgoal 1 (ID 95) is:	 forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	 (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	 (fxL : forall l : L0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (xL0 l))	 (fxR : forall r : R0,	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (xR0 r))	 (fxcut : forall (l : L0) (r : R0),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	            (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	 (yL : L' -> GenNo S) (yR : R' -> GenNo S)	 (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : forall l : L',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	         (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	          (yL l))	 (fyR : forall r : R',	        (fun y : GenNo S =>	         {x_plus_y : No &	         (forall l : L, (xL_plus l).1 y < x_plus_y) *	         (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	          (yR r))	 (fycut : forall (l : L') (r : R'),	          (fun (x y : GenNo S) (_ : x < y)	             (z : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	             (w : (fun y0 : GenNo S =>	                   {x_plus_y : No &	                   (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                   (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	           z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	            (fyR r)) (r : R0) (p : xR0 r <= {{ yL | yR // ycut }}),	 (fun (x y : GenNo S) (_ : x <= y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	  z.1 <= w.1) (xR0 r) {{ yL | yR // ycut }} p (fxR r)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L' R' s' yL yR ycut fyL fyR	      fycut) ->	 (fun (x y : GenNo S) (_ : x < y)	    (z : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	    (w : (fun y0 : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	  z.1 < w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	   (lt_r xL0 xR0 xcut0 yL yR ycut r p)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L0 R0 s xL0 xR0 xcut0 fxL	      fxR fxcut)	   ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	       (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	       (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	       (x_plus_yL : forall l : L'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                     (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                      (yL0 l))	       (x_plus_yR : forall r0 : R'0,	                    (fun y : GenNo S =>	                     {x_plus_y : No &	                     (forall l : L, (xL_plus l).1 y < x_plus_y) *	                     (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                      (yR0 r0))	       (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) x)	                             (w : (fun y0 : GenNo S =>	                                   {x_plus_y : No &	                                   (forall l0 : L,	                                    (xL_plus l0).1 y0 < x_plus_y) *	                                   (forall r1 : R,	                                    x_plus_y < (xR_plus r1).1 y0)}) y) =>	                           z.1 < w.1) (yL0 l) (yR0 r0) 	                            (ycut0 l r0) (x_plus_yL l) 	                            (x_plus_yR r0)) =>	     let L'' := L + L'0 in	     let R'' := R + R'0 in	     let zL :=	       sum_ind (fun _ : L + L'0 => No)	         (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	         (fun l : L'0 => (x_plus_yL l).1)	       :	       L'' -> No in	     let zR :=	       sum_ind (fun _ : R + R'0 => No)	         (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	         (fun r0 : R'0 => (x_plus_yR r0).1)	       :	       R'' -> No in	     let zcut :=	       plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	         x_plus_yL_lt_yR in	     let X := sum_options L R L'0 R'0 Sx s0 in	     ({{ zL | zR // zcut }};	     (fun l : L => lt_lopt zL zR zcut (inl l),	     fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L' R' s' yL yR ycut fyL fyR	      fycut)	";
            responses[i]=data;
          

            i = 57;
            data = "1 subgoal (ID 95)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  ============================	  forall (L0 R0 : Type) (s : InSort S L0 R0) (xL0 : L0 -> GenNo S)	  (xR0 : R0 -> GenNo S) (xcut0 : forall (l : L0) (r : R0), xL0 l < xR0 r)	  (fxL : forall l : L0,	         (fun y : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	           (xL0 l))	  (fxR : forall r : R0,	         (fun y : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	           (xR0 r))	  (fxcut : forall (l : L0) (r : R0),	           (fun (x y : GenNo S) (_ : x < y)	              (z : (fun y0 : GenNo S =>	                    {x_plus_y : No &	                    (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                    (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	              (w : (fun y0 : GenNo S =>	                    {x_plus_y : No &	                    (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                    (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	            z.1 < w.1) (xL0 l) (xR0 r) (xcut0 l r) 	             (fxL l) (fxR r)) (L' R' : Type) (s' : InSort S L' R')	  (yL : L' -> GenNo S) (yR : R' -> GenNo S)	  (ycut : forall (l : L') (r : R'), yL l < yR r)	  (fyL : forall l : L',	         (fun y : GenNo S =>	          {x_plus_y : No &	          (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	          (forall r : R, x_plus_y < (xR_plus r).1 y)}) 	           (yL l))	  (fyR : forall r : R',	         (fun y : GenNo S =>	          {x_plus_y : No &	          (forall l : L, (xL_plus l).1 y < x_plus_y) *	          (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	           (yR r))	  (fycut : forall (l : L') (r : R'),	           (fun (x y : GenNo S) (_ : x < y)	              (z : (fun y0 : GenNo S =>	                    {x_plus_y : No &	                    (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                    (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	              (w : (fun y0 : GenNo S =>	                    {x_plus_y : No &	                    (forall l0 : L, (xL_plus l0).1 y0 < x_plus_y) *	                    (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) =>	            z.1 < w.1) (yL l) (yR r) (ycut l r) (fyL l) 	             (fyR r)) (r : R0) (p : xR0 r <= {{ yL | yR // ycut }}),	  (fun (x y : GenNo S) (_ : x <= y)	     (z : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	           (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	     (w : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	           (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	   z.1 <= w.1) (xR0 r) {{ yL | yR // ycut }} p (fxR r)	    ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	        (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	        (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	        (x_plus_yL : forall l : L'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                      (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                       (yL0 l))	        (x_plus_yR : forall r0 : R'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l : L, (xL_plus l).1 y < x_plus_y) *	                      (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                       (yR0 r0))	        (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                           (fun (x y : GenNo S) (_ : x < y)	                              (z : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r1 : R,	                                     x_plus_y < (xR_plus r1).1 y0)}) x)	                              (w : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r1 : R,	                                     x_plus_y < (xR_plus r1).1 y0)}) y) =>	                            z.1 < w.1) (yL0 l) (yR0 r0) 	                             (ycut0 l r0) (x_plus_yL l) 	                             (x_plus_yR r0)) =>	      let L'' := L + L'0 in	      let R'' := R + R'0 in	      let zL :=	        sum_ind (fun _ : L + L'0 => No)	          (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	          (fun l : L'0 => (x_plus_yL l).1)	        :	        L'' -> No in	      let zR :=	        sum_ind (fun _ : R + R'0 => No)	          (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	          (fun r0 : R'0 => (x_plus_yR r0).1)	        :	        R'' -> No in	      let zcut :=	        plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	          x_plus_yL_lt_yR in	      let X := sum_options L R L'0 R'0 Sx s0 in	      ({{ zL | zR // zcut }};	      (fun l : L => lt_lopt zL zR zcut (inl l),	      fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L' R' s' yL yR ycut fyL	       fyR fycut) ->	  (fun (x y : GenNo S) (_ : x < y)	     (z : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	           (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) x)	     (w : (fun y0 : GenNo S =>	           {x_plus_y : No &	           (forall l : L, (xL_plus l).1 y0 < x_plus_y) *	           (forall r0 : R, x_plus_y < (xR_plus r0).1 y0)}) y) => 	   z.1 < w.1) {{ xL0 | xR0 // xcut0 }} {{ yL | yR // ycut }}	    (lt_r xL0 xR0 xcut0 yL yR ycut r p)	    ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	        (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	        (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	        (x_plus_yL : forall l : L'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                      (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                       (yL0 l))	        (x_plus_yR : forall r0 : R'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l : L, (xL_plus l).1 y < x_plus_y) *	                      (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                       (yR0 r0))	        (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                           (fun (x y : GenNo S) (_ : x < y)	                              (z : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r1 : R,	                                     x_plus_y < (xR_plus r1).1 y0)}) x)	                              (w : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r1 : R,	                                     x_plus_y < (xR_plus r1).1 y0)}) y) =>	                            z.1 < w.1) (yL0 l) (yR0 r0) 	                             (ycut0 l r0) (x_plus_yL l) 	                             (x_plus_yR r0)) =>	      let L'' := L + L'0 in	      let R'' := R + R'0 in	      let zL :=	        sum_ind (fun _ : L + L'0 => No)	          (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	          (fun l : L'0 => (x_plus_yL l).1)	        :	        L'' -> No in	      let zR :=	        sum_ind (fun _ : R + R'0 => No)	          (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	          (fun r0 : R'0 => (x_plus_yR r0).1)	        :	        R'' -> No in	      let zcut :=	        plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	          x_plus_yL_lt_yR in	      let X := sum_options L R L'0 R'0 Sx s0 in	      ({{ zL | zR // zcut }};	      (fun l : L => lt_lopt zL zR zcut (inl l),	      fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L0 R0 s xL0 xR0 xcut0 fxL	       fxR fxcut)	    ((fun (L'0 R'0 : Type) (s0 : InSort S L'0 R'0) 	        (yL0 : L'0 -> GenNo S) (yR0 : R'0 -> GenNo S)	        (ycut0 : forall (l : L'0) (r0 : R'0), yL0 l < yR0 r0)	        (x_plus_yL : forall l : L'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                      (forall r0 : R, x_plus_y < (xR_plus r0).1 y)}) 	                       (yL0 l))	        (x_plus_yR : forall r0 : R'0,	                     (fun y : GenNo S =>	                      {x_plus_y : No &	                      (forall l : L, (xL_plus l).1 y < x_plus_y) *	                      (forall r1 : R, x_plus_y < (xR_plus r1).1 y)}) 	                       (yR0 r0))	        (x_plus_yL_lt_yR : forall (l : L'0) (r0 : R'0),	                           (fun (x y : GenNo S) (_ : x < y)	                              (z : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r1 : R,	                                     x_plus_y < (xR_plus r1).1 y0)}) x)	                              (w : (fun y0 : GenNo S =>	                                    {x_plus_y : No &	                                    (forall l0 : L,	                                     (xL_plus l0).1 y0 < x_plus_y) *	                                    (forall r1 : R,	                                     x_plus_y < (xR_plus r1).1 y0)}) y) =>	                            z.1 < w.1) (yL0 l) (yR0 r0) 	                             (ycut0 l r0) (x_plus_yL l) 	                             (x_plus_yR r0)) =>	      let L'' := L + L'0 in	      let R'' := R + R'0 in	      let zL :=	        sum_ind (fun _ : L + L'0 => No)	          (fun l : L => (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	          (fun l : L'0 => (x_plus_yL l).1)	        :	        L'' -> No in	      let zR :=	        sum_ind (fun _ : R + R'0 => No)	          (fun r0 : R => (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	          (fun r0 : R'0 => (x_plus_yR r0).1)	        :	        R'' -> No in	      let zcut :=	        plus_inner_subproof L'0 R'0 s0 yL0 yR0 ycut0 x_plus_yL x_plus_yR	          x_plus_yL_lt_yR in	      let X := sum_options L R L'0 R'0 Sx s0 in	      ({{ zL | zR // zcut }};	      (fun l : L => lt_lopt zL zR zcut (inl l),	      fun r0 : R => lt_ropt zL zR zcut (inl r0)))) L' R' s' yL yR ycut fyL	       fyR fycut)	No more subgoals.	";
            responses[i]=data;
          

            i = 58;
            data = "";
            responses[i]=data;
          

            i = 59;
            data = "";
            responses[i]=data;
          

            i = 60;
            data = "";
            responses[i]=data;
          

            i = 61;
            data = "";
            responses[i]=data;
          

            i = 62;
            data = "";
            responses[i]=data;
          

            i = 63;
            data = "";
            responses[i]=data;
          

            i = 64;
            data = "";
            responses[i]=data;
          

            i = 65;
            data = "";
            responses[i]=data;
          

            i = 66;
            data = "";
            responses[i]=data;
          

            i = 67;
            data = "";
            responses[i]=data;
          

            i = 68;
            data = "";
            responses[i]=data;
          

            i = 69;
            data = "1 subgoal (ID 113)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  Sy : InSort S L' R'	  yL : L' -> No	  yR : R' -> No	  ycut : forall (l : L') (r : R'), yL l < yR r	  ============================	  let L'' := L + L' in	  let R'' := R + R' in	  let zL :=	    sum_ind (fun _ : L + L' => No)	      (fun l : L => (xL_plus l).1 {{ yL | yR // ycut }})	      (fun l : L' => (plus_inner.1 (yL l)).1) in	  let zR :=	    sum_ind (fun _ : R + R' => No)	      (fun r : R => (xR_plus r).1 {{ yL | yR // ycut }})	      (fun r : R' => (plus_inner.1 (yR r)).1) in	  let Sz := sum_options L R L' R' Sx Sy in	  {zcut : forall (l : L'') (r : R''), zL l < zR r &	  (plus_inner.1 {{ yL | yR // ycut }}).1 = {{ zL | zR // zcut }}}	";
            responses[i]=data;
          

            i = 70;
            data = "";
            responses[i]=data;
          

            i = 71;
            data = "";
            responses[i]=data;
          

            i = 72;
            data = "";
            responses[i]=data;
          

            i = 73;
            data = "";
            responses[i]=data;
          

            i = 74;
            data = "";
            responses[i]=data;
          

            i = 75;
            data = "1 focused subgoal	(shelved: 1) (ID 116)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  Sy : InSort S L' R'	  yL : L' -> No	  yR : R' -> No	  ycut : forall (l : L') (r : R'), yL l < yR r	  ============================	  (plus_inner.1 {{ yL | yR // ycut }}).1 =	  {{ sum_ind (fun _ : L + L' => No)	       (fun l : L => (xL_plus l).1 {{ yL | yR // ycut }})	       (fun l : L' => (plus_inner.1 (yL l)).1) | sum_ind	                                                 (fun _ : R + R' => No)	                                                 (fun r : R =>	                                                 (xR_plus r).1	                                                 {{ yL | yR // ycut }})	                                                 (fun r : R' =>	                                                 (plus_inner.1 (yR r)).1) // 	  ?zcut }}	";
            responses[i]=data;
          

            i = 76;
            data = "";
            responses[i]=data;
          

            i = 77;
            data = "";
            responses[i]=data;
          

            i = 78;
            data = "";
            responses[i]=data;
          

            i = 79;
            data = "";
            responses[i]=data;
          

            i = 80;
            data = "";
            responses[i]=data;
          

            i = 81;
            data = "";
            responses[i]=data;
          

            i = 82;
            data = "";
            responses[i]=data;
          

            i = 83;
            data = "1 focused subgoal	(shelved: 1) (ID 119)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  L, R : Type	  Sx : InSort S L R	  xL : L -> No	  xR : R -> No	  xcut : forall (l : L) (r : R), xL l < xR r	  A := {g : No -> No &	       (forall x y : No, x <= y -> g x <= g y) *	       (forall x y : No, x < y -> g x < g y)} : Type	  xL_plus : L -> A	  xR_plus : R -> A	  xL_lt_xR_plus : forall (l : L) (r : R) (x : No),	                  (xL_plus l).1 x < (xR_plus r).1 x	  L', R' : Type	  Sy : InSort S L' R'	  yL : L' -> No	  yR : R' -> No	  ycut : forall (l : L') (r : R'), yL l < yR r	  ============================	  {|	  game_of := opt (L + L') (R + R') (sum_options L R L' R' Sx Sy)	               (fun x : L + L' =>	                game_of	                  (sum_ind (fun _ : L + L' => No)	                     (fun l : L =>	                      (xL_plus l).1	                        {{ fun l0 : L' =>	                           {|	                           game_of := game_of (yL l0);	                           isno_game_of := isno_game_of (yL l0) |} | 	                        (fun r : R' =>	                         {|	                         game_of := game_of (yR r);	                         isno_game_of := isno_game_of (yR r) |}) // ycut }})	                     (fun l : L' =>	                      (Core.Surreals.No_ind_internal	                         (fun y : GenNo S =>	                          {x_plus_y : No &	                          (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                          (forall r : R, x_plus_y < (xR_plus r).1 y)})	                         (fun (x0 y : GenNo S) (_ : x0 <= y)	                            (z : {x_plus_y : No &	                                 (forall l0 : L, (xL_plus l0).1 x0 < x_plus_y) *	                                 (forall r : R, x_plus_y < (xR_plus r).1 x0)})	                            (w : {x_plus_y : No &	                                 (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                                 (forall r : R, x_plus_y < (xR_plus r).1 y)})	                          => z.1 <= w.1)	                         (fun (x0 y : GenNo S) (_ : x0 < y)	                            (z : {x_plus_y : No &	                                 (forall l0 : L, (xL_plus l0).1 x0 < x_plus_y) *	                                 (forall r : R, x_plus_y < (xR_plus r).1 x0)})	                            (w : {x_plus_y : No &	                                 (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                                 (forall r : R, x_plus_y < (xR_plus r).1 y)})	                          => z.1 < w.1)	                         (fun (L'0 R'0 : Type) (s : InSort S L'0 R'0)	                            (yL0 : L'0 -> GenNo S) 	                            (yR0 : R'0 -> GenNo S)	                            (ycut0 : forall (l0 : L'0) 	                                     (r : R'0), yL0 l0 < yR0 r)	                            (x_plus_yL : forall l0 : L'0,	                                         {x_plus_y : No &	                                         (forall l1 : L,	                                          (xL_plus l1).1 (yL0 l0) < x_plus_y) *	                                         (forall r : R,	                                          x_plus_y < (xR_plus r).1 (yL0 l0))})	                            (x_plus_yR : forall r : R'0,	                                         {x_plus_y : No &	                                         (forall l0 : L,	                                          (xL_plus l0).1 (yR0 r) < x_plus_y) *	                                         (forall r0 : R,	                                          x_plus_y < (xR_plus r0).1 (yR0 r))})	                            (x_plus_yL_lt_yR : forall 	                                               (l0 : L'0) 	                                               (r : R'0),	                                               (x_plus_yL l0).1 <	                                               (x_plus_yR r).1) =>	                          let L'' := L + L'0 in	                          let R'' := R + R'0 in	                          let zL :=	                            sum_ind (fun _ : L + L'0 => No)	                              (fun l0 : L =>	                               (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	                              (fun l0 : L'0 => (x_plus_yL l0).1) in	                          let zR :=	                            sum_ind (fun _ : R + R'0 => No)	                              (fun r : R =>	                               (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	                              (fun r : R'0 => (x_plus_yR r).1) in	                          let zcut :=	                            plus_inner_subproof L'0 R'0 s yL0 yR0 ycut0	                              x_plus_yL x_plus_yR x_plus_yL_lt_yR in	                          let X := sum_options L R L'0 R'0 Sx s in	                          ({{ zL | zR // zcut }};	                          (fun l0 : L => lt_lopt zL zR zcut (inl l0),	                          fun r : R => lt_ropt zL zR zcut (inl r))))	                         plus_inner_subproof0 plus_inner_subproof1	                         plus_inner_subproof2 plus_inner_subproof3	                         (game_of (yL l)) (isno_game_of (yL l))).1) x))	               (fun x : R + R' =>	                game_of	                  (sum_ind (fun _ : R + R' => No)	                     (fun r : R =>	                      (xR_plus r).1	                        {{ fun l : L' =>	                           {|	                           game_of := game_of (yL l);	                           isno_game_of := isno_game_of (yL l) |} | 	                        (fun r0 : R' =>	                         {|	                         game_of := game_of (yR r0);	                         isno_game_of := isno_game_of (yR r0) |}) // ycut }})	                     (fun r : R' =>	                      (Core.Surreals.No_ind_internal	                         (fun y : GenNo S =>	                          {x_plus_y : No &	                          (forall l : L, (xL_plus l).1 y < x_plus_y) *	                          (forall r0 : R, x_plus_y < (xR_plus r0).1 y)})	                         (fun (x0 y : GenNo S) (_ : x0 <= y)	                            (z : {x_plus_y : No &	                                 (forall l : L, (xL_plus l).1 x0 < x_plus_y) *	                                 (forall r0 : R, x_plus_y < (xR_plus r0).1 x0)})	                            (w : {x_plus_y : No &	                                 (forall l : L, (xL_plus l).1 y < x_plus_y) *	                                 (forall r0 : R, x_plus_y < (xR_plus r0).1 y)})	                          => z.1 <= w.1)	                         (fun (x0 y : GenNo S) (_ : x0 < y)	                            (z : {x_plus_y : No &	                                 (forall l : L, (xL_plus l).1 x0 < x_plus_y) *	                                 (forall r0 : R, x_plus_y < (xR_plus r0).1 x0)})	                            (w : {x_plus_y : No &	                                 (forall l : L, (xL_plus l).1 y < x_plus_y) *	                                 (forall r0 : R, x_plus_y < (xR_plus r0).1 y)})	                          => z.1 < w.1)	                         (fun (L'0 R'0 : Type) (s : InSort S L'0 R'0)	                            (yL0 : L'0 -> GenNo S) 	                            (yR0 : R'0 -> GenNo S)	                            (ycut0 : forall (l : L'0) 	                                     (r0 : R'0), yL0 l < yR0 r0)	                            (x_plus_yL : forall l : L'0,	                                         {x_plus_y : No &	                                         (forall l0 : L,	                                          (xL_plus l0).1 (yL0 l) < x_plus_y) *	                                         (forall r0 : R,	                                          x_plus_y < (xR_plus r0).1 (yL0 l))})	                            (x_plus_yR : forall r0 : R'0,	                                         {x_plus_y : No &	                                         (forall l : L,	                                          (xL_plus l).1 (yR0 r0) < x_plus_y) *	                                         (forall r1 : R,	                                          x_plus_y < (xR_plus r1).1 (yR0 r0))})	                            (x_plus_yL_lt_yR : forall 	                                               (l : L'0) 	                                               (r0 : R'0),	                                               (x_plus_yL l).1 <	                                               (x_plus_yR r0).1) =>	                          let L'' := L + L'0 in	                          let R'' := R + R'0 in	                          let zL :=	                            sum_ind (fun _ : L + L'0 => No)	                              (fun l : L =>	                               (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	                              (fun l : L'0 => (x_plus_yL l).1) in	                          let zR :=	                            sum_ind (fun _ : R + R'0 => No)	                              (fun r0 : R =>	                               (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	                              (fun r0 : R'0 => (x_plus_yR r0).1) in	                          let zcut :=	                            plus_inner_subproof L'0 R'0 s yL0 yR0 ycut0	                              x_plus_yL x_plus_yR x_plus_yL_lt_yR in	                          let X := sum_options L R L'0 R'0 Sx s in	                          ({{ zL | zR // zcut }};	                          (fun l : L => lt_lopt zL zR zcut (inl l),	                          fun r0 : R => lt_ropt zL zR zcut (inl r0))))	                         plus_inner_subproof0 plus_inner_subproof1	                         plus_inner_subproof2 plus_inner_subproof3	                         (game_of (yR r)) (isno_game_of (yR r))).1) x));	  isno_game_of := isno (L + L') (R + R') (sum_options L R L' R' Sx Sy)	                    (fun x : L + L' =>	                     game_of	                       (sum_ind (fun _ : L + L' => No)	                          (fun l : L =>	                           (xL_plus l).1	                             {{ fun l0 : L' =>	                                {|	                                game_of := game_of (yL l0);	                                isno_game_of := isno_game_of (yL l0) |} | 	                             (fun r : R' =>	                              {|	                              game_of := game_of (yR r);	                              isno_game_of := isno_game_of (yR r) |}) // ycut }})	                          (fun l : L' =>	                           (Core.Surreals.No_ind_internal	                              (fun y : GenNo S =>	                               {x_plus_y : No &	                               (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                               (forall r : R, x_plus_y < (xR_plus r).1 y)})	                              (fun (x0 y : GenNo S) 	                                 (_ : x0 <= y)	                                 (z : {x_plus_y : No &	                                      (forall l0 : L,	                                       (xL_plus l0).1 x0 < x_plus_y) *	                                      (forall r : R,	                                       x_plus_y < (xR_plus r).1 x0)})	                                 (w : {x_plus_y : No &	                                      (forall l0 : L,	                                       (xL_plus l0).1 y < x_plus_y) *	                                      (forall r : R,	                                       x_plus_y < (xR_plus r).1 y)}) =>	                               z.1 <= w.1)	                              (fun (x0 y : GenNo S) 	                                 (_ : x0 < y)	                                 (z : {x_plus_y : No &	                                      (forall l0 : L,	                                       (xL_plus l0).1 x0 < x_plus_y) *	                                      (forall r : R,	                                       x_plus_y < (xR_plus r).1 x0)})	                                 (w : {x_plus_y : No &	                                      (forall l0 : L,	                                       (xL_plus l0).1 y < x_plus_y) *	                                      (forall r : R,	                                       x_plus_y < (xR_plus r).1 y)}) =>	                               z.1 < w.1)	                              (fun (L'0 R'0 : Type) 	                                 (s : InSort S L'0 R'0)	                                 (yL0 : L'0 -> GenNo S)	                                 (yR0 : R'0 -> GenNo S)	                                 (ycut0 : forall (l0 : L'0) 	                                          (r : R'0), 	                                          yL0 l0 < yR0 r)	                                 (x_plus_yL : forall 	                                              l0 : L'0,	                                              {x_plus_y : No &	                                              (forall 	                                               l1 : L,	                                               (xL_plus l1).1 (yL0 l0) <	                                               x_plus_y) *	                                              (forall 	                                               r : R,	                                               x_plus_y <	                                               (xR_plus r).1 (yL0 l0))})	                                 (x_plus_yR : forall 	                                              r : R'0,	                                              {x_plus_y : No &	                                              (forall 	                                               l0 : L,	                                               (xL_plus l0).1 (yR0 r) <	                                               x_plus_y) *	                                              (forall 	                                               r0 : R,	                                               x_plus_y <	                                               (xR_plus r0).1 (yR0 r))})	                                 (x_plus_yL_lt_yR : 	                                  forall (l0 : L'0) 	                                  (r : R'0),	                                  (x_plus_yL l0).1 < (x_plus_yR r).1) =>	                               let L'' := L + L'0 in	                               let R'' := R + R'0 in	                               let zL :=	                                 sum_ind (fun _ : L + L'0 => No)	                                   (fun l0 : L =>	                                    (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	                                   (fun l0 : L'0 => (x_plus_yL l0).1) in	                               let zR :=	                                 sum_ind (fun _ : R + R'0 => No)	                                   (fun r : R =>	                                    (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	                                   (fun r : R'0 => (x_plus_yR r).1) in	                               let zcut :=	                                 plus_inner_subproof L'0 R'0 s yL0 yR0 ycut0	                                   x_plus_yL x_plus_yR x_plus_yL_lt_yR in	                               let X := sum_options L R L'0 R'0 Sx s in	                               ({{ zL | zR // zcut }};	                               (fun l0 : L => lt_lopt zL zR zcut (inl l0),	                               fun r : R => lt_ropt zL zR zcut (inl r))))	                              plus_inner_subproof0 plus_inner_subproof1	                              plus_inner_subproof2 plus_inner_subproof3	                              (game_of (yL l)) (isno_game_of (yL l))).1) x))	                    (fun x : R + R' =>	                     game_of	                       (sum_ind (fun _ : R + R' => No)	                          (fun r : R =>	                           (xR_plus r).1	                             {{ fun l : L' =>	                                {|	                                game_of := game_of (yL l);	                                isno_game_of := isno_game_of (yL l) |} | 	                             (fun r0 : R' =>	                              {|	                              game_of := game_of (yR r0);	                              isno_game_of := isno_game_of (yR r0) |}) // ycut }})	                          (fun r : R' =>	                           (Core.Surreals.No_ind_internal	                              (fun y : GenNo S =>	                               {x_plus_y : No &	                               (forall l : L, (xL_plus l).1 y < x_plus_y) *	                               (forall r0 : R, x_plus_y < (xR_plus r0).1 y)})	                              (fun (x0 y : GenNo S) 	                                 (_ : x0 <= y)	                                 (z : {x_plus_y : No &	                                      (forall l : L,	                                       (xL_plus l).1 x0 < x_plus_y) *	                                      (forall r0 : R,	                                       x_plus_y < (xR_plus r0).1 x0)})	                                 (w : {x_plus_y : No &	                                      (forall l : L,	                                       (xL_plus l).1 y < x_plus_y) *	                                      (forall r0 : R,	                                       x_plus_y < (xR_plus r0).1 y)}) =>	                               z.1 <= w.1)	                              (fun (x0 y : GenNo S) 	                                 (_ : x0 < y)	                                 (z : {x_plus_y : No &	                                      (forall l : L,	                                       (xL_plus l).1 x0 < x_plus_y) *	                                      (forall r0 : R,	                                       x_plus_y < (xR_plus r0).1 x0)})	                                 (w : {x_plus_y : No &	                                      (forall l : L,	                                       (xL_plus l).1 y < x_plus_y) *	                                      (forall r0 : R,	                                       x_plus_y < (xR_plus r0).1 y)}) =>	                               z.1 < w.1)	                              (fun (L'0 R'0 : Type) 	                                 (s : InSort S L'0 R'0)	                                 (yL0 : L'0 -> GenNo S)	                                 (yR0 : R'0 -> GenNo S)	                                 (ycut0 : forall (l : L'0) 	                                          (r0 : R'0), 	                                          yL0 l < yR0 r0)	                                 (x_plus_yL : forall 	                                              l : L'0,	                                              {x_plus_y : No &	                                              (forall 	                                               l0 : L,	                                               (xL_plus l0).1 (yL0 l) <	                                               x_plus_y) *	                                              (forall 	                                               r0 : R,	                                               x_plus_y <	                                               (xR_plus r0).1 (yL0 l))})	                                 (x_plus_yR : forall 	                                              r0 : R'0,	                                              {x_plus_y : No &	                                              (forall 	                                               l : L,	                                               (xL_plus l).1 (yR0 r0) <	                                               x_plus_y) *	                                              (forall 	                                               r1 : R,	                                               x_plus_y <	                                               (xR_plus r1).1 (yR0 r0))})	                                 (x_plus_yL_lt_yR : 	                                  forall (l : L'0) 	                                  (r0 : R'0),	                                  (x_plus_yL l).1 < (x_plus_yR r0).1) =>	                               let L'' := L + L'0 in	                               let R'' := R + R'0 in	                               let zL :=	                                 sum_ind (fun _ : L + L'0 => No)	                                   (fun l : L =>	                                    (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	                                   (fun l : L'0 => (x_plus_yL l).1) in	                               let zR :=	                                 sum_ind (fun _ : R + R'0 => No)	                                   (fun r0 : R =>	                                    (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	                                   (fun r0 : R'0 => (x_plus_yR r0).1) in	                               let zcut :=	                                 plus_inner_subproof L'0 R'0 s yL0 yR0 ycut0	                                   x_plus_yL x_plus_yR x_plus_yL_lt_yR in	                               let X := sum_options L R L'0 R'0 Sx s in	                               ({{ zL | zR // zcut }};	                               (fun l : L => lt_lopt zL zR zcut (inl l),	                               fun r0 : R => lt_ropt zL zR zcut (inl r0))))	                              plus_inner_subproof0 plus_inner_subproof1	                              plus_inner_subproof2 plus_inner_subproof3	                              (game_of (yR r)) (isno_game_of (yR r))).1) x))	                    (fun x : L + L' =>	                     isno_game_of	                       (sum_ind (fun _ : L + L' => No)	                          (fun l : L =>	                           (xL_plus l).1	                             {{ fun l0 : L' =>	                                {|	                                game_of := game_of (yL l0);	                                isno_game_of := isno_game_of (yL l0) |} | 	                             (fun r : R' =>	                              {|	                              game_of := game_of (yR r);	                              isno_game_of := isno_game_of (yR r) |}) // ycut }})	                          (fun l : L' =>	                           (Core.Surreals.No_ind_internal	                              (fun y : GenNo S =>	                               {x_plus_y : No &	                               (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                               (forall r : R, x_plus_y < (xR_plus r).1 y)})	                              (fun (x0 y : GenNo S) 	                                 (_ : x0 <= y)	                                 (z : {x_plus_y : No &	                                      (forall l0 : L,	                                       (xL_plus l0).1 x0 < x_plus_y) *	                                      (forall r : R,	                                       x_plus_y < (xR_plus r).1 x0)})	                                 (w : {x_plus_y : No &	                                      (forall l0 : L,	                                       (xL_plus l0).1 y < x_plus_y) *	                                      (forall r : R,	                                       x_plus_y < (xR_plus r).1 y)}) =>	                               z.1 <= w.1)	                              (fun (x0 y : GenNo S) 	                                 (_ : x0 < y)	                                 (z : {x_plus_y : No &	                                      (forall l0 : L,	                                       (xL_plus l0).1 x0 < x_plus_y) *	                                      (forall r : R,	                                       x_plus_y < (xR_plus r).1 x0)})	                                 (w : {x_plus_y : No &	                                      (forall l0 : L,	                                       (xL_plus l0).1 y < x_plus_y) *	                                      (forall r : R,	                                       x_plus_y < (xR_plus r).1 y)}) =>	                               z.1 < w.1)	                              (fun (L'0 R'0 : Type) 	                                 (s : InSort S L'0 R'0)	                                 (yL0 : L'0 -> GenNo S)	                                 (yR0 : R'0 -> GenNo S)	                                 (ycut0 : forall (l0 : L'0) 	                                          (r : R'0), 	                                          yL0 l0 < yR0 r)	                                 (x_plus_yL : forall 	                                              l0 : L'0,	                                              {x_plus_y : No &	                                              (forall 	                                               l1 : L,	                                               (xL_plus l1).1 (yL0 l0) <	                                               x_plus_y) *	                                              (forall 	                                               r : R,	                                               x_plus_y <	                                               (xR_plus r).1 (yL0 l0))})	                                 (x_plus_yR : forall 	                                              r : R'0,	                                              {x_plus_y : No &	                                              (forall 	                                               l0 : L,	                                               (xL_plus l0).1 (yR0 r) <	                                               x_plus_y) *	                                              (forall 	                                               r0 : R,	                                               x_plus_y <	                                               (xR_plus r0).1 (yR0 r))})	                                 (x_plus_yL_lt_yR : 	                                  forall (l0 : L'0) 	                                  (r : R'0),	                                  (x_plus_yL l0).1 < (x_plus_yR r).1) =>	                               let L'' := L + L'0 in	                               let R'' := R + R'0 in	                               let zL :=	                                 sum_ind (fun _ : L + L'0 => No)	                                   (fun l0 : L =>	                                    (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	                                   (fun l0 : L'0 => (x_plus_yL l0).1) in	                               let zR :=	                                 sum_ind (fun _ : R + R'0 => No)	                                   (fun r : R =>	                                    (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	                                   (fun r : R'0 => (x_plus_yR r).1) in	                               let zcut :=	                                 plus_inner_subproof L'0 R'0 s yL0 yR0 ycut0	                                   x_plus_yL x_plus_yR x_plus_yL_lt_yR in	                               let X := sum_options L R L'0 R'0 Sx s in	                               ({{ zL | zR // zcut }};	                               (fun l0 : L => lt_lopt zL zR zcut (inl l0),	                               fun r : R => lt_ropt zL zR zcut (inl r))))	                              plus_inner_subproof0 plus_inner_subproof1	                              plus_inner_subproof2 plus_inner_subproof3	                              (game_of (yL l)) (isno_game_of (yL l))).1) x))	                    (fun x : R + R' =>	                     isno_game_of	                       (sum_ind (fun _ : R + R' => No)	                          (fun r : R =>	                           (xR_plus r).1	                             {{ fun l : L' =>	                                {|	                                game_of := game_of (yL l);	                                isno_game_of := isno_game_of (yL l) |} | 	                             (fun r0 : R' =>	                              {|	                              game_of := game_of (yR r0);	                              isno_game_of := isno_game_of (yR r0) |}) // ycut }})	                          (fun r : R' =>	                           (Core.Surreals.No_ind_internal	                              (fun y : GenNo S =>	                               {x_plus_y : No &	                               (forall l : L, (xL_plus l).1 y < x_plus_y) *	                               (forall r0 : R, x_plus_y < (xR_plus r0).1 y)})	                              (fun (x0 y : GenNo S) 	                                 (_ : x0 <= y)	                                 (z : {x_plus_y : No &	                                      (forall l : L,	                                       (xL_plus l).1 x0 < x_plus_y) *	                                      (forall r0 : R,	                                       x_plus_y < (xR_plus r0).1 x0)})	                                 (w : {x_plus_y : No &	                                      (forall l : L,	                                       (xL_plus l).1 y < x_plus_y) *	                                      (forall r0 : R,	                                       x_plus_y < (xR_plus r0).1 y)}) =>	                               z.1 <= w.1)	                              (fun (x0 y : GenNo S) 	                                 (_ : x0 < y)	                                 (z : {x_plus_y : No &	                                      (forall l : L,	                                       (xL_plus l).1 x0 < x_plus_y) *	                                      (forall r0 : R,	                                       x_plus_y < (xR_plus r0).1 x0)})	                                 (w : {x_plus_y : No &	                                      (forall l : L,	                                       (xL_plus l).1 y < x_plus_y) *	                                      (forall r0 : R,	                                       x_plus_y < (xR_plus r0).1 y)}) =>	                               z.1 < w.1)	                              (fun (L'0 R'0 : Type) 	                                 (s : InSort S L'0 R'0)	                                 (yL0 : L'0 -> GenNo S)	                                 (yR0 : R'0 -> GenNo S)	                                 (ycut0 : forall (l : L'0) 	                                          (r0 : R'0), 	                                          yL0 l < yR0 r0)	                                 (x_plus_yL : forall 	                                              l : L'0,	                                              {x_plus_y : No &	                                              (forall 	                                               l0 : L,	                                               (xL_plus l0).1 (yL0 l) <	                                               x_plus_y) *	                                              (forall 	                                               r0 : R,	                                               x_plus_y <	                                               (xR_plus r0).1 (yL0 l))})	                                 (x_plus_yR : forall 	                                              r0 : R'0,	                                              {x_plus_y : No &	                                              (forall 	                                               l : L,	                                               (xL_plus l).1 (yR0 r0) <	                                               x_plus_y) *	                                              (forall 	                                               r1 : R,	                                               x_plus_y <	                                               (xR_plus r1).1 (yR0 r0))})	                                 (x_plus_yL_lt_yR : 	                                  forall (l : L'0) 	                                  (r0 : R'0),	                                  (x_plus_yL l).1 < (x_plus_yR r0).1) =>	                               let L'' := L + L'0 in	                               let R'' := R + R'0 in	                               let zL :=	                                 sum_ind (fun _ : L + L'0 => No)	                                   (fun l : L =>	                                    (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	                                   (fun l : L'0 => (x_plus_yL l).1) in	                               let zR :=	                                 sum_ind (fun _ : R + R'0 => No)	                                   (fun r0 : R =>	                                    (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	                                   (fun r0 : R'0 => (x_plus_yR r0).1) in	                               let zcut :=	                                 plus_inner_subproof L'0 R'0 s yL0 yR0 ycut0	                                   x_plus_yL x_plus_yR x_plus_yL_lt_yR in	                               let X := sum_options L R L'0 R'0 Sx s in	                               ({{ zL | zR // zcut }};	                               (fun l : L => lt_lopt zL zR zcut (inl l),	                               fun r0 : R => lt_ropt zL zR zcut (inl r0))))	                              plus_inner_subproof0 plus_inner_subproof1	                              plus_inner_subproof2 plus_inner_subproof3	                              (game_of (yR r)) (isno_game_of (yR r))).1) x))	                    (plus_inner_subproof L' R' Sy	                       (fun l : L' =>	                        {|	                        game_of := game_of (yL l);	                        isno_game_of := isno_game_of (yL l) |})	                       (fun r : R' =>	                        {|	                        game_of := game_of (yR r);	                        isno_game_of := isno_game_of (yR r) |}) ycut	                       (fun l : L' =>	                        Core.Surreals.No_ind_internal	                          (fun y : GenNo S =>	                           {x_plus_y : No &	                           (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                           (forall r : R, x_plus_y < (xR_plus r).1 y)})	                          (fun (x y : GenNo S) (_ : x <= y)	                             (z : {x_plus_y : No &	                                  (forall l0 : L, (xL_plus l0).1 x < x_plus_y) *	                                  (forall r : R, x_plus_y < (xR_plus r).1 x)})	                             (w : {x_plus_y : No &	                                  (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                                  (forall r : R, x_plus_y < (xR_plus r).1 y)})	                           => z.1 <= w.1)	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : {x_plus_y : No &	                                  (forall l0 : L, (xL_plus l0).1 x < x_plus_y) *	                                  (forall r : R, x_plus_y < (xR_plus r).1 x)})	                             (w : {x_plus_y : No &	                                  (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                                  (forall r : R, x_plus_y < (xR_plus r).1 y)})	                           => z.1 < w.1)	                          (fun (L'0 R'0 : Type) (s : InSort S L'0 R'0)	                             (yL0 : L'0 -> GenNo S) 	                             (yR0 : R'0 -> GenNo S)	                             (ycut0 : forall (l0 : L'0) 	                                      (r : R'0), yL0 l0 < yR0 r)	                             (x_plus_yL : forall l0 : L'0,	                                          {x_plus_y : No &	                                          (forall 	                                           l1 : L,	                                           (xL_plus l1).1 (yL0 l0) < x_plus_y) *	                                          (forall 	                                           r : R,	                                           x_plus_y < (xR_plus r).1 (yL0 l0))})	                             (x_plus_yR : forall r : R'0,	                                          {x_plus_y : No &	                                          (forall 	                                           l0 : L,	                                           (xL_plus l0).1 (yR0 r) < x_plus_y) *	                                          (forall 	                                           r0 : R,	                                           x_plus_y < (xR_plus r0).1 (yR0 r))})	                             (x_plus_yL_lt_yR : forall 	                                                (l0 : L'0) 	                                                (r : R'0),	                                                (x_plus_yL l0).1 <	                                                (x_plus_yR r).1) =>	                           let L'' := L + L'0 in	                           let R'' := R + R'0 in	                           let zL :=	                             sum_ind (fun _ : L + L'0 => No)	                               (fun l0 : L =>	                                (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	                               (fun l0 : L'0 => (x_plus_yL l0).1) in	                           let zR :=	                             sum_ind (fun _ : R + R'0 => No)	                               (fun r : R =>	                                (xR_plus r).1 {{ yL0 | yR0 // ycut0 }})	                               (fun r : R'0 => (x_plus_yR r).1) in	                           let zcut :=	                             plus_inner_subproof L'0 R'0 s yL0 yR0 ycut0	                               x_plus_yL x_plus_yR x_plus_yL_lt_yR in	                           let X := sum_options L R L'0 R'0 Sx s in	                           ({{ zL | zR // zcut }};	                           (fun l0 : L => lt_lopt zL zR zcut (inl l0),	                           fun r : R => lt_ropt zL zR zcut (inl r))))	                          plus_inner_subproof0 plus_inner_subproof1	                          plus_inner_subproof2 plus_inner_subproof3	                          (game_of (yL l)) (isno_game_of (yL l)))	                       (fun r : R' =>	                        Core.Surreals.No_ind_internal	                          (fun y : GenNo S =>	                           {x_plus_y : No &	                           (forall l : L, (xL_plus l).1 y < x_plus_y) *	                           (forall r0 : R, x_plus_y < (xR_plus r0).1 y)})	                          (fun (x y : GenNo S) (_ : x <= y)	                             (z : {x_plus_y : No &	                                  (forall l : L, (xL_plus l).1 x < x_plus_y) *	                                  (forall r0 : R, x_plus_y < (xR_plus r0).1 x)})	                             (w : {x_plus_y : No &	                                  (forall l : L, (xL_plus l).1 y < x_plus_y) *	                                  (forall r0 : R, x_plus_y < (xR_plus r0).1 y)})	                           => z.1 <= w.1)	                          (fun (x y : GenNo S) (_ : x < y)	                             (z : {x_plus_y : No &	                                  (forall l : L, (xL_plus l).1 x < x_plus_y) *	                                  (forall r0 : R, x_plus_y < (xR_plus r0).1 x)})	                             (w : {x_plus_y : No &	                                  (forall l : L, (xL_plus l).1 y < x_plus_y) *	                                  (forall r0 : R, x_plus_y < (xR_plus r0).1 y)})	                           => z.1 < w.1)	                          (fun (L'0 R'0 : Type) (s : InSort S L'0 R'0)	                             (yL0 : L'0 -> GenNo S) 	                             (yR0 : R'0 -> GenNo S)	                             (ycut0 : forall (l : L'0) 	                                      (r0 : R'0), 	                                      yL0 l < yR0 r0)	                             (x_plus_yL : forall l : L'0,	                                          {x_plus_y : No &	                                          (forall 	                                           l0 : L,	                                           (xL_plus l0).1 (yL0 l) < x_plus_y) *	                                          (forall 	                                           r0 : R,	                                           x_plus_y < (xR_plus r0).1 (yL0 l))})	                             (x_plus_yR : forall r0 : R'0,	                                          {x_plus_y : No &	                                          (forall 	                                           l : L,	                                           (xL_plus l).1 (yR0 r0) < x_plus_y) *	                                          (forall 	                                           r1 : R,	                                           x_plus_y < (xR_plus r1).1 (yR0 r0))})	                             (x_plus_yL_lt_yR : forall 	                                                (l : L'0) 	                                                (r0 : R'0),	                                                (x_plus_yL l).1 <	                                                (x_plus_yR r0).1) =>	                           let L'' := L + L'0 in	                           let R'' := R + R'0 in	                           let zL :=	                             sum_ind (fun _ : L + L'0 => No)	                               (fun l : L =>	                                (xL_plus l).1 {{ yL0 | yR0 // ycut0 }})	                               (fun l : L'0 => (x_plus_yL l).1) in	                           let zR :=	                             sum_ind (fun _ : R + R'0 => No)	                               (fun r0 : R =>	                                (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	                               (fun r0 : R'0 => (x_plus_yR r0).1) in	                           let zcut :=	                             plus_inner_subproof L'0 R'0 s yL0 yR0 ycut0	                               x_plus_yL x_plus_yR x_plus_yL_lt_yR in	                           let X := sum_options L R L'0 R'0 Sx s in	                           ({{ zL | zR // zcut }};	                           (fun l : L => lt_lopt zL zR zcut (inl l),	                           fun r0 : R => lt_ropt zL zR zcut (inl r0))))	                          plus_inner_subproof0 plus_inner_subproof1	                          plus_inner_subproof2 plus_inner_subproof3	                          (game_of (yR r)) (isno_game_of (yR r)))	                       (fun (l : L') (r : R') =>	                        match	                          No_Empty_admitted	                          return	                            ((Core.Surreals.No_ind_internal	                                (fun y : GenNo S =>	                                 {x_plus_y : No &	                                 (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                                 (forall r0 : R, x_plus_y < (xR_plus r0).1 y)})	                                (fun (x0 y : GenNo S) 	                                   (_ : x0 <= y)	                                   (z : {x_plus_y : No &	                                        (forall l0 : L,	                                         (xL_plus l0).1 x0 < x_plus_y) *	                                        (forall r0 : R,	                                         x_plus_y < (xR_plus r0).1 x0)})	                                   (w : {x_plus_y : No &	                                        (forall l0 : L,	                                         (xL_plus l0).1 y < x_plus_y) *	                                        (forall r0 : R,	                                         x_plus_y < (xR_plus r0).1 y)}) =>	                                 z.1 <= w.1)	                                (fun (x0 y : GenNo S) 	                                   (_ : x0 < y)	                                   (z : {x_plus_y : No &	                                        (forall l0 : L,	                                         (xL_plus l0).1 x0 < x_plus_y) *	                                        (forall r0 : R,	                                         x_plus_y < (xR_plus r0).1 x0)})	                                   (w : {x_plus_y : No &	                                        (forall l0 : L,	                                         (xL_plus l0).1 y < x_plus_y) *	                                        (forall r0 : R,	                                         x_plus_y < (xR_plus r0).1 y)}) =>	                                 z.1 < w.1)	                                (fun (L'0 R'0 : Type) 	                                   (s : InSort S L'0 R'0)	                                   (yL0 : L'0 -> GenNo S)	                                   (yR0 : R'0 -> GenNo S)	                                   (ycut0 : forall 	                                            (l0 : L'0) 	                                            (r0 : R'0), 	                                            yL0 l0 < yR0 r0)	                                   (x_plus_yL : forall 	                                                l0 : L'0,	                                                {x_plus_y : No &	                                                (forall 	                                                 l1 : L,	                                                 (xL_plus l1).1 (yL0 l0) <	                                                 x_plus_y) *	                                                (forall 	                                                 r0 : R,	                                                 x_plus_y <	                                                 (xR_plus r0).1 (yL0 l0))})	                                   (x_plus_yR : forall 	                                                r0 : R'0,	                                                {x_plus_y : No &	                                                (forall 	                                                 l0 : L,	                                                 (xL_plus l0).1 (yR0 r0) <	                                                 x_plus_y) *	                                                (forall 	                                                 r1 : R,	                                                 x_plus_y <	                                                 (xR_plus r1).1 (yR0 r0))})	                                   (x_plus_yL_lt_yR : 	                                    forall (l0 : L'0) 	                                    (r0 : R'0),	                                    (x_plus_yL l0).1 < (x_plus_yR r0).1) =>	                                 let L'' := L + L'0 in	                                 let R'' := R + R'0 in	                                 let zL :=	                                   sum_ind (fun _ : L + L'0 => No)	                                     (fun l0 : L =>	                                      (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	                                     (fun l0 : L'0 => (x_plus_yL l0).1) in	                                 let zR :=	                                   sum_ind (fun _ : R + R'0 => No)	                                     (fun r0 : R =>	                                      (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	                                     (fun r0 : R'0 => (x_plus_yR r0).1) in	                                 let zcut :=	                                   plus_inner_subproof L'0 R'0 s yL0 yR0	                                     ycut0 x_plus_yL x_plus_yR	                                     x_plus_yL_lt_yR in	                                 let X := sum_options L R L'0 R'0 Sx s in	                                 ({{ zL | zR // zcut }};	                                 (fun l0 : L => lt_lopt zL zR zcut (inl l0),	                                 fun r0 : R => lt_ropt zL zR zcut (inl r0))))	                                plus_inner_subproof0 plus_inner_subproof1	                                plus_inner_subproof2 plus_inner_subproof3	                                (game_of (yL l)) (isno_game_of (yL l))).1 <	                             (Core.Surreals.No_ind_internal	                                (fun y : GenNo S =>	                                 {x_plus_y : No &	                                 (forall l0 : L, (xL_plus l0).1 y < x_plus_y) *	                                 (forall r0 : R, x_plus_y < (xR_plus r0).1 y)})	                                (fun (x0 y : GenNo S) 	                                   (_ : x0 <= y)	                                   (z : {x_plus_y : No &	                                        (forall l0 : L,	                                         (xL_plus l0).1 x0 < x_plus_y) *	                                        (forall r0 : R,	                                         x_plus_y < (xR_plus r0).1 x0)})	                                   (w : {x_plus_y : No &	                                        (forall l0 : L,	                                         (xL_plus l0).1 y < x_plus_y) *	                                        (forall r0 : R,	                                         x_plus_y < (xR_plus r0).1 y)}) =>	                                 z.1 <= w.1)	                                (fun (x0 y : GenNo S) 	                                   (_ : x0 < y)	                                   (z : {x_plus_y : No &	                                        (forall l0 : L,	                                         (xL_plus l0).1 x0 < x_plus_y) *	                                        (forall r0 : R,	                                         x_plus_y < (xR_plus r0).1 x0)})	                                   (w : {x_plus_y : No &	                                        (forall l0 : L,	                                         (xL_plus l0).1 y < x_plus_y) *	                                        (forall r0 : R,	                                         x_plus_y < (xR_plus r0).1 y)}) =>	                                 z.1 < w.1)	                                (fun (L'0 R'0 : Type) 	                                   (s : InSort S L'0 R'0)	                                   (yL0 : L'0 -> GenNo S)	                                   (yR0 : R'0 -> GenNo S)	                                   (ycut0 : forall 	                                            (l0 : L'0) 	                                            (r0 : R'0), 	                                            yL0 l0 < yR0 r0)	                                   (x_plus_yL : forall 	                                                l0 : L'0,	                                                {x_plus_y : No &	                                                (forall 	                                                 l1 : L,	                                                 (xL_plus l1).1 (yL0 l0) <	                                                 x_plus_y) *	                                                (forall 	                                                 r0 : R,	                                                 x_plus_y <	                                                 (xR_plus r0).1 (yL0 l0))})	                                   (x_plus_yR : forall 	                                                r0 : R'0,	                                                {x_plus_y : No &	                                                (forall 	                                                 l0 : L,	                                                 (xL_plus l0).1 (yR0 r0) <	                                                 x_plus_y) *	                                                (forall 	                                                 r1 : R,	                                                 x_plus_y <	                                                 (xR_plus r1).1 (yR0 r0))})	                                   (x_plus_yL_lt_yR : 	                                    forall (l0 : L'0) 	                                    (r0 : R'0),	                                    (x_plus_yL l0).1 < (x_plus_yR r0).1) =>	                                 let L'' := L + L'0 in	                                 let R'' := R + R'0 in	                                 let zL :=	                                   sum_ind (fun _ : L + L'0 => No)	                                     (fun l0 : L =>	                                      (xL_plus l0).1 {{ yL0 | yR0 // ycut0 }})	                                     (fun l0 : L'0 => (x_plus_yL l0).1) in	                                 let zR :=	                                   sum_ind (fun _ : R + R'0 => No)	                                     (fun r0 : R =>	                                      (xR_plus r0).1 {{ yL0 | yR0 // ycut0 }})	                                     (fun r0 : R'0 => (x_plus_yR r0).1) in	                                 let zcut :=	                                   plus_inner_subproof L'0 R'0 s yL0 yR0	                                     ycut0 x_plus_yL x_plus_yR	                                     x_plus_yL_lt_yR in	                                 let X := sum_options L R L'0 R'0 Sx s in	                                 ({{ zL | zR // zcut }};	                                 (fun l0 : L => lt_lopt zL zR zcut (inl l0),	                                 fun r0 : R => lt_ropt zL zR zcut (inl r0))))	                                plus_inner_subproof0 plus_inner_subproof1	                                plus_inner_subproof2 plus_inner_subproof3	                                (game_of (yR r)) (isno_game_of (yR r))).1)	                        with	                        end)) |} =	  {|	  game_of := opt (L + L') (R + R') (sum_options L R L' R' Sx Sy)	               (fun x : L + L' =>	                game_of	                  (sum_ind (fun _ : L + L' => No)	                     (fun l : L => (xL_plus l).1 {{ yL | yR // ycut }})	                     (fun l : L' => (plus_inner.1 (yL l)).1) x))	               (fun x : R + R' =>	                game_of	                  (sum_ind (fun _ : R + R' => No)	                     (fun r : R => (xR_plus r).1 {{ yL | yR // ycut }})	                     (fun r : R' => (plus_inner.1 (yR r)).1) x));	  isno_game_of := isno (L + L') (R + R') (sum_options L R L' R' Sx Sy)	                    (fun x : L + L' =>	                     game_of	                       (sum_ind (fun _ : L + L' => No)	                          (fun l : L => (xL_plus l).1 {{ yL | yR // ycut }})	                          (fun l : L' => (plus_inner.1 (yL l)).1) x))	                    (fun x : R + R' =>	                     game_of	                       (sum_ind (fun _ : R + R' => No)	                          (fun r : R => (xR_plus r).1 {{ yL | yR // ycut }})	                          (fun r : R' => (plus_inner.1 (yR r)).1) x))	                    (fun x : L + L' =>	                     isno_game_of	                       (sum_ind (fun _ : L + L' => No)	                          (fun l : L => (xL_plus l).1 {{ yL | yR // ycut }})	                          (fun l : L' => (plus_inner.1 (yL l)).1) x))	                    (fun x : R + R' =>	                     isno_game_of	                       (sum_ind (fun _ : R + R' => No)	                          (fun r : R => (xR_plus r).1 {{ yL | yR // ycut }})	                          (fun r : R' => (plus_inner.1 (yR r)).1) x)) 	                    ?zcut |}	No more subgoals.	";
            responses[i]=data;
          

            i = 84;
            data = "";
            responses[i]=data;
          

            i = 85;
            data = "";
            responses[i]=data;
          

            i = 86;
            data = "1 subgoal (ID 51)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  ============================	  {f	  : No ->	    {g : No -> No &	    (forall x y : GenNo S, x <= y -> g x <= g y) *	    (forall x y : GenNo S, x < y -> g x < g y)} &	  (forall x y : GenNo S, x <= y -> forall z : No, (f x).1 z <= (f y).1 z) *	  (forall x y : GenNo S, x < y -> forall z : No, (f x).1 z < (f y).1 z)}	";
            responses[i]=data;
          

            i = 87;
            data = "";
            responses[i]=data;
          

            i = 88;
            data = "4 subgoals (ID 203)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  ============================	  forall	  a	   b : {g : No -> No &	       (forall x y : GenNo S, x <= y -> g x <= g y) *	       (forall x y : GenNo S, x < y -> g x < g y)},	  (forall x : No, a.1 x <= b.1 x) -> (forall x : No, b.1 x <= a.1 x) -> a = b		subgoal 2 (ID 205) is:	 forall (L R : Type) (s : InSort S L R) (xL : L -> GenNo S)	 (xR : R -> GenNo S) (xcut : forall (l : L) (r : R), xL l < xR r)	 (fxL : L ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxR : R ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxcut : forall (l : L) (r : R) (x : No), (fxL l).1 x < (fxR r).1 x)	 (L' R' : Type) (s' : InSort S L' R') (yL : L' -> GenNo S)	 (yR : R' -> GenNo S) (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : L' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fyR : R' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fycut : forall (l : L') (r : R') (x : No), (fyL l).1 x < (fyR r).1 x),	 (forall l : L, xL l < {{ yL | yR // ycut }}) ->	 (forall (l : L) (x : No),	  (fxL l).1 x <	  (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x) ->	 (forall r : R', {{ xL | xR // xcut }} < yR r) ->	 (forall (r : R') (x : No),	  (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <	  (fyR r).1 x) ->	 forall x : No,	 (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <=	 (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x	subgoal 3 (ID 207) is:	 forall (L R : Type) (s : InSort S L R) (xL : L -> GenNo S)	 (xR : R -> GenNo S) (xcut : forall (l : L) (r : R), xL l < xR r)	 (fxL : L ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxR : R ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxcut : forall (l : L) (r : R) (x : No), (fxL l).1 x < (fxR r).1 x)	 (L' R' : Type) (s' : InSort S L' R') (yL : L' -> GenNo S)	 (yR : R' -> GenNo S),	 (forall (l : L') (r : R'), yL l < yR r) ->	 forall	 (fyL : L' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fyR : R' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fycut : forall (l : L') (r : R') (x : No), (fyL l).1 x < (fyR r).1 x)	 (l : L'),	 {{ xL | xR // xcut }} <= yL l ->	 (forall x : No,	  (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <=	  (fyL l).1 x) ->	 forall x : No,	 (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <	 (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x	subgoal 4 (ID 209) is:	 forall (L R : Type) (s : InSort S L R) (xL : L -> GenNo S)	 (xR : R -> GenNo S),	 (forall (l : L) (r : R), xL l < xR r) ->	 forall	 (fxL : L ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxR : R ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxcut : forall (l : L) (r : R) (x : No), (fxL l).1 x < (fxR r).1 x)	 (L' R' : Type) (s' : InSort S L' R') (yL : L' -> GenNo S)	 (yR : R' -> GenNo S) (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : L' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fyR : R' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fycut : forall (l : L') (r : R') (x : No), (fyL l).1 x < (fyR r).1 x)	 (r : R),	 xR r <= {{ yL | yR // ycut }} ->	 (forall x : No,	  (fxR r).1 x <=	  (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x) ->	 forall x : No,	 (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <	 (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x	";
            responses[i]=data;
          

            i = 89;
            data = "1 subgoal (ID 203)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  ============================	  forall	  a	   b : {g : No -> No &	       (forall x y : GenNo S, x <= y -> g x <= g y) *	       (forall x y : GenNo S, x < y -> g x < g y)},	  (forall x : No, a.1 x <= b.1 x) -> (forall x : No, b.1 x <= a.1 x) -> a = b	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	3 subgoals (ID 205)		subgoal 1 (ID 205) is:	 forall (L R : Type) (s : InSort S L R) (xL : L -> GenNo S)	 (xR : R -> GenNo S) (xcut : forall (l : L) (r : R), xL l < xR r)	 (fxL : L ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxR : R ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxcut : forall (l : L) (r : R) (x : No), (fxL l).1 x < (fxR r).1 x)	 (L' R' : Type) (s' : InSort S L' R') (yL : L' -> GenNo S)	 (yR : R' -> GenNo S) (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : L' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fyR : R' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fycut : forall (l : L') (r : R') (x : No), (fyL l).1 x < (fyR r).1 x),	 (forall l : L, xL l < {{ yL | yR // ycut }}) ->	 (forall (l : L) (x : No),	  (fxL l).1 x <	  (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x) ->	 (forall r : R', {{ xL | xR // xcut }} < yR r) ->	 (forall (r : R') (x : No),	  (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <	  (fyR r).1 x) ->	 forall x : No,	 (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <=	 (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x	subgoal 2 (ID 207) is:	 forall (L R : Type) (s : InSort S L R) (xL : L -> GenNo S)	 (xR : R -> GenNo S) (xcut : forall (l : L) (r : R), xL l < xR r)	 (fxL : L ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxR : R ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxcut : forall (l : L) (r : R) (x : No), (fxL l).1 x < (fxR r).1 x)	 (L' R' : Type) (s' : InSort S L' R') (yL : L' -> GenNo S)	 (yR : R' -> GenNo S),	 (forall (l : L') (r : R'), yL l < yR r) ->	 forall	 (fyL : L' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fyR : R' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fycut : forall (l : L') (r : R') (x : No), (fyL l).1 x < (fyR r).1 x)	 (l : L'),	 {{ xL | xR // xcut }} <= yL l ->	 (forall x : No,	  (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <=	  (fyL l).1 x) ->	 forall x : No,	 (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <	 (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x	subgoal 3 (ID 209) is:	 forall (L R : Type) (s : InSort S L R) (xL : L -> GenNo S)	 (xR : R -> GenNo S),	 (forall (l : L) (r : R), xL l < xR r) ->	 forall	 (fxL : L ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxR : R ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxcut : forall (l : L) (r : R) (x : No), (fxL l).1 x < (fxR r).1 x)	 (L' R' : Type) (s' : InSort S L' R') (yL : L' -> GenNo S)	 (yR : R' -> GenNo S) (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : L' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fyR : R' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fycut : forall (l : L') (r : R') (x : No), (fyL l).1 x < (fyR r).1 x)	 (r : R),	 xR r <= {{ yL | yR // ycut }} ->	 (forall x : No,	  (fxR r).1 x <=	  (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x) ->	 forall x : No,	 (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <	 (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x	";
            responses[i]=data;
          

            i = 90;
            data = "";
            responses[i]=data;
          

            i = 91;
            data = "";
            responses[i]=data;
          

            i = 92;
            data = "";
            responses[i]=data;
          

            i = 93;
            data = "";
            responses[i]=data;
          

            i = 94;
            data = "";
            responses[i]=data;
          

            i = 95;
            data = "";
            responses[i]=data;
          

            i = 96;
            data = "";
            responses[i]=data;
          

            i = 97;
            data = "";
            responses[i]=data;
          

            i = 98;
            data = "";
            responses[i]=data;
          

            i = 99;
            data = "";
            responses[i]=data;
          

            i = 100;
            data = "";
            responses[i]=data;
          

            i = 101;
            data = "";
            responses[i]=data;
          

            i = 102;
            data = "";
            responses[i]=data;
          

            i = 103;
            data = "";
            responses[i]=data;
          

            i = 104;
            data = "";
            responses[i]=data;
          

            i = 105;
            data = "";
            responses[i]=data;
          

            i = 106;
            data = "1 subgoal (ID 205)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  ============================	  forall (L R : Type) (s : InSort S L R) (xL : L -> GenNo S)	  (xR : R -> GenNo S) (xcut : forall (l : L) (r : R), xL l < xR r)	  (fxL : L ->	         {g : No -> No &	         (forall x y : GenNo S, x <= y -> g x <= g y) *	         (forall x y : GenNo S, x < y -> g x < g y)})	  (fxR : R ->	         {g : No -> No &	         (forall x y : GenNo S, x <= y -> g x <= g y) *	         (forall x y : GenNo S, x < y -> g x < g y)})	  (fxcut : forall (l : L) (r : R) (x : No), (fxL l).1 x < (fxR r).1 x)	  (L' R' : Type) (s' : InSort S L' R') (yL : L' -> GenNo S)	  (yR : R' -> GenNo S) (ycut : forall (l : L') (r : R'), yL l < yR r)	  (fyL : L' ->	         {g : No -> No &	         (forall x y : GenNo S, x <= y -> g x <= g y) *	         (forall x y : GenNo S, x < y -> g x < g y)})	  (fyR : R' ->	         {g : No -> No &	         (forall x y : GenNo S, x <= y -> g x <= g y) *	         (forall x y : GenNo S, x < y -> g x < g y)})	  (fycut : forall (l : L') (r : R') (x : No), (fyL l).1 x < (fyR r).1 x),	  (forall l : L, xL l < {{ yL | yR // ycut }}) ->	  (forall (l : L) (x : No),	   (fxL l).1 x <	   (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x) ->	  (forall r : R', {{ xL | xR // xcut }} < yR r) ->	  (forall (r : R') (x : No),	   (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <	   (fyR r).1 x) ->	  forall x : No,	  (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <=	  (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x	";
            responses[i]=data;
          

            i = 107;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	2 subgoals (ID 207)		subgoal 1 (ID 207) is:	 forall (L R : Type) (s : InSort S L R) (xL : L -> GenNo S)	 (xR : R -> GenNo S) (xcut : forall (l : L) (r : R), xL l < xR r)	 (fxL : L ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxR : R ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxcut : forall (l : L) (r : R) (x : No), (fxL l).1 x < (fxR r).1 x)	 (L' R' : Type) (s' : InSort S L' R') (yL : L' -> GenNo S)	 (yR : R' -> GenNo S),	 (forall (l : L') (r : R'), yL l < yR r) ->	 forall	 (fyL : L' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fyR : R' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fycut : forall (l : L') (r : R') (x : No), (fyL l).1 x < (fyR r).1 x)	 (l : L'),	 {{ xL | xR // xcut }} <= yL l ->	 (forall x : No,	  (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <=	  (fyL l).1 x) ->	 forall x : No,	 (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <	 (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x	subgoal 2 (ID 209) is:	 forall (L R : Type) (s : InSort S L R) (xL : L -> GenNo S)	 (xR : R -> GenNo S),	 (forall (l : L) (r : R), xL l < xR r) ->	 forall	 (fxL : L ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxR : R ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxcut : forall (l : L) (r : R) (x : No), (fxL l).1 x < (fxR r).1 x)	 (L' R' : Type) (s' : InSort S L' R') (yL : L' -> GenNo S)	 (yR : R' -> GenNo S) (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : L' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fyR : R' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fycut : forall (l : L') (r : R') (x : No), (fyL l).1 x < (fyR r).1 x)	 (r : R),	 xR r <= {{ yL | yR // ycut }} ->	 (forall x : No,	  (fxR r).1 x <=	  (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x) ->	 forall x : No,	 (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <	 (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x	1 subgoal (ID 207)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  ============================	  forall (L R : Type) (s : InSort S L R) (xL : L -> GenNo S)	  (xR : R -> GenNo S) (xcut : forall (l : L) (r : R), xL l < xR r)	  (fxL : L ->	         {g : No -> No &	         (forall x y : GenNo S, x <= y -> g x <= g y) *	         (forall x y : GenNo S, x < y -> g x < g y)})	  (fxR : R ->	         {g : No -> No &	         (forall x y : GenNo S, x <= y -> g x <= g y) *	         (forall x y : GenNo S, x < y -> g x < g y)})	  (fxcut : forall (l : L) (r : R) (x : No), (fxL l).1 x < (fxR r).1 x)	  (L' R' : Type) (s' : InSort S L' R') (yL : L' -> GenNo S)	  (yR : R' -> GenNo S),	  (forall (l : L') (r : R'), yL l < yR r) ->	  forall	  (fyL : L' ->	         {g : No -> No &	         (forall x y : GenNo S, x <= y -> g x <= g y) *	         (forall x y : GenNo S, x < y -> g x < g y)})	  (fyR : R' ->	         {g : No -> No &	         (forall x y : GenNo S, x <= y -> g x <= g y) *	         (forall x y : GenNo S, x < y -> g x < g y)})	  (fycut : forall (l : L') (r : R') (x : No), (fyL l).1 x < (fyR r).1 x)	  (l : L'),	  {{ xL | xR // xcut }} <= yL l ->	  (forall x : No,	   (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <=	   (fyL l).1 x) ->	  forall x : No,	  (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <	  (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 209)		subgoal 1 (ID 209) is:	 forall (L R : Type) (s : InSort S L R) (xL : L -> GenNo S)	 (xR : R -> GenNo S),	 (forall (l : L) (r : R), xL l < xR r) ->	 forall	 (fxL : L ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxR : R ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fxcut : forall (l : L) (r : R) (x : No), (fxL l).1 x < (fxR r).1 x)	 (L' R' : Type) (s' : InSort S L' R') (yL : L' -> GenNo S)	 (yR : R' -> GenNo S) (ycut : forall (l : L') (r : R'), yL l < yR r)	 (fyL : L' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fyR : R' ->	        {g : No -> No &	        (forall x y : GenNo S, x <= y -> g x <= g y) *	        (forall x y : GenNo S, x < y -> g x < g y)})	 (fycut : forall (l : L') (r : R') (x : No), (fyL l).1 x < (fyR r).1 x)	 (r : R),	 xR r <= {{ yL | yR // ycut }} ->	 (forall x : No,	  (fxR r).1 x <=	  (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x) ->	 forall x : No,	 (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <	 (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x	";
            responses[i]=data;
          

            i = 108;
            data = "1 subgoal (ID 209)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  ============================	  forall (L R : Type) (s : InSort S L R) (xL : L -> GenNo S)	  (xR : R -> GenNo S),	  (forall (l : L) (r : R), xL l < xR r) ->	  forall	  (fxL : L ->	         {g : No -> No &	         (forall x y : GenNo S, x <= y -> g x <= g y) *	         (forall x y : GenNo S, x < y -> g x < g y)})	  (fxR : R ->	         {g : No -> No &	         (forall x y : GenNo S, x <= y -> g x <= g y) *	         (forall x y : GenNo S, x < y -> g x < g y)})	  (fxcut : forall (l : L) (r : R) (x : No), (fxL l).1 x < (fxR r).1 x)	  (L' R' : Type) (s' : InSort S L' R') (yL : L' -> GenNo S)	  (yR : R' -> GenNo S) (ycut : forall (l : L') (r : R'), yL l < yR r)	  (fyL : L' ->	         {g : No -> No &	         (forall x y : GenNo S, x <= y -> g x <= g y) *	         (forall x y : GenNo S, x < y -> g x < g y)})	  (fyR : R' ->	         {g : No -> No &	         (forall x y : GenNo S, x <= y -> g x <= g y) *	         (forall x y : GenNo S, x < y -> g x < g y)})	  (fycut : forall (l : L') (r : R') (x : No), (fyL l).1 x < (fyR r).1 x)	  (r : R),	  xR r <= {{ yL | yR // ycut }} ->	  (forall x : No,	   (fxR r).1 x <=	   (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x) ->	  forall x : No,	  (let g := plus_inner fxL fxR fxcut in (fun y : No => (g.1 y).1; g.2)).1 x <	  (let g := plus_inner fyL fyR fycut in (fun y : No => (g.1 y).1; g.2)).1 x	";
            responses[i]=data;
          

            i = 109;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 110;
            data = "<infomsg>plus is defined</infomsg>	";
            responses[i]=data;
          

            i = 111;
            data = "";
            responses[i]=data;
          

            i = 112;
            data = "<infomsg>plus_le_l is defined</infomsg>	";
            responses[i]=data;
          

            i = 113;
            data = "<infomsg>plus_lt_l is defined</infomsg>	";
            responses[i]=data;
          

            i = 114;
            data = "<infomsg>plus_le_r is defined</infomsg>	";
            responses[i]=data;
          

            i = 115;
            data = "<infomsg>plus_lt_r is defined</infomsg>	";
            responses[i]=data;
          

            i = 116;
            data = "";
            responses[i]=data;
          

            i = 117;
            data = "";
            responses[i]=data;
          

            i = 118;
            data = "";
            responses[i]=data;
          

            i = 119;
            data = "";
            responses[i]=data;
          

            i = 120;
            data = "";
            responses[i]=data;
          

            i = 121;
            data = "";
            responses[i]=data;
          

            i = 122;
            data = "";
            responses[i]=data;
          

            i = 123;
            data = "";
            responses[i]=data;
          

            i = 124;
            data = "";
            responses[i]=data;
          

            i = 125;
            data = "";
            responses[i]=data;
          

            i = 126;
            data = "";
            responses[i]=data;
          

            i = 127;
            data = "";
            responses[i]=data;
          

            i = 128;
            data = "";
            responses[i]=data;
          

            i = 129;
            data = "";
            responses[i]=data;
          

            i = 130;
            data = "";
            responses[i]=data;
          

            i = 131;
            data = "";
            responses[i]=data;
          

            i = 132;
            data = "";
            responses[i]=data;
          

            i = 133;
            data = "";
            responses[i]=data;
          

            i = 134;
            data = "";
            responses[i]=data;
          

            i = 135;
            data = "";
            responses[i]=data;
          

            i = 136;
            data = "<infomsg>plus_cut is defined</infomsg>	<infomsg>do_plus_cut is defined</infomsg>	";
            responses[i]=data;
          

            i = 137;
            data = "";
            responses[i]=data;
          

            i = 138;
            data = "";
            responses[i]=data;
          

            i = 139;
            data = "";
            responses[i]=data;
          

            i = 140;
            data = "";
            responses[i]=data;
          

            i = 141;
            data = "1 subgoal (ID 140)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  x, y : No	  ============================	  x + y = y + x	";
            responses[i]=data;
          

            i = 142;
            data = "";
            responses[i]=data;
          

            i = 143;
            data = "";
            responses[i]=data;
          

            i = 144;
            data = "";
            responses[i]=data;
          

            i = 145;
            data = "No more subgoals.	1 subgoal (ID 146)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  x, y, z : No	  ============================	  x + y + z = x + (y + z)	";
            responses[i]=data;
          

            i = 146;
            data = "";
            responses[i]=data;
          

            i = 147;
            data = "";
            responses[i]=data;
          

            i = 148;
            data = "";
            responses[i]=data;
          

            i = 149;
            data = "";
            responses[i]=data;
          

            i = 150;
            data = "";
            responses[i]=data;
          

            i = 151;
            data = "";
            responses[i]=data;
          

            i = 152;
            data = "";
            responses[i]=data;
          

            i = 153;
            data = "";
            responses[i]=data;
          

            i = 154;
            data = "";
            responses[i]=data;
          

            i = 155;
            data = "";
            responses[i]=data;
          

            i = 156;
            data = "";
            responses[i]=data;
          

            i = 157;
            data = "";
            responses[i]=data;
          

            i = 158;
            data = "";
            responses[i]=data;
          

            i = 159;
            data = "";
            responses[i]=data;
          

            i = 160;
            data = "";
            responses[i]=data;
          

            i = 161;
            data = "";
            responses[i]=data;
          

            i = 162;
            data = "";
            responses[i]=data;
          

            i = 163;
            data = "";
            responses[i]=data;
          

            i = 164;
            data = "";
            responses[i]=data;
          

            i = 165;
            data = "";
            responses[i]=data;
          

            i = 166;
            data = "";
            responses[i]=data;
          

            i = 167;
            data = "";
            responses[i]=data;
          

            i = 168;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 169;
            data = "1 subgoal (ID 155)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  x : No	  ============================	  x + zero = x	1 subgoal (ID 157)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  x : No	  ============================	  x + {{ Empty_rec | Empty_rec // lempty_cut }} = x	No more subgoals.	1 subgoal (ID 164)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  x : No	  ============================	  zero + x = x	1 subgoal (ID 166)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  x : No	  ============================	  {{ Empty_rec | Empty_rec // lempty_cut }} + x = x	No more subgoals.	<infomsg>H1 is declared</infomsg>	1 subgoal (ID 175)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  H1 : HasNegation S	  x : No	  ============================	  x + negate x = zero	1 subgoal (ID 259)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  H1 : HasNegation S	  L : Type	  R : Type	  s : InSort S L R	  xL : L -> GenNo S	  xR : R -> GenNo S	  xcut : forall (l : L) (r : R), xL l < xR r	  IHL : forall l : L, xL l + negate (xL l) = zero	  IHR : forall r : R, xR r + negate (xR r) = zero	  nxcut : forall (r : R) (l : L), negate (xR r) < negate (xL l)	  cut : forall (l : L + R) (r : R + L),	        sum_ind (fun _ : L + R => No)	          (fun l0 : L =>	           xL l0 +	           {{ fun r0 : R => negate (xR r0) | (fun l1 : L => negate (xL l1)) // nxcut }})	          (fun l0 : R => {{ xL | xR // xcut }} + negate (xR l0)) l <	        sum_ind (fun _ : R + L => No)	          (fun r0 : R =>	           xR r0 +	           {{ fun r1 : R => negate (xR r1) | (fun l0 : L => negate (xL l0)) // nxcut }})	          (fun r0 : L => {{ xL | xR // xcut }} + negate (xL r0)) r	  ============================	  {{ sum_ind (fun _ : L + R => No)	       (fun l : L =>	        xL l +	        {{ fun r : R => negate (xR r) | (fun l0 : L => negate (xL l0)) // nxcut }})	       (fun l : R => {{ xL | xR // xcut }} + negate (xR l)) | 	  sum_ind (fun _ : R + L => No)	    (fun r : R =>	     xR r +	     {{ fun r0 : R => negate (xR r0) | (fun l : L => negate (xL l)) // nxcut }})	    (fun r : L => {{ xL | xR // xcut }} + negate (xL r)) // cut }} = zero	2 subgoals (ID 261)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  H1 : HasNegation S	  L : Type	  R : Type	  s : InSort S L R	  xL : L -> GenNo S	  xR : R -> GenNo S	  xcut : forall (l : L) (r : R), xL l < xR r	  IHL : forall l : L, xL l + negate (xL l) = zero	  IHR : forall r : R, xR r + negate (xR r) = zero	  nxcut : forall (r : R) (l : L), negate (xR r) < negate (xL l)	  cut : forall (l : L + R) (r : R + L),	        sum_ind (fun _ : L + R => No)	          (fun l0 : L =>	           xL l0 +	           {{ fun r0 : R => negate (xR r0) | (fun l1 : L => negate (xL l1)) // nxcut }})	          (fun l0 : R => {{ xL | xR // xcut }} + negate (xR l0)) l <	        sum_ind (fun _ : R + L => No)	          (fun r0 : R =>	           xR r0 +	           {{ fun r1 : R => negate (xR r1) | (fun l0 : L => negate (xL l0)) // nxcut }})	          (fun r0 : L => {{ xL | xR // xcut }} + negate (xL r0)) r	  ============================	  {{ sum_ind (fun _ : L + R => No)	       (fun l : L =>	        xL l +	        {{ fun r : R => negate (xR r) | (fun l0 : L => negate (xL l0)) // nxcut }})	       (fun l : R => {{ xL | xR // xcut }} + negate (xR l)) | 	  sum_ind (fun _ : R + L => No)	    (fun r : R =>	     xR r +	     {{ fun r0 : R => negate (xR r0) | (fun l : L => negate (xL l)) // nxcut }})	    (fun r : L => {{ xL | xR // xcut }} + negate (xL r)) // cut }} <= zero		subgoal 2 (ID 262) is:	 zero <=	 {{ sum_ind (fun _ : L + R => No)	      (fun l : L =>	       xL l +	       {{ fun r : R => negate (xR r) | (fun l0 : L => negate (xL l0)) // nxcut }})	      (fun l : R => {{ xL | xR // xcut }} + negate (xR l)) | 	 sum_ind (fun _ : R + L => No)	   (fun r : R =>	    xR r +	    {{ fun r0 : R => negate (xR r0) | (fun l : L => negate (xL l)) // nxcut }})	   (fun r : L => {{ xL | xR // xcut }} + negate (xL r)) // cut }}	1 subgoal (ID 261)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  H1 : HasNegation S	  L : Type	  R : Type	  s : InSort S L R	  xL : L -> GenNo S	  xR : R -> GenNo S	  xcut : forall (l : L) (r : R), xL l < xR r	  IHL : forall l : L, xL l + negate (xL l) = zero	  IHR : forall r : R, xR r + negate (xR r) = zero	  nxcut : forall (r : R) (l : L), negate (xR r) < negate (xL l)	  cut : forall (l : L + R) (r : R + L),	        sum_ind (fun _ : L + R => No)	          (fun l0 : L =>	           xL l0 +	           {{ fun r0 : R => negate (xR r0) | (fun l1 : L => negate (xL l1)) // nxcut }})	          (fun l0 : R => {{ xL | xR // xcut }} + negate (xR l0)) l <	        sum_ind (fun _ : R + L => No)	          (fun r0 : R =>	           xR r0 +	           {{ fun r1 : R => negate (xR r1) | (fun l0 : L => negate (xL l0)) // nxcut }})	          (fun r0 : L => {{ xL | xR // xcut }} + negate (xL r0)) r	  ============================	  {{ sum_ind (fun _ : L + R => No)	       (fun l : L =>	        xL l +	        {{ fun r : R => negate (xR r) | (fun l0 : L => negate (xL l0)) // nxcut }})	       (fun l : R => {{ xL | xR // xcut }} + negate (xR l)) | 	  sum_ind (fun _ : R + L => No)	    (fun r : R =>	     xR r +	     {{ fun r0 : R => negate (xR r0) | (fun l : L => negate (xL l)) // nxcut }})	    (fun r : L => {{ xL | xR // xcut }} + negate (xL r)) // cut }} <= zero	2 subgoals (ID 277)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  H1 : HasNegation S	  L : Type	  R : Type	  s : InSort S L R	  xL : L -> GenNo S	  xR : R -> GenNo S	  xcut : forall (l : L) (r : R), xL l < xR r	  IHL : forall l : L, xL l + negate (xL l) = zero	  IHR : forall r : R, xR r + negate (xR r) = zero	  nxcut : forall (r : R) (l : L), negate (xR r) < negate (xL l)	  cut : forall (l : L + R) (r : R + L),	        sum_ind (fun _ : L + R => No)	          (fun l0 : L =>	           xL l0 +	           {{ fun r0 : R => negate (xR r0) | (fun l1 : L => negate (xL l1)) // nxcut }})	          (fun l0 : R => {{ xL | xR // xcut }} + negate (xR l0)) l <	        sum_ind (fun _ : R + L => No)	          (fun r0 : R =>	           xR r0 +	           {{ fun r1 : R => negate (xR r1) | (fun l0 : L => negate (xL l0)) // nxcut }})	          (fun r0 : L => {{ xL | xR // xcut }} + negate (xL r0)) r	  l : L	  ============================	  xL l +	  {{ fun r : R => negate (xR r) | (fun l0 : L => negate (xL l0)) // nxcut }} <	  {{ Empty_rec | Empty_rec // lempty_cut }}		subgoal 2 (ID 279) is:	 {{ xL | xR // xcut }} + negate (xR r) <	 {{ Empty_rec | Empty_rec // lempty_cut }}	1 subgoal (ID 277)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  H1 : HasNegation S	  L : Type	  R : Type	  s : InSort S L R	  xL : L -> GenNo S	  xR : R -> GenNo S	  xcut : forall (l : L) (r : R), xL l < xR r	  IHL : forall l : L, xL l + negate (xL l) = zero	  IHR : forall r : R, xR r + negate (xR r) = zero	  nxcut : forall (r : R) (l : L), negate (xR r) < negate (xL l)	  cut : forall (l : L + R) (r : R + L),	        sum_ind (fun _ : L + R => No)	          (fun l0 : L =>	           xL l0 +	           {{ fun r0 : R => negate (xR r0) | (fun l1 : L => negate (xL l1)) // nxcut }})	          (fun l0 : R => {{ xL | xR // xcut }} + negate (xR l0)) l <	        sum_ind (fun _ : R + L => No)	          (fun r0 : R =>	           xR r0 +	           {{ fun r1 : R => negate (xR r1) | (fun l0 : L => negate (xL l0)) // nxcut }})	          (fun r0 : L => {{ xL | xR // xcut }} + negate (xL r0)) r	  l : L	  ============================	  xL l +	  {{ fun r : R => negate (xR r) | (fun l0 : L => negate (xL l0)) // nxcut }} <	  {{ Empty_rec | Empty_rec // lempty_cut }}	1 subgoal (ID 283)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  H1 : HasNegation S	  L : Type	  R : Type	  s : InSort S L R	  xL : L -> GenNo S	  xR : R -> GenNo S	  xcut : forall (l : L) (r : R), xL l < xR r	  IHR : forall r : R, xR r + negate (xR r) = zero	  nxcut : forall (r : R) (l : L), negate (xR r) < negate (xL l)	  cut : forall (l : L + R) (r : R + L),	        sum_ind (fun _ : L + R => No)	          (fun l0 : L =>	           xL l0 +	           {{ fun r0 : R => negate (xR r0) | (fun l1 : L => negate (xL l1)) // nxcut }})	          (fun l0 : R => {{ xL | xR // xcut }} + negate (xR l0)) l <	        sum_ind (fun _ : R + L => No)	          (fun r0 : R =>	           xR r0 +	           {{ fun r1 : R => negate (xR r1) | (fun l0 : L => negate (xL l0)) // nxcut }})	          (fun r0 : L => {{ xL | xR // xcut }} + negate (xL r0)) r	  l : L	  ============================	  xL l +	  {{ fun r : R => negate (xR r) | (fun l0 : L => negate (xL l0)) // nxcut }} <	  xL l + negate (xL l)	";
            responses[i]=data;
          

            i = 170;
            data = "1 subgoal (ID 284)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  H1 : HasNegation S	  L : Type	  R : Type	  s : InSort S L R	  xL : L -> GenNo S	  xR : R -> GenNo S	  xcut : forall (l : L) (r : R), xL l < xR r	  IHR : forall r : R, xR r + negate (xR r) = zero	  nxcut : forall (r : R) (l : L), negate (xR r) < negate (xL l)	  cut : forall (l : L + R) (r : R + L),	        sum_ind (fun _ : L + R => No)	          (fun l0 : L =>	           xL l0 +	           {{ fun r0 : R => negate (xR r0) | (fun l1 : L => negate (xL l1)) // nxcut }})	          (fun l0 : R => {{ xL | xR // xcut }} + negate (xR l0)) l <	        sum_ind (fun _ : R + L => No)	          (fun r0 : R =>	           xR r0 +	           {{ fun r1 : R => negate (xR r1) | (fun l0 : L => negate (xL l0)) // nxcut }})	          (fun r0 : L => {{ xL | xR // xcut }} + negate (xL r0)) r	  l : L	  ============================	  {{ fun r : R => negate (xR r) | (fun l0 : L => negate (xL l0)) // nxcut }} <	  negate (xL l)	";
            responses[i]=data;
          

            i = 171;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 subgoals (ID 279)		subgoal 1 (ID 279) is:	 {{ xL | xR // xcut }} + negate (xR r) <	 {{ Empty_rec | Empty_rec // lempty_cut }}	subgoal 2 (ID 262) is:	 zero <=	 {{ sum_ind (fun _ : L + R => No)	      (fun l : L =>	       xL l +	       {{ fun r : R => negate (xR r) | (fun l0 : L => negate (xL l0)) // nxcut }})	      (fun l : R => {{ xL | xR // xcut }} + negate (xR l)) | 	 sum_ind (fun _ : R + L => No)	   (fun r : R =>	    xR r +	    {{ fun r0 : R => negate (xR r0) | (fun l : L => negate (xL l)) // nxcut }})	   (fun r : L => {{ xL | xR // xcut }} + negate (xL r)) // cut }}	";
            responses[i]=data;
          

            i = 172;
            data = "1 subgoal (ID 279)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  H1 : HasNegation S	  L : Type	  R : Type	  s : InSort S L R	  xL : L -> GenNo S	  xR : R -> GenNo S	  xcut : forall (l : L) (r : R), xL l < xR r	  IHL : forall l : L, xL l + negate (xL l) = zero	  IHR : forall r : R, xR r + negate (xR r) = zero	  nxcut : forall (r : R) (l : L), negate (xR r) < negate (xL l)	  cut : forall (l : L + R) (r : R + L),	        sum_ind (fun _ : L + R => No)	          (fun l0 : L =>	           xL l0 +	           {{ fun r0 : R => negate (xR r0) | (fun l1 : L => negate (xL l1)) // nxcut }})	          (fun l0 : R => {{ xL | xR // xcut }} + negate (xR l0)) l <	        sum_ind (fun _ : R + L => No)	          (fun r0 : R =>	           xR r0 +	           {{ fun r1 : R => negate (xR r1) | (fun l0 : L => negate (xL l0)) // nxcut }})	          (fun r0 : L => {{ xL | xR // xcut }} + negate (xL r0)) r	  r : R	  ============================	  {{ xL | xR // xcut }} + negate (xR r) <	  {{ Empty_rec | Empty_rec // lempty_cut }}	1 subgoal (ID 301)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  H1 : HasNegation S	  L : Type	  R : Type	  s : InSort S L R	  xL : L -> GenNo S	  xR : R -> GenNo S	  xcut : forall (l : L) (r : R), xL l < xR r	  IHL : forall l : L, xL l + negate (xL l) = zero	  nxcut : forall (r : R) (l : L), negate (xR r) < negate (xL l)	  cut : forall (l : L + R) (r : R + L),	        sum_ind (fun _ : L + R => No)	          (fun l0 : L =>	           xL l0 +	           {{ fun r0 : R => negate (xR r0) | (fun l1 : L => negate (xL l1)) // nxcut }})	          (fun l0 : R => {{ xL | xR // xcut }} + negate (xR l0)) l <	        sum_ind (fun _ : R + L => No)	          (fun r0 : R =>	           xR r0 +	           {{ fun r1 : R => negate (xR r1) | (fun l0 : L => negate (xL l0)) // nxcut }})	          (fun r0 : L => {{ xL | xR // xcut }} + negate (xL r0)) r	  r : R	  ============================	  {{ xL | xR // xcut }} + negate (xR r) < xR r + negate (xR r)	";
            responses[i]=data;
          

            i = 173;
            data = "1 subgoal (ID 302)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  H1 : HasNegation S	  L : Type	  R : Type	  s : InSort S L R	  xL : L -> GenNo S	  xR : R -> GenNo S	  xcut : forall (l : L) (r : R), xL l < xR r	  IHL : forall l : L, xL l + negate (xL l) = zero	  nxcut : forall (r : R) (l : L), negate (xR r) < negate (xL l)	  cut : forall (l : L + R) (r : R + L),	        sum_ind (fun _ : L + R => No)	          (fun l0 : L =>	           xL l0 +	           {{ fun r0 : R => negate (xR r0) | (fun l1 : L => negate (xL l1)) // nxcut }})	          (fun l0 : R => {{ xL | xR // xcut }} + negate (xR l0)) l <	        sum_ind (fun _ : R + L => No)	          (fun r0 : R =>	           xR r0 +	           {{ fun r1 : R => negate (xR r1) | (fun l0 : L => negate (xL l0)) // nxcut }})	          (fun r0 : L => {{ xL | xR // xcut }} + negate (xL r0)) r	  r : R	  ============================	  {{ xL | xR // xcut }} < xR r	";
            responses[i]=data;
          

            i = 174;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 262)		subgoal 1 (ID 262) is:	 zero <=	 {{ sum_ind (fun _ : L + R => No)	      (fun l : L =>	       xL l +	       {{ fun r : R => negate (xR r) | (fun l0 : L => negate (xL l0)) // nxcut }})	      (fun l : R => {{ xL | xR // xcut }} + negate (xR l)) | 	 sum_ind (fun _ : R + L => No)	   (fun r : R =>	    xR r +	    {{ fun r0 : R => negate (xR r0) | (fun l : L => negate (xL l)) // nxcut }})	   (fun r : L => {{ xL | xR // xcut }} + negate (xL r)) // cut }}	";
            responses[i]=data;
          

            i = 175;
            data = "1 subgoal (ID 262)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  H1 : HasNegation S	  L : Type	  R : Type	  s : InSort S L R	  xL : L -> GenNo S	  xR : R -> GenNo S	  xcut : forall (l : L) (r : R), xL l < xR r	  IHL : forall l : L, xL l + negate (xL l) = zero	  IHR : forall r : R, xR r + negate (xR r) = zero	  nxcut : forall (r : R) (l : L), negate (xR r) < negate (xL l)	  cut : forall (l : L + R) (r : R + L),	        sum_ind (fun _ : L + R => No)	          (fun l0 : L =>	           xL l0 +	           {{ fun r0 : R => negate (xR r0) | (fun l1 : L => negate (xL l1)) // nxcut }})	          (fun l0 : R => {{ xL | xR // xcut }} + negate (xR l0)) l <	        sum_ind (fun _ : R + L => No)	          (fun r0 : R =>	           xR r0 +	           {{ fun r1 : R => negate (xR r1) | (fun l0 : L => negate (xL l0)) // nxcut }})	          (fun r0 : L => {{ xL | xR // xcut }} + negate (xL r0)) r	  ============================	  zero <=	  {{ sum_ind (fun _ : L + R => No)	       (fun l : L =>	        xL l +	        {{ fun r : R => negate (xR r) | (fun l0 : L => negate (xL l0)) // nxcut }})	       (fun l : R => {{ xL | xR // xcut }} + negate (xR l)) | 	  sum_ind (fun _ : R + L => No)	    (fun r : R =>	     xR r +	     {{ fun r0 : R => negate (xR r0) | (fun l : L => negate (xL l)) // nxcut }})	    (fun r : L => {{ xL | xR // xcut }} + negate (xL r)) // cut }}	2 subgoals (ID 332)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  H1 : HasNegation S	  L : Type	  R : Type	  s : InSort S L R	  xL : L -> GenNo S	  xR : R -> GenNo S	  xcut : forall (l : L) (r : R), xL l < xR r	  IHL : forall l : L, xL l + negate (xL l) = zero	  IHR : forall r : R, xR r + negate (xR r) = zero	  nxcut : forall (r : R) (l : L), negate (xR r) < negate (xL l)	  cut : forall (l : L + R) (r : R + L),	        sum_ind (fun _ : L + R => No)	          (fun l0 : L =>	           xL l0 +	           {{ fun r0 : R => negate (xR r0) | (fun l1 : L => negate (xL l1)) // nxcut }})	          (fun l0 : R => {{ xL | xR // xcut }} + negate (xR l0)) l <	        sum_ind (fun _ : R + L => No)	          (fun r0 : R =>	           xR r0 +	           {{ fun r1 : R => negate (xR r1) | (fun l0 : L => negate (xL l0)) // nxcut }})	          (fun r0 : L => {{ xL | xR // xcut }} + negate (xL r0)) r	  r : R	  ============================	  {{ Empty_rec | Empty_rec // lempty_cut }} <	  xR r +	  {{ fun r0 : R => negate (xR r0) | (fun l : L => negate (xL l)) // nxcut }}		subgoal 2 (ID 334) is:	 {{ Empty_rec | Empty_rec // lempty_cut }} <	 {{ xL | xR // xcut }} + negate (xL l)	";
            responses[i]=data;
          

            i = 176;
            data = "1 subgoal (ID 332)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  H1 : HasNegation S	  L : Type	  R : Type	  s : InSort S L R	  xL : L -> GenNo S	  xR : R -> GenNo S	  xcut : forall (l : L) (r : R), xL l < xR r	  IHL : forall l : L, xL l + negate (xL l) = zero	  IHR : forall r : R, xR r + negate (xR r) = zero	  nxcut : forall (r : R) (l : L), negate (xR r) < negate (xL l)	  cut : forall (l : L + R) (r : R + L),	        sum_ind (fun _ : L + R => No)	          (fun l0 : L =>	           xL l0 +	           {{ fun r0 : R => negate (xR r0) | (fun l1 : L => negate (xL l1)) // nxcut }})	          (fun l0 : R => {{ xL | xR // xcut }} + negate (xR l0)) l <	        sum_ind (fun _ : R + L => No)	          (fun r0 : R =>	           xR r0 +	           {{ fun r1 : R => negate (xR r1) | (fun l0 : L => negate (xL l0)) // nxcut }})	          (fun r0 : L => {{ xL | xR // xcut }} + negate (xL r0)) r	  r : R	  ============================	  {{ Empty_rec | Empty_rec // lempty_cut }} <	  xR r +	  {{ fun r0 : R => negate (xR r0) | (fun l : L => negate (xL l)) // nxcut }}	1 subgoal (ID 337)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  H1 : HasNegation S	  L : Type	  R : Type	  s : InSort S L R	  xL : L -> GenNo S	  xR : R -> GenNo S	  xcut : forall (l : L) (r : R), xL l < xR r	  IHL : forall l : L, xL l + negate (xL l) = zero	  nxcut : forall (r : R) (l : L), negate (xR r) < negate (xL l)	  cut : forall (l : L + R) (r : R + L),	        sum_ind (fun _ : L + R => No)	          (fun l0 : L =>	           xL l0 +	           {{ fun r0 : R => negate (xR r0) | (fun l1 : L => negate (xL l1)) // nxcut }})	          (fun l0 : R => {{ xL | xR // xcut }} + negate (xR l0)) l <	        sum_ind (fun _ : R + L => No)	          (fun r0 : R =>	           xR r0 +	           {{ fun r1 : R => negate (xR r1) | (fun l0 : L => negate (xL l0)) // nxcut }})	          (fun r0 : L => {{ xL | xR // xcut }} + negate (xL r0)) r	  r : R	  ============================	  xR r + negate (xR r) <	  xR r +	  {{ fun r0 : R => negate (xR r0) | (fun l : L => negate (xL l)) // nxcut }}	";
            responses[i]=data;
          

            i = 177;
            data = "1 subgoal (ID 338)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  H1 : HasNegation S	  L : Type	  R : Type	  s : InSort S L R	  xL : L -> GenNo S	  xR : R -> GenNo S	  xcut : forall (l : L) (r : R), xL l < xR r	  IHL : forall l : L, xL l + negate (xL l) = zero	  nxcut : forall (r : R) (l : L), negate (xR r) < negate (xL l)	  cut : forall (l : L + R) (r : R + L),	        sum_ind (fun _ : L + R => No)	          (fun l0 : L =>	           xL l0 +	           {{ fun r0 : R => negate (xR r0) | (fun l1 : L => negate (xL l1)) // nxcut }})	          (fun l0 : R => {{ xL | xR // xcut }} + negate (xR l0)) l <	        sum_ind (fun _ : R + L => No)	          (fun r0 : R =>	           xR r0 +	           {{ fun r1 : R => negate (xR r1) | (fun l0 : L => negate (xL l0)) // nxcut }})	          (fun r0 : L => {{ xL | xR // xcut }} + negate (xL r0)) r	  r : R	  ============================	  negate (xR r) <	  {{ fun r0 : R => negate (xR r0) | (fun l : L => negate (xL l)) // nxcut }}	";
            responses[i]=data;
          

            i = 178;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 subgoal (ID 334)		subgoal 1 (ID 334) is:	 {{ Empty_rec | Empty_rec // lempty_cut }} <	 {{ xL | xR // xcut }} + negate (xL l)	";
            responses[i]=data;
          

            i = 179;
            data = "1 subgoal (ID 334)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  H1 : HasNegation S	  L : Type	  R : Type	  s : InSort S L R	  xL : L -> GenNo S	  xR : R -> GenNo S	  xcut : forall (l : L) (r : R), xL l < xR r	  IHL : forall l : L, xL l + negate (xL l) = zero	  IHR : forall r : R, xR r + negate (xR r) = zero	  nxcut : forall (r : R) (l : L), negate (xR r) < negate (xL l)	  cut : forall (l : L + R) (r : R + L),	        sum_ind (fun _ : L + R => No)	          (fun l0 : L =>	           xL l0 +	           {{ fun r0 : R => negate (xR r0) | (fun l1 : L => negate (xL l1)) // nxcut }})	          (fun l0 : R => {{ xL | xR // xcut }} + negate (xR l0)) l <	        sum_ind (fun _ : R + L => No)	          (fun r0 : R =>	           xR r0 +	           {{ fun r1 : R => negate (xR r1) | (fun l0 : L => negate (xL l0)) // nxcut }})	          (fun r0 : L => {{ xL | xR // xcut }} + negate (xL r0)) r	  l : L	  ============================	  {{ Empty_rec | Empty_rec // lempty_cut }} <	  {{ xL | xR // xcut }} + negate (xL l)	1 subgoal (ID 355)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  H1 : HasNegation S	  L : Type	  R : Type	  s : InSort S L R	  xL : L -> GenNo S	  xR : R -> GenNo S	  xcut : forall (l : L) (r : R), xL l < xR r	  IHR : forall r : R, xR r + negate (xR r) = zero	  nxcut : forall (r : R) (l : L), negate (xR r) < negate (xL l)	  cut : forall (l : L + R) (r : R + L),	        sum_ind (fun _ : L + R => No)	          (fun l0 : L =>	           xL l0 +	           {{ fun r0 : R => negate (xR r0) | (fun l1 : L => negate (xL l1)) // nxcut }})	          (fun l0 : R => {{ xL | xR // xcut }} + negate (xR l0)) l <	        sum_ind (fun _ : R + L => No)	          (fun r0 : R =>	           xR r0 +	           {{ fun r1 : R => negate (xR r1) | (fun l0 : L => negate (xL l0)) // nxcut }})	          (fun r0 : L => {{ xL | xR // xcut }} + negate (xL r0)) r	  l : L	  ============================	  xL l + negate (xL l) < {{ xL | xR // xcut }} + negate (xL l)	";
            responses[i]=data;
          

            i = 180;
            data = "1 subgoal (ID 356)	  	  H : Univalence	  S : OptionSort	  H0 : HasAddition S	  No := GenNo S : Type	  H1 : HasNegation S	  L : Type	  R : Type	  s : InSort S L R	  xL : L -> GenNo S	  xR : R -> GenNo S	  xcut : forall (l : L) (r : R), xL l < xR r	  IHR : forall r : R, xR r + negate (xR r) = zero	  nxcut : forall (r : R) (l : L), negate (xR r) < negate (xL l)	  cut : forall (l : L + R) (r : R + L),	        sum_ind (fun _ : L + R => No)	          (fun l0 : L =>	           xL l0 +	           {{ fun r0 : R => negate (xR r0) | (fun l1 : L => negate (xL l1)) // nxcut }})	          (fun l0 : R => {{ xL | xR // xcut }} + negate (xR l0)) l <	        sum_ind (fun _ : R + L => No)	          (fun r0 : R =>	           xR r0 +	           {{ fun r1 : R => negate (xR r1) | (fun l0 : L => negate (xL l0)) // nxcut }})	          (fun r0 : L => {{ xL | xR // xcut }} + negate (xL r0)) r	  l : L	  ============================	  xL l < {{ xL | xR // xcut }}	";
            responses[i]=data;
          

            i = 181;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 182;
            data = "";
            responses[i]=data;
          

            i = 183;
            data = "<infomsg>sub is defined</infomsg>	";
            responses[i]=data;
          

            i = 184;
            data = "";
            responses[i]=data;
          

            i = 185;
            data = "";
            responses[i]=data;
          

            i = 186;
            data = "";
            responses[i]=data;
          

            i = 187;
            data = "";
            responses[i]=data;
          

            i = 188;
            data = "";
            responses[i]=data;
          

            i = 189;
            data = "";
            responses[i]=data;
          

            i = 190;
            data = "";
            responses[i]=data;
          

            i = 191;
            data = "";
            responses[i]=data;
          

            i = 192;
            data = "";
            responses[i]=data;
          

            i = 193;
            data = "";
            responses[i]=data;
          

            i = 194;
            data = "";
            responses[i]=data;
          

            i = 195;
            data = "";
            responses[i]=data;
          

            i = 196;
            data = "";
            responses[i]=data;
          
        };
        
        function get_response(id) {
          return responses[id];
        };

        function set_response(response, scene) {
          goalId = "goal"+scene;
          elById = document.getElementById(goalId);
          if(elById){ 
            goalSpan = elById.getElementsByTagName("span")[0];
            goalSpan.innerHTML = response.replace(/	/g , '\n');
          }
        };
      </script>
</head>
<body onload="set_array()"><div id="page" scenenumber="0" class="doc">
<div id="header" scenenumber="1" class="doc">
</div>
<div id="main" scenenumber="3" class="doc">
<h1 class="libtitle">Library HoTT.Spaces.No.Addition</h1>
<div scenenumber="3" class="code">
<span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(6, '0_3_3');
      ">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Basics.html#"><span class="id" title="library">HoTT.Basics</span></a> <a class="idref" href="HoTT.Types.html#"><span class="id" title="library">HoTT.Types</span></a> <a class="idref" href="HoTT.UnivalenceImpliesFunext.html#"><span class="id" title="library">UnivalenceImpliesFunext</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(7, '0_3_3');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Spaces.No.Core.html#"><span class="id" title="library">HoTT.Spaces.No.Core</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#"><span class="id" title="library">HoTT.Spaces.No.Negation</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(8, '0_3_3');
      "><br>
<br>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">path_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(9, '0_3_3');
      "><br>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">surreal_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(10, '0_3_3');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_3"><pre><span></span></pre></div>
<div class="doc" scenenumber="5">
<a name="lab351"></a><h1 class="section">Addition of surreal numbers</h1>
<div class="doc" scenenumber="4"> </div>

 Addition requires the option sorts to be closed under finite sums. 
</div>
<div scenenumber="7" class="code">
<span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(19, '0_3_7');
      ">
<span class="id" title="keyword">Class</span> <a name="HasAddition"><span class="id" title="record">HasAddition</span></a> (<span class="id" title="var">S</span> : <a class="idref" href="HoTT.Spaces.No.Core.html#OptionSort"><span class="id" title="definition">OptionSort</span></a>) :=<br>
  { <a name="empty_options"><span class="id" title="projection">empty_options</span></a> : <a class="idref" href="HoTT.Spaces.No.Core.html#InSort"><span class="id" title="class">InSort</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#S"><span class="id" title="variable">S</span></a> <a class="idref" href="HoTT.Basics.Overture.html#Empty"><span class="id" title="inductive">Empty</span></a> <a class="idref" href="HoTT.Basics.Overture.html#Empty"><span class="id" title="inductive">Empty</span></a><br>
    ; <a name="sum_options"><span class="id" title="projection">sum_options</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">L</span> <span class="id" title="var">R</span> <span class="id" title="var">L'</span> <span class="id" title="var">R'</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a><br>
        <a class="idref" href="HoTT.Spaces.No.Core.html#InSort"><span class="id" title="class">InSort</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#S"><span class="id" title="variable">S</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#L"><span class="id" title="variable">L</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#InSort"><span class="id" title="class">InSort</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#S"><span class="id" title="variable">S</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#L'"><span class="id" title="variable">L'</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#R'"><span class="id" title="variable">R'</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#InSort"><span class="id" title="class">InSort</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#S"><span class="id" title="variable">S</span></a> (<a class="idref" href="HoTT.Spaces.No.Addition.html#L"><span class="id" title="variable">L</span></a> <a class="idref" href="Coq.Init.Datatypes.html#e03f39daf98516fa530d3f6f5a1b4d92"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#L'"><span class="id" title="variable">L'</span></a>) (<a class="idref" href="HoTT.Spaces.No.Addition.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Datatypes.html#e03f39daf98516fa530d3f6f5a1b4d92"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#R'"><span class="id" title="variable">R'</span></a>)<br>
  }.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(20, '0_3_7');
      "><br>
<span class="id" title="var">Existing</span> <span class="id" title="keyword">Instance</span> <span class="id" title="var">empty_options</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(21, '0_3_7');
      "><br>
<span class="id" title="var">Existing</span> <span class="id" title="keyword">Instance</span> <span class="id" title="var">sum_options</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(22, '0_3_7');
      "><br>
<br>
<span class="id" title="keyword">Global Instance</span> <a name="hasaddition_maxsort"><span class="id" title="instance">hasaddition_maxsort</span></a> : <a class="idref" href="HoTT.Spaces.No.Addition.html#HasAddition"><span class="id" title="class">HasAddition</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#MaxSort"><span class="id" title="definition">MaxSort</span></a><br>
  := { <a class="idref" href="HoTT.Spaces.No.Addition.html#empty_options"><span class="id" title="projection">empty_options</span></a> := <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> ;<br>
       <a class="idref" href="HoTT.Spaces.No.Addition.html#sum_options"><span class="id" title="projection">sum_options</span></a> := <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> }.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(23, '0_3_7');
      "><br>
<br>
<span class="id" title="keyword">Global Instance</span> <a name="hasaddition_ordsort"><span class="id" title="instance">hasaddition_ordsort</span></a> : <a class="idref" href="HoTT.Spaces.No.Addition.html#HasAddition"><span class="id" title="class">HasAddition</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#OrdSort"><span class="id" title="definition">OrdSort</span></a><br>
  := { <a class="idref" href="HoTT.Spaces.No.Addition.html#empty_options"><span class="id" title="projection">empty_options</span></a> := <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a> ;<br>
       <a class="idref" href="HoTT.Spaces.No.Addition.html#sum_options"><span class="id" title="projection">sum_options</span></a> := <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> ⇒ <a class="idref" href="HoTT.Types.Sum.html#sum_ind"><span class="id" title="definition">sum_ind</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> }.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(24, '0_3_7');
      "><br>
<br>
<span class="id" title="keyword">Global Instance</span> <a name="hasaddition_decsort"><span class="id" title="instance">hasaddition_decsort</span></a> : <a class="idref" href="HoTT.Spaces.No.Addition.html#HasAddition"><span class="id" title="class">HasAddition</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#DecSort"><span class="id" title="definition">DecSort</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(25, '0_3_7');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(26, '0_3_7');
      "><br>
  <span class="id" title="tactic">constructor</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(27, '0_3_7');
      "><br>
  - <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#insort_decsort"><span class="id" title="instance">insort_decsort</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(28, '0_3_7');
      "><br>
  - <span class="id" title="tactic">intros</span> <span class="id" title="var">L</span> <span class="id" title="var">R</span> <span class="id" title="var">L'</span> <span class="id" title="var">R'</span> [? ?] [? ?]; <span class="id" title="tactic">split</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(29, '0_3_7');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(30, '0_3_7');
      "><br>
<br>
<span class="id" title="keyword">Section</span> <a name="Addition"><span class="id" title="section">Addition</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(31, '0_3_7');
      "><br>
  <span class="id" title="keyword">Context</span> `{<a class="idref" href="HoTT.Types.Universe.html#Univalence"><span class="id" title="class">Univalence</span></a>}.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(32, '0_3_7');
      "><br>
  <span class="id" title="keyword">Context</span> {<span class="id" title="var">S</span> : <a class="idref" href="HoTT.Spaces.No.Core.html#OptionSort"><span class="id" title="definition">OptionSort@</span></a>{<span class="id" title="var">i</span>}} `{<a class="idref" href="HoTT.Spaces.No.Addition.html#HasAddition"><span class="id" title="class">HasAddition</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#S"><span class="id" title="variable">S</span></a>}.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(33, '0_3_7');
      "><br>
  <span class="id" title="keyword">Let</span> <a name="Addition.No"><span class="id" title="variable">No</span></a> := <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.GenNo"><span class="id" title="record">GenNo</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.S"><span class="id" title="variable">S</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(34, '0_3_7');
      "><br>
<br>
  <span class="id" title="keyword">Section</span> <a name="Addition.Inner"><span class="id" title="section">Inner</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(35, '0_3_7');
      "><br>
<br>
    <span class="id" title="keyword">Context</span> {<span class="id" title="var">L</span> <span class="id" title="var">R</span> : <span class="id" title="var">Type@</span>{<span class="id" title="var">i</span>} } {<span class="id" title="var">Sx</span> : <a class="idref" href="HoTT.Spaces.No.Core.html#InSort"><span class="id" title="class">InSort@</span></a>{<span class="id" title="var">i</span>} <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.S"><span class="id" title="variable">S</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#L"><span class="id" title="variable">L</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#R"><span class="id" title="variable">R</span></a>}<br>
            (<span class="id" title="var">xL</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#L"><span class="id" title="variable">L</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>}) (<span class="id" title="var">xR</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>})<br>
            (<span class="id" title="var">xcut</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><span class="id" title="var">l</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#L"><span class="id" title="variable">L</span></a>) (<span class="id" title="var">r</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#R"><span class="id" title="variable">R</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#xL"><span class="id" title="variable">xL</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#xR"><span class="id" title="variable">xR</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(36, '0_3_7');
      "><br>
<br>
    <span class="id" title="keyword">Let</span> <a name="Addition.Inner.A"><span class="id" title="variable">A</span></a> := <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><span class="id" title="var">g</span> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>} <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>} <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a><br>
              <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>}<a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#b0ffa48971baa6e5913c7f1eea9baaf6"><span class="id" title="notation">≤</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#b0ffa48971baa6e5913c7f1eea9baaf6"><span class="id" title="notation">≤</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a><br>
              <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>}<a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a><a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(37, '0_3_7');
      "><br>
<br>
    <span class="id" title="keyword">Context</span> (<span class="id" title="var">xL_plus</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.L"><span class="id" title="variable">L</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">xR_plus</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.A"><span class="id" title="variable">A</span></a>)<br>
            (<span class="id" title="var">xL_lt_xR_plus</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><span class="id" title="var">l</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.L"><span class="id" title="variable">L</span></a>) (<span class="id" title="var">r</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.R"><span class="id" title="variable">R</span></a>) (<span class="id" title="var">x</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a><br>
                               <a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#xL_plus"><span class="id" title="variable">xL_plus</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#xR_plus"><span class="id" title="variable">xR_plus</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(38, '0_3_7');
      "><br>
<br>
    <span class="id" title="keyword">Definition</span> <a name="plus_inner"><span class="id" title="definition">plus_inner</span></a><br>
    : <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a> <span class="id" title="var">g</span> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><span class="id" title="var">y</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>}<a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a><br>
              <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a> <span class="id" title="var">x_plus_y</span> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>} <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a><br>
                <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">l</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.xL_plus"><span class="id" title="variable">xL_plus</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x_plus_y"><span class="id" title="variable">x_plus_y</span></a><a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a><br>
                <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">r</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x_plus_y"><span class="id" title="variable">x_plus_y</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.xR_plus"><span class="id" title="variable">xR_plus</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a><br>
        <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">y</span> <span class="id" title="var">z</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#b0ffa48971baa6e5913c7f1eea9baaf6"><span class="id" title="notation">≤</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#z"><span class="id" title="variable">z</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#b0ffa48971baa6e5913c7f1eea9baaf6"><span class="id" title="notation">≤</span></a> <a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#z"><span class="id" title="variable">z</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">).1</span></a><a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a><br>
        <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">y</span> <span class="id" title="var">z</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#z"><span class="id" title="variable">z</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#z"><span class="id" title="variable">z</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">).1</span></a><a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(39, '0_3_7');
      "><br>
    <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(40, '0_3_7');
      "><br>
      <span class="id" title="tactic">simple</span> <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.No_ind_package"><span class="id" title="definition">No_ind_package</span></a><br>
                (<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> ⇒ <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a> <span class="id" title="var">x_plus_y</span> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a><br>
                            <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">l</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.xL_plus"><span class="id" title="variable">xL_plus</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x_plus_y"><span class="id" title="variable">x_plus_y</span></a><a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a><br>
                            <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">r</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x_plus_y"><span class="id" title="variable">x_plus_y</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.xR_plus"><span class="id" title="variable">xR_plus</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a>)<br>
                (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">z</span> <span class="id" title="var">w</span> ⇒ <a class="idref" href="HoTT.Spaces.No.Addition.html#z"><span class="id" title="variable">z</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">.1</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#b0ffa48971baa6e5913c7f1eea9baaf6"><span class="id" title="notation">≤</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#w"><span class="id" title="variable">w</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">.1</span></a>)<br>
                (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">z</span> <span class="id" title="var">w</span> ⇒ <a class="idref" href="HoTT.Spaces.No.Addition.html#z"><span class="id" title="variable">z</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">.1</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#w"><span class="id" title="variable">w</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">.1</span></a>)<br>
                <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(41, '0_3_7');
      "><br>
      - <span class="id" title="tactic">intros</span> <span class="id" title="var">L'</span> <span class="id" title="var">R'</span> ? <span class="id" title="var">yL</span> <span class="id" title="var">yR</span> <span class="id" title="var">ycut</span> <span class="id" title="var">x_plus_yL</span> <span class="id" title="var">x_plus_yR</span> <span class="id" title="var">x_plus_yL_lt_yR</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(42, '0_3_7');
      "><br>
        <span class="id" title="tactic">pose</span> (<span class="id" title="var">L''</span> := <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.L"><span class="id" title="variable">L</span></a> <a class="idref" href="Coq.Init.Datatypes.html#e03f39daf98516fa530d3f6f5a1b4d92"><span class="id" title="notation">+</span></a> <span class="id" title="var">L'</span>). </span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(43, '0_3_7');
      "><span class="id" title="tactic">pose</span> (<span class="id" title="var">R''</span> := <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Datatypes.html#e03f39daf98516fa530d3f6f5a1b4d92"><span class="id" title="notation">+</span></a> <span class="id" title="var">R'</span>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(44, '0_3_7');
      "><br>
        <span class="id" title="tactic">pose</span> (<span class="id" title="var">zL</span> := <a class="idref" href="HoTT.Types.Sum.html#sum_ind"><span class="id" title="definition">sum_ind</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a>)<br>
                            (<span class="id" title="keyword">fun</span> <span class="id" title="var">l</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.xL_plus"><span class="id" title="variable">xL_plus</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">{{</span></a> <span class="id" title="var">yL</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">|</span></a> <span class="id" title="var">yR</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">//</span></a> <span class="id" title="var">ycut</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">}}</span></a>)<br>
                            (<span class="id" title="keyword">fun</span> <span class="id" title="var">l</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">(</span></a><span class="id" title="var">x_plus_yL</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">).1</span></a>)<br>
                    : <span class="id" title="var">L''</span> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(45, '0_3_7');
      "><br>
        <span class="id" title="tactic">pose</span> (<span class="id" title="var">zR</span> := <a class="idref" href="HoTT.Types.Sum.html#sum_ind"><span class="id" title="definition">sum_ind</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a>)<br>
                            (<span class="id" title="keyword">fun</span> <span class="id" title="var">r</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.xR_plus"><span class="id" title="variable">xR_plus</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">{{</span></a> <span class="id" title="var">yL</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">|</span></a> <span class="id" title="var">yR</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">//</span></a> <span class="id" title="var">ycut</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">}}</span></a>)<br>
                            (<span class="id" title="keyword">fun</span> <span class="id" title="var">r</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">(</span></a><span class="id" title="var">x_plus_yR</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">).1</span></a>)<br>
                    : <span class="id" title="var">R''</span> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(46, '0_3_7');
      "><br>
        <span class="id" title="tactic">assert</span> (<span class="id" title="var">zcut</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><span class="id" title="var">l</span>:<span class="id" title="var">L''</span>) (<span class="id" title="var">r</span>:<span class="id" title="var">R''</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <span class="id" title="var">zL</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">&lt;</span></a> <span class="id" title="var">zR</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(47, '0_3_7');
      "><br>
        { <span class="id" title="tactic">abstract</span> (<br>
          <span class="id" title="tactic">intros</span> [<span class="id" title="var">l</span>|<span class="id" title="var">l</span>] [<span class="id" title="var">r</span>|<span class="id" title="var">r</span>]; <span class="id" title="var">cbn</span>;<br>
          [ <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.xL_lt_xR_plus"><span class="id" title="variable">xL_lt_xR_plus</span></a><br>
          | <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.xL_plus"><span class="id" title="variable">xL_plus</span></a> <span class="id" title="var">l</span><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">).1</span></a> (<span class="id" title="var">yR</span> <span class="id" title="var">r</span>));<br>
            [ <span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.Basics.Overture.html#dec9bdefe956e49d73ffc4a7400937db"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.xL_plus"><span class="id" title="variable">xL_plus</span></a> <span class="id" title="var">l</span><a class="idref" href="HoTT.Basics.Overture.html#dec9bdefe956e49d73ffc4a7400937db"><span class="id" title="notation">).2</span></a>), <a class="idref" href="HoTT.Spaces.No.Core.html#lt_ropt"><span class="id" title="lemma">lt_ropt</span></a>; <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span><br>
            | <span class="id" title="tactic">exact</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.Basics.Overture.html#dec9bdefe956e49d73ffc4a7400937db"><span class="id" title="notation">(</span></a><span class="id" title="var">x_plus_yR</span> <span class="id" title="var">r</span><a class="idref" href="HoTT.Basics.Overture.html#dec9bdefe956e49d73ffc4a7400937db"><span class="id" title="notation">).2</span></a> <span class="id" title="var">l</span>) ]<br>
          | <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.xR_plus"><span class="id" title="variable">xR_plus</span></a> <span class="id" title="var">r</span><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">).1</span></a> (<span class="id" title="var">yL</span> <span class="id" title="var">l</span>));<br>
            [ <span class="id" title="tactic">exact</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.Basics.Overture.html#dec9bdefe956e49d73ffc4a7400937db"><span class="id" title="notation">(</span></a><span class="id" title="var">x_plus_yL</span> <span class="id" title="var">l</span><a class="idref" href="HoTT.Basics.Overture.html#dec9bdefe956e49d73ffc4a7400937db"><span class="id" title="notation">).2</span></a> <span class="id" title="var">r</span>)<br>
            | <span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.Basics.Overture.html#dec9bdefe956e49d73ffc4a7400937db"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.xR_plus"><span class="id" title="variable">xR_plus</span></a> <span class="id" title="var">r</span><a class="idref" href="HoTT.Basics.Overture.html#dec9bdefe956e49d73ffc4a7400937db"><span class="id" title="notation">).2</span></a>), <a class="idref" href="HoTT.Spaces.No.Core.html#lt_lopt"><span class="id" title="lemma">lt_lopt</span></a>; <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span> ]<br>
          | <span class="id" title="tactic">apply</span> <span class="id" title="var">x_plus_yL_lt_yR</span> ]). }</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(48, '0_3_7');
      "><br>
        <span class="id" title="tactic">assert</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#InSort"><span class="id" title="class">InSort</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.S"><span class="id" title="variable">S</span></a> <span class="id" title="var">L''</span> <span class="id" title="var">R''</span>) <span class="id" title="tactic">by</span> (<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#sum_options"><span class="id" title="projection">sum_options</span></a>; <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(49, '0_3_7');
      "><br>
        <span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">{{</span></a> <span class="id" title="var">zL</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">|</span></a> <span class="id" title="var">zR</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">//</span></a> <span class="id" title="var">zcut</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">}}</span></a>); <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(50, '0_3_7');
      "><br>
        + <span class="id" title="tactic">intros</span> <span class="id" title="var">l</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(51, '0_3_7');
      "><br>
          <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#lt_lopt"><span class="id" title="lemma">lt_lopt</span></a> <span class="id" title="var">zL</span> <span class="id" title="var">zR</span> <span class="id" title="var">zcut</span> (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">l</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(52, '0_3_7');
      "><br>
        + <span class="id" title="tactic">intros</span> <span class="id" title="var">r</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(53, '0_3_7');
      "><br>
          <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#lt_ropt"><span class="id" title="lemma">lt_ropt</span></a> <span class="id" title="var">zL</span> <span class="id" title="var">zR</span> <span class="id" title="var">zcut</span> (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">r</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(54, '0_3_7');
      "><br>
      - <span class="id" title="tactic">abstract</span> (<br>
        <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> [<span class="id" title="var">a</span> ?] [<span class="id" title="var">b</span> ?] <span class="id" title="var">p</span> <span class="id" title="var">q</span> <span class="id" title="var">r</span> <span class="id" title="var">s</span>;<br>
        <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Types.Sigma.html#transport_sigma"><span class="id" title="definition">transport_sigma</span></a>; <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> *;<br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Sigma.html#path_sigma_hprop"><span class="id" title="definition">path_sigma_hprop</span></a>, <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.path_No"><span class="id" title="axiom">path_No</span></a>; <span class="id" title="var">cbn</span>;<br>
        <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_const"><span class="id" title="definition">transport_const</span></a>; <span class="id" title="tactic">assumption</span>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(55, '0_3_7');
      "><br>
      - <span class="id" title="tactic">abstract</span> (<br>
        <span class="id" title="tactic">intros</span> <span class="id" title="var">L'</span> <span class="id" title="var">R'</span> ? <span class="id" title="var">yL</span> <span class="id" title="var">yR</span> <span class="id" title="var">ycut</span> <span class="id" title="var">x_plus_yL</span> <span class="id" title="var">x_plus_yR</span> <span class="id" title="var">x_plus_yL_lt_yR</span><br>
               <span class="id" title="var">L''</span> <span class="id" title="var">R''</span> ? <span class="id" title="var">zL</span> <span class="id" title="var">zR</span> <span class="id" title="var">zcut</span> <span class="id" title="var">x_plus_zL</span> <span class="id" title="var">x_plus_zR</span> <span class="id" title="var">x_plus_zL_lt_zR</span><br>
               <span class="id" title="var">yL_lt_z</span> <span class="id" title="var">x_plus_yL_lt_z</span> <span class="id" title="var">y_lt_zR</span> <span class="id" title="var">x_plus_y_lt_zR</span>;<br>
        <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> *;<br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.le_lr"><span class="id" title="definition">le_lr</span></a>; [ <span class="id" title="tactic">intros</span> [<span class="id" title="var">l</span>|<span class="id" title="var">l</span>] | <span class="id" title="tactic">intros</span> [<span class="id" title="var">r</span>|<span class="id" title="var">r</span>] ]; <span class="id" title="var">cbn</span>;<br>
        [ <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#le_lt_trans"><span class="id" title="lemma">le_lt_trans</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.Basics.Overture.html#dec9bdefe956e49d73ffc4a7400937db"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.xL_plus"><span class="id" title="variable">xL_plus</span></a> <span class="id" title="var">l</span><a class="idref" href="HoTT.Basics.Overture.html#dec9bdefe956e49d73ffc4a7400937db"><span class="id" title="notation">).2</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">{{</span></a> <span class="id" title="var">zL</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">|</span></a> <span class="id" title="var">zR</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">//</span></a> <span class="id" title="var">zcut</span><a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">}}</span></a> <span class="id" title="var">_</span>) <span class="id" title="var">_</span>);<br>
          [ <span class="id" title="tactic">by</span> (<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.le_lr"><span class="id" title="definition">le_lr</span></a>; <span class="id" title="tactic">assumption</span>)<br>
          | <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#lt_lopt"><span class="id" title="lemma">lt_lopt</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">l</span>)) ]<br>
        | <span class="id" title="tactic">exact</span> (<span class="id" title="var">x_plus_yL_lt_z</span> <span class="id" title="var">l</span>)<br>
        | <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#lt_le_trans"><span class="id" title="lemma">lt_le_trans</span></a> <span class="id" title="var">_</span><br>
                    (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.Basics.Overture.html#dec9bdefe956e49d73ffc4a7400937db"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.xR_plus"><span class="id" title="variable">xR_plus</span></a> <span class="id" title="var">r</span><a class="idref" href="HoTT.Basics.Overture.html#dec9bdefe956e49d73ffc4a7400937db"><span class="id" title="notation">).2</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">{{</span></a> <span class="id" title="var">yL</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">|</span></a> <span class="id" title="var">yR</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">//</span></a> <span class="id" title="var">ycut</span><a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">}}</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>));<br>
          [ <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#lt_ropt"><span class="id" title="lemma">lt_ropt</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">r</span>))<br>
          | <span class="id" title="tactic">by</span> (<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.le_lr"><span class="id" title="definition">le_lr</span></a>; <span class="id" title="tactic">assumption</span>) ]<br>
        | <span class="id" title="tactic">exact</span> (<span class="id" title="var">x_plus_y_lt_zR</span> <span class="id" title="var">r</span>) ] ).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(56, '0_3_7');
      "><br>
      - <span class="id" title="tactic">abstract</span> (<br>
        <span class="id" title="tactic">intros</span> <span class="id" title="var">L'</span> <span class="id" title="var">R'</span> ? <span class="id" title="var">yL</span> <span class="id" title="var">yR</span> <span class="id" title="var">ycut</span> <span class="id" title="var">x_plus_yL</span> <span class="id" title="var">x_plus_yR</span> <span class="id" title="var">x_plus_yL_lt_yR</span><br>
               <span class="id" title="var">L''</span> <span class="id" title="var">R''</span> ? <span class="id" title="var">zL</span> <span class="id" title="var">zR</span> <span class="id" title="var">zcut</span> <span class="id" title="var">x_plus_zL</span> <span class="id" title="var">x_plus_zR</span> <span class="id" title="var">x_plus_zL_lt_zR</span><br>
               <span class="id" title="var">l</span> <span class="id" title="var">y_le_zL</span> <span class="id" title="var">x_plus_y_le_zL</span>; <span class="id" title="var">cbn</span>;<br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.lt_l"><span class="id" title="definition">lt_l</span></a> <span class="id" title="keyword">with</span> (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <span class="id" title="var">l</span>);<br>
        <span class="id" title="tactic">apply</span> <span class="id" title="var">x_plus_y_le_zL</span> ).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(57, '0_3_7');
      "><br>
      - <span class="id" title="tactic">abstract</span> (<br>
        <span class="id" title="tactic">intros</span> <span class="id" title="var">L'</span> <span class="id" title="var">R'</span> ? <span class="id" title="var">yL</span> <span class="id" title="var">yR</span> <span class="id" title="var">ycut</span> <span class="id" title="var">x_plus_yL</span> <span class="id" title="var">x_plus_yR</span> <span class="id" title="var">x_plus_yL_lt_yR</span><br>
               <span class="id" title="var">L''</span> <span class="id" title="var">R''</span> ? <span class="id" title="var">zL</span> <span class="id" title="var">zR</span> <span class="id" title="var">zcut</span> <span class="id" title="var">x_plus_zL</span> <span class="id" title="var">x_plus_zR</span> <span class="id" title="var">x_plus_zL_lt_zR</span><br>
               <span class="id" title="var">r</span> <span class="id" title="var">yR_le_z</span> <span class="id" title="var">x_plus_yR_le_z</span>; <span class="id" title="var">cbn</span>;<br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.lt_r"><span class="id" title="definition">lt_r</span></a> <span class="id" title="keyword">with</span> (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <span class="id" title="var">r</span>);<br>
        <span class="id" title="tactic">apply</span> <span class="id" title="var">x_plus_yR_le_z</span>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(58, '0_3_7');
      "><br>
    <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(59, '0_3_7');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_7"><pre><span></span></pre></div>
<div class="doc" scenenumber="9">
We now prove a computation law for <span class="inlinecode"><a class="idref" href="HoTT.Spaces.No.Addition.html#plus_inner"><span class="id" title="definition">plus_inner</span></a></span>.  It holds definitionally, so we would like to prove it with just <span class="inlinecode">:=</span> <span class="inlinecode">1</span> and then rewrite along it later, as we did above.  However, there is a subtlety in that the output should be a surreal defined by a cut, which in particular includes a proof of cut-ness, and that proof is rather long, so we would not like to see it in the type of this lemma.  Thus, instead we assert only that there *exists* some proof of cut-ness and an equality. 
</div>
<div scenenumber="11" class="code">
<span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(69, '0_3_11');
      ">
    <span class="id" title="keyword">Definition</span> <a name="plus_inner_cut"><span class="id" title="definition">plus_inner_cut</span></a><br>
               {<span class="id" title="var">L'</span> <span class="id" title="var">R'</span> : <span class="id" title="var">Type@</span>{<span class="id" title="var">i</span>} } {<span class="id" title="var">Sy</span> : <a class="idref" href="HoTT.Spaces.No.Core.html#InSort"><span class="id" title="class">InSort@</span></a>{<span class="id" title="var">i</span>} <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.S"><span class="id" title="variable">S</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#L'"><span class="id" title="variable">L'</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#R'"><span class="id" title="variable">R'</span></a>}<br>
               (<span class="id" title="var">yL</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#L'"><span class="id" title="variable">L'</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>}) (<span class="id" title="var">yR</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#R'"><span class="id" title="variable">R'</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>})<br>
               (<span class="id" title="var">ycut</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><span class="id" title="var">l</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#L'"><span class="id" title="variable">L'</span></a>) (<span class="id" title="var">r</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#R'"><span class="id" title="variable">R'</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#yL"><span class="id" title="variable">yL</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#yR"><span class="id" title="variable">yR</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a>)<br>
    : <span class="id" title="keyword">let</span> <span class="id" title="var">L''</span> := <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.L"><span class="id" title="variable">L</span></a> <a class="idref" href="Coq.Init.Datatypes.html#e03f39daf98516fa530d3f6f5a1b4d92"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#L'"><span class="id" title="variable">L'</span></a> <span class="id" title="tactic">in</span><br>
      <span class="id" title="keyword">let</span> <span class="id" title="var">R''</span> := <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Datatypes.html#e03f39daf98516fa530d3f6f5a1b4d92"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#R'"><span class="id" title="variable">R'</span></a> <span class="id" title="tactic">in</span><br>
      <span class="id" title="keyword">let</span> <span class="id" title="var">zL</span> := <a class="idref" href="HoTT.Types.Sum.html#sum_ind"><span class="id" title="definition">sum_ind</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a>)<br>
                        (<span class="id" title="keyword">fun</span> <span class="id" title="var">l</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.xL_plus"><span class="id" title="variable">xL_plus</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">{{</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#yL"><span class="id" title="variable">yL</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">|</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#yR"><span class="id" title="variable">yR</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">//</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#ycut"><span class="id" title="variable">ycut</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">}}</span></a>)<br>
                        (<span class="id" title="keyword">fun</span> <span class="id" title="var">l</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#plus_inner"><span class="id" title="definition">plus_inner</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">.1</span></a> (<a class="idref" href="HoTT.Spaces.No.Addition.html#yL"><span class="id" title="variable">yL</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a>)<a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">).1</span></a>)<br>
                : <a class="idref" href="HoTT.Spaces.No.Addition.html#L''"><span class="id" title="variable">L''</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a> <span class="id" title="tactic">in</span><br>
      <span class="id" title="keyword">let</span> <span class="id" title="var">zR</span> := <a class="idref" href="HoTT.Types.Sum.html#sum_ind"><span class="id" title="definition">sum_ind</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a>)<br>
                        (<span class="id" title="keyword">fun</span> <span class="id" title="var">r</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.xR_plus"><span class="id" title="variable">xR_plus</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">{{</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#yL"><span class="id" title="variable">yL</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">|</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#yR"><span class="id" title="variable">yR</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">//</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#ycut"><span class="id" title="variable">ycut</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">}}</span></a>)<br>
                        (<span class="id" title="keyword">fun</span> <span class="id" title="var">r</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#plus_inner"><span class="id" title="definition">plus_inner</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">.1</span></a> (<a class="idref" href="HoTT.Spaces.No.Addition.html#yR"><span class="id" title="variable">yR</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a>)<a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">).1</span></a>)<br>
                : <a class="idref" href="HoTT.Spaces.No.Addition.html#R''"><span class="id" title="variable">R''</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a> <span class="id" title="tactic">in</span><br>
      <span class="id" title="keyword">let</span> <span class="id" title="var">Sz</span> := <a class="idref" href="HoTT.Spaces.No.Addition.html#sum_options"><span class="id" title="projection">sum_options</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.L"><span class="id" title="variable">L</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner.R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#L'"><span class="id" title="variable">L'</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#R'"><span class="id" title="variable">R'</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="tactic">in</span><br>
      <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a> <span class="id" title="var">zcut</span> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><span class="id" title="var">l</span>:<a class="idref" href="HoTT.Spaces.No.Addition.html#L''"><span class="id" title="variable">L''</span></a>) (<span class="id" title="var">r</span>:<a class="idref" href="HoTT.Spaces.No.Addition.html#R''"><span class="id" title="variable">R''</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#zL"><span class="id" title="variable">zL</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#zR"><span class="id" title="variable">zR</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a><br>
        <a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#plus_inner"><span class="id" title="definition">plus_inner</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">.1</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">{{</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#yL"><span class="id" title="variable">yL</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">|</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#yR"><span class="id" title="variable">yR</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">//</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#ycut"><span class="id" title="variable">ycut</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">}}</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">(</span></a>@<a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.No_cut"><span class="id" title="definition">No_cut</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#Sz"><span class="id" title="variable">Sz</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#zL"><span class="id" title="variable">zL</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#zR"><span class="id" title="variable">zR</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#zcut"><span class="id" title="variable">zcut</span></a><a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(70, '0_3_11');
      "><br>
    <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(71, '0_3_11');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_11"><pre><span></span></pre></div>
<div class="doc" scenenumber="13">
Now we tell Coq that we want the equality to be definitional, and let it figure out what the proof of cut-ness has to be. 
</div>
<div scenenumber="15" class="code">
<span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(75, '0_3_15');
      ">
      <span class="id" title="tactic">eexists</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(76, '0_3_15');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_15"><pre><span></span></pre></div>
<div class="doc" scenenumber="17">
Adding <span class="inlinecode"><span class="id" title="var">rel_hnf</span></span> here speeds things up considerably, possibly because it puts the terms in a form where the evar can be instantiated without unfolding or reduction, preventing backtracking across the evar instantiation. 
</div>
<div scenenumber="19" class="code">
<span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(82, '0_3_19');
      ">
      <span class="id" title="var">rel_hnf</span>. </span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(83, '0_3_19');
      "><span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(84, '0_3_19');
      "><br>
    <span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(85, '0_3_19');
      "><br>
<br>
  <span class="id" title="keyword">End</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.Inner"><span class="id" title="section">Inner</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(86, '0_3_19');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="plus_outer"><span class="id" title="definition">plus_outer</span></a><br>
  : <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a> <span class="id" title="var">f</span> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>} <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a> <span class="id" title="var">g</span> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>} <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>} <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a><br>
                  <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#b0ffa48971baa6e5913c7f1eea9baaf6"><span class="id" title="notation">≤</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#b0ffa48971baa6e5913c7f1eea9baaf6"><span class="id" title="notation">≤</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a><br>
                  <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a><br>
      <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#b0ffa48971baa6e5913c7f1eea9baaf6"><span class="id" title="notation">≤</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">z</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#z"><span class="id" title="variable">z</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#b0ffa48971baa6e5913c7f1eea9baaf6"><span class="id" title="notation">≤</span></a> <a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#z"><span class="id" title="variable">z</span></a><a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a><br>
      <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">z</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#z"><span class="id" title="variable">z</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#z"><span class="id" title="variable">z</span></a><a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(87, '0_3_19');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(88, '0_3_19');
      "><br>
    <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#No_rec_package"><span class="id" title="definition">No_rec_package</span></a><br>
              <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><span class="id" title="var">g</span> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a><br>
                <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#b0ffa48971baa6e5913c7f1eea9baaf6"><span class="id" title="notation">≤</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#b0ffa48971baa6e5913c7f1eea9baaf6"><span class="id" title="notation">≤</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a><br>
                <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a><br>
              (<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> <span class="id" title="var">h</span> ⇒ <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">.1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#b0ffa48971baa6e5913c7f1eea9baaf6"><span class="id" title="notation">≤</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">.1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a>)<br>
              (<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> <span class="id" title="var">h</span> ⇒ <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">.1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">.1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a>)<br>
              (<span class="id" title="keyword">fun</span> <span class="id" title="var">L</span> <span class="id" title="var">R</span> <span class="id" title="var">Sx</span> <span class="id" title="var">xL</span> <span class="id" title="var">xR</span> <span class="id" title="var">xcut</span> <span class="id" title="var">xL_plus</span> <span class="id" title="var">xR_plus</span> <span class="id" title="var">xL_lt_xR_plus</span> ⇒<br>
                 <span class="id" title="keyword">let</span> <span class="id" title="var">g</span> := <a class="idref" href="HoTT.Spaces.No.Addition.html#plus_inner"><span class="id" title="definition">plus_inner</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#xL_plus"><span class="id" title="variable">xL_plus</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#xR_plus"><span class="id" title="variable">xR_plus</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#xL_lt_xR_plus"><span class="id" title="variable">xL_lt_xR_plus</span></a> <span class="id" title="tactic">in</span><br>
                 <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">((</span></a><span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">.1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">).1</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#g"><span class="id" title="variable">g</span></a><a class="idref" href="HoTT.Basics.Overture.html#dec9bdefe956e49d73ffc4a7400937db"><span class="id" title="notation">.2</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">))</span></a>)<br>
               <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(89, '0_3_19');
      "><br>
    - <span class="id" title="tactic">abstract</span> (<br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">g</span> ?] [<span class="id" title="var">h</span> ?] <span class="id" title="var">p</span> <span class="id" title="var">q</span>;<br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Sigma.html#path_sigma_hprop"><span class="id" title="definition">path_sigma_hprop</span></a>; <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> *;<br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Arrow.html#path_arrow"><span class="id" title="definition">path_arrow</span></a>; <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>;<br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.path_No"><span class="id" title="axiom">path_No</span></a>; [ <span class="id" title="tactic">apply</span> <span class="id" title="var">p</span> | <span class="id" title="tactic">apply</span> <span class="id" title="var">q</span> ] ).</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(90, '0_3_19');
      "><br>
    - <span class="id" title="tactic">abstract</span> (<br>
      <span class="id" title="tactic">intros</span> <span class="id" title="var">L</span> <span class="id" title="var">R</span> ? <span class="id" title="var">xL</span> <span class="id" title="var">xR</span> <span class="id" title="var">xcut</span> <span class="id" title="var">xL_plus</span> <span class="id" title="var">xR_plus</span> <span class="id" title="var">xL_lt_xR_plus</span><br>
           <span class="id" title="var">L'</span> <span class="id" title="var">R'</span> ? <span class="id" title="var">yL</span> <span class="id" title="var">yR</span> <span class="id" title="var">ycut</span> <span class="id" title="var">yL_plus</span> <span class="id" title="var">yR_plus</span> <span class="id" title="var">yL_lt_yR_plus</span>;<br>
      <span class="id" title="tactic">intros</span> <span class="id" title="var">xL_lt_y</span> <span class="id" title="var">xL_lt_y_plus</span> <span class="id" title="var">x_lt_yR</span> <span class="id" title="var">x_lt_yR_plus</span> <span class="id" title="var">z</span>;<br>
      <span class="id" title="tactic">lazy</span> <span class="id" title="keyword">beta</span> <span class="id" title="keyword">zeta</span> <span class="id" title="tactic">in</span> *; <span class="id" title="var">cbn</span> [<span class="id" title="var">pr1</span>] <span class="id" title="tactic">in</span> *;<br>
      <span class="id" title="tactic">pattern</span> <span class="id" title="var">z</span>; <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#No_ind_hprop"><span class="id" title="definition">No_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">z</span>);<br>
      <span class="id" title="tactic">intros</span> <span class="id" title="var">L''</span> <span class="id" title="var">R''</span> ? <span class="id" title="var">zL</span> <span class="id" title="var">zR</span> <span class="id" title="var">zcut</span> <span class="id" title="var">x_le_y_plus_zL</span> <span class="id" title="var">x_le_y_plus_zR</span>;<br>
      <span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.Spaces.No.Addition.html#plus_inner_cut"><span class="id" title="definition">plus_inner_cut</span></a> <span class="id" title="var">xL_plus</span> <span class="id" title="var">xR_plus</span> <span class="id" title="var">xL_lt_xR_plus</span><br>
                               <span class="id" title="var">zL</span> <span class="id" title="var">zR</span> <span class="id" title="var">zcut</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">xzcut</span> <span class="id" title="var">p</span>]; <span class="id" title="tactic">rewrite</span> <span class="id" title="var">p</span>;<br>
      <span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.Spaces.No.Addition.html#plus_inner_cut"><span class="id" title="definition">plus_inner_cut</span></a> <span class="id" title="var">yL_plus</span> <span class="id" title="var">yR_plus</span> <span class="id" title="var">yL_lt_yR_plus</span><br>
                               <span class="id" title="var">zL</span> <span class="id" title="var">zR</span> <span class="id" title="var">zcut</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">yzcut</span> <span class="id" title="var">q</span>];<span class="id" title="tactic">rewrite</span> <span class="id" title="var">q</span>;<br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.le_lr"><span class="id" title="definition">le_lr</span></a>; [ <span class="id" title="tactic">intros</span> [<span class="id" title="var">l</span>|<span class="id" title="var">l</span>] | <span class="id" title="tactic">intros</span> [<span class="id" title="var">r</span>|<span class="id" title="var">r</span>] ];<br>
      [ </span>
</div>
<div class="goal" id="goal0_3_19"><pre><span></span></pre></div>
<div class="doc" scenenumber="21">
x^L + z &lt; y + z 
</div>
<div scenenumber="23" class="code"><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(94, '0_3_23');
      ">
        <span class="id" title="tactic">specialize</span> (<span class="id" title="var">xL_lt_y_plus</span> <span class="id" title="var">l</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">{{</span></a> <span class="id" title="var">zL</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">|</span></a> <span class="id" title="var">zR</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">//</span></a> <span class="id" title="var">zcut</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">}}</span></a>);<br>
        <span class="id" title="tactic">rewrite</span> <span class="id" title="var">q</span> <span class="id" title="tactic">in</span> <span class="id" title="var">xL_lt_y_plus</span>;<br>
        <span class="id" title="tactic">exact</span> <span class="id" title="var">xL_lt_y_plus</span><br>
      | </span></div>
<div class="goal" id="goal0_3_23"><pre><span></span></pre></div>
<div class="doc" scenenumber="25">
x + z^L &lt; y + z 
</div>
<div scenenumber="27" class="code"><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(98, '0_3_27');
      ">
        <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#le_lt_trans"><span class="id" title="lemma">le_lt_trans</span></a> (<span class="id" title="var">x_le_y_plus_zL</span> <span class="id" title="var">l</span>) <span class="id" title="var">_</span>);<br>
        <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#lt_lopt"><span class="id" title="lemma">lt_lopt</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <span class="id" title="var">l</span>))<br>
      | </span></div>
<div class="goal" id="goal0_3_27"><pre><span></span></pre></div>
<div class="doc" scenenumber="29">
x + z &lt; y^R + z 
</div>
<div scenenumber="31" class="code"><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(102, '0_3_31');
      ">
        <span class="id" title="tactic">specialize</span> (<span class="id" title="var">x_lt_yR_plus</span> <span class="id" title="var">r</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">{{</span></a> <span class="id" title="var">zL</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">|</span></a> <span class="id" title="var">zR</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">//</span></a> <span class="id" title="var">zcut</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">}}</span></a>);<br>
        <span class="id" title="tactic">rewrite</span> <span class="id" title="var">p</span> <span class="id" title="tactic">in</span> <span class="id" title="var">x_lt_yR_plus</span>;<br>
        <span class="id" title="tactic">exact</span> <span class="id" title="var">x_lt_yR_plus</span><br>
      | </span></div>
<div class="goal" id="goal0_3_31"><pre><span></span></pre></div>
<div class="doc" scenenumber="33">
x + z &lt; y + z^R 
</div>
<div scenenumber="35" class="code">
<span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(106, '0_3_35');
      ">
        <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#lt_le_trans"><span class="id" title="lemma">lt_le_trans</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">x_le_y_plus_zR</span> <span class="id" title="var">r</span>));<br>
        <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#lt_ropt"><span class="id" title="lemma">lt_ropt</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <span class="id" title="var">r</span>)) ]).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(107, '0_3_35');
      "><br>
    - <span class="id" title="tactic">abstract</span> (<br>
      <span class="id" title="tactic">intros</span> <span class="id" title="var">L</span> <span class="id" title="var">R</span> ? <span class="id" title="var">xL</span> <span class="id" title="var">xR</span> <span class="id" title="var">xcut</span> <span class="id" title="var">xL_plus</span> <span class="id" title="var">xR_plus</span> <span class="id" title="var">xL_lt_xR_plus</span><br>
             <span class="id" title="var">L'</span> <span class="id" title="var">R'</span> ? <span class="id" title="var">yL</span> <span class="id" title="var">yR</span> <span class="id" title="var">ycut</span> <span class="id" title="var">yL_plus</span> <span class="id" title="var">yR_plus</span> <span class="id" title="var">yL_lt_yR_plus</span>;<br>
      <span class="id" title="tactic">intros</span> <span class="id" title="var">l</span> <span class="id" title="var">x_le_yL</span> <span class="id" title="var">x_le_yL_plus</span> <span class="id" title="var">z</span>;<br>
      <span class="id" title="tactic">lazy</span> <span class="id" title="keyword">beta</span> <span class="id" title="keyword">zeta</span> <span class="id" title="tactic">in</span> *; <span class="id" title="var">cbn</span> [<span class="id" title="var">pr1</span>] <span class="id" title="tactic">in</span> *;<br>
      <span class="id" title="tactic">pattern</span> <span class="id" title="var">z</span>; <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#No_ind_hprop"><span class="id" title="definition">No_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">z</span>);<br>
      <span class="id" title="tactic">intros</span> <span class="id" title="var">L''</span> <span class="id" title="var">R''</span> ? <span class="id" title="var">zL</span> <span class="id" title="var">zR</span> <span class="id" title="var">zcut</span> <span class="id" title="var">x_le_y_plus_zL</span> <span class="id" title="var">x_le_y_plus_zR</span>;<br>
      <span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.Spaces.No.Addition.html#plus_inner_cut"><span class="id" title="definition">plus_inner_cut</span></a> <span class="id" title="var">xL_plus</span> <span class="id" title="var">xR_plus</span> <span class="id" title="var">xL_lt_xR_plus</span><br>
                               <span class="id" title="var">zL</span> <span class="id" title="var">zR</span> <span class="id" title="var">zcut</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">xzcut</span> <span class="id" title="var">p</span>]; <span class="id" title="tactic">rewrite</span> <span class="id" title="var">p</span>;<br>
      <span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.Spaces.No.Addition.html#plus_inner_cut"><span class="id" title="definition">plus_inner_cut</span></a> <span class="id" title="var">yL_plus</span> <span class="id" title="var">yR_plus</span> <span class="id" title="var">yL_lt_yR_plus</span><br>
                               <span class="id" title="var">zL</span> <span class="id" title="var">zR</span> <span class="id" title="var">zcut</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">yzcut</span> <span class="id" title="var">q</span>];<span class="id" title="tactic">rewrite</span> <span class="id" title="var">q</span>;<br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#le_lt_trans"><span class="id" title="lemma">le_lt_trans</span></a> (<span class="id" title="var">x_le_yL_plus</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">{{</span></a> <span class="id" title="var">zL</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">|</span></a> <span class="id" title="var">zR</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">//</span></a> <span class="id" title="var">zcut</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">}}</span></a>) <span class="id" title="var">_</span>);<br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#lt_lopt"><span class="id" title="lemma">lt_lopt</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">l</span>)) ).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(108, '0_3_35');
      "><br>
    - <span class="id" title="tactic">abstract</span> (<br>
      <span class="id" title="tactic">intros</span> <span class="id" title="var">L</span> <span class="id" title="var">R</span> ? <span class="id" title="var">xL</span> <span class="id" title="var">xR</span> <span class="id" title="var">xcut</span> <span class="id" title="var">xL_plus</span> <span class="id" title="var">xR_plus</span> <span class="id" title="var">xL_lt_xR_plus</span><br>
             <span class="id" title="var">L'</span> <span class="id" title="var">R'</span> ? <span class="id" title="var">yL</span> <span class="id" title="var">yR</span> <span class="id" title="var">ycut</span> <span class="id" title="var">yL_plus</span> <span class="id" title="var">yR_plus</span> <span class="id" title="var">yL_lt_yR_plus</span>;<br>
      <span class="id" title="tactic">intros</span> <span class="id" title="var">r</span> <span class="id" title="var">xR_le_y</span> <span class="id" title="var">xR_le_y_plus</span> <span class="id" title="var">z</span>;<br>
      <span class="id" title="tactic">lazy</span> <span class="id" title="keyword">beta</span> <span class="id" title="keyword">zeta</span> <span class="id" title="tactic">in</span> *; <span class="id" title="var">cbn</span> [<span class="id" title="var">pr1</span>] <span class="id" title="tactic">in</span> *;<br>
      <span class="id" title="tactic">pattern</span> <span class="id" title="var">z</span>; <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#No_ind_hprop"><span class="id" title="definition">No_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">z</span>);<br>
      <span class="id" title="tactic">intros</span> <span class="id" title="var">L''</span> <span class="id" title="var">R''</span> ? <span class="id" title="var">zL</span> <span class="id" title="var">zR</span> <span class="id" title="var">zcut</span> <span class="id" title="var">x_le_y_plus_zL</span> <span class="id" title="var">x_le_y_plus_zR</span>;<br>
      <span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.Spaces.No.Addition.html#plus_inner_cut"><span class="id" title="definition">plus_inner_cut</span></a> <span class="id" title="var">xL_plus</span> <span class="id" title="var">xR_plus</span> <span class="id" title="var">xL_lt_xR_plus</span><br>
                               <span class="id" title="var">zL</span> <span class="id" title="var">zR</span> <span class="id" title="var">zcut</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">xzcut</span> <span class="id" title="var">p</span>]; <span class="id" title="tactic">rewrite</span> <span class="id" title="var">p</span>;<br>
      <span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.Spaces.No.Addition.html#plus_inner_cut"><span class="id" title="definition">plus_inner_cut</span></a> <span class="id" title="var">yL_plus</span> <span class="id" title="var">yR_plus</span> <span class="id" title="var">yL_lt_yR_plus</span><br>
                               <span class="id" title="var">zL</span> <span class="id" title="var">zR</span> <span class="id" title="var">zcut</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">yzcut</span> <span class="id" title="var">q</span>];<span class="id" title="tactic">rewrite</span> <span class="id" title="var">q</span>;<br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#lt_le_trans"><span class="id" title="lemma">lt_le_trans</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">xR_le_y_plus</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">{{</span></a> <span class="id" title="var">zL</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">|</span></a> <span class="id" title="var">zR</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">//</span></a> <span class="id" title="var">zcut</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">}}</span></a>));<br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#lt_ropt"><span class="id" title="lemma">lt_ropt</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">r</span>)) ).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(109, '0_3_35');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(110, '0_3_35');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="plus"><span class="id" title="definition">plus</span></a> (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a>) : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a><br>
    := <a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#plus_outer"><span class="id" title="definition">plus_outer</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">.1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(111, '0_3_35');
      "><br>
<br>
  <span class="id" title="keyword">Infix</span> <a name="d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">"</span></a>+" := <a class="idref" href="HoTT.Spaces.No.Addition.html#plus"><span class="id" title="definition">plus</span></a> : <span class="id" title="var">surreal_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(112, '0_3_35');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="plus_le_l"><span class="id" title="definition">plus_le_l</span></a> (<span class="id" title="var">x</span> <span class="id" title="var">x'</span> <span class="id" title="var">y</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>}) (<span class="id" title="var">p</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#b0ffa48971baa6e5913c7f1eea9baaf6"><span class="id" title="notation">≤</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x'"><span class="id" title="variable">x'</span></a>)<br>
  : <a class="idref" href="HoTT.Spaces.No.Core.html#b0ffa48971baa6e5913c7f1eea9baaf6"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Spaces.No.Core.html#b0ffa48971baa6e5913c7f1eea9baaf6"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#b0ffa48971baa6e5913c7f1eea9baaf6"><span class="id" title="notation">≤</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#b0ffa48971baa6e5913c7f1eea9baaf6"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#x'"><span class="id" title="variable">x'</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Spaces.No.Core.html#b0ffa48971baa6e5913c7f1eea9baaf6"><span class="id" title="notation">)</span></a><br>
    := <a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> (<a class="idref" href="HoTT.Spaces.No.Addition.html#plus_outer"><span class="id" title="definition">plus_outer</span></a><a class="idref" href="HoTT.Basics.Overture.html#dec9bdefe956e49d73ffc4a7400937db"><span class="id" title="notation">.2</span></a>) <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x'"><span class="id" title="variable">x'</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(113, '0_3_35');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="plus_lt_l"><span class="id" title="definition">plus_lt_l</span></a> (<span class="id" title="var">x</span> <span class="id" title="var">x'</span> <span class="id" title="var">y</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>}) (<span class="id" title="var">p</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x'"><span class="id" title="variable">x'</span></a>)<br>
  : <a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#x'"><span class="id" title="variable">x'</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">)</span></a><br>
    := <a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> (<a class="idref" href="HoTT.Spaces.No.Addition.html#plus_outer"><span class="id" title="definition">plus_outer</span></a><a class="idref" href="HoTT.Basics.Overture.html#dec9bdefe956e49d73ffc4a7400937db"><span class="id" title="notation">.2</span></a>) <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x'"><span class="id" title="variable">x'</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(114, '0_3_35');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="plus_le_r"><span class="id" title="definition">plus_le_r</span></a> (<span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">y'</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>}) (<span class="id" title="var">p</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#b0ffa48971baa6e5913c7f1eea9baaf6"><span class="id" title="notation">≤</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y'"><span class="id" title="variable">y'</span></a>)<br>
  : <a class="idref" href="HoTT.Spaces.No.Core.html#b0ffa48971baa6e5913c7f1eea9baaf6"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Spaces.No.Core.html#b0ffa48971baa6e5913c7f1eea9baaf6"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#b0ffa48971baa6e5913c7f1eea9baaf6"><span class="id" title="notation">≤</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#b0ffa48971baa6e5913c7f1eea9baaf6"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y'"><span class="id" title="variable">y'</span></a><a class="idref" href="HoTT.Spaces.No.Core.html#b0ffa48971baa6e5913c7f1eea9baaf6"><span class="id" title="notation">)</span></a><br>
    := <a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.Basics.Overture.html#dec9bdefe956e49d73ffc4a7400937db"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#plus_outer"><span class="id" title="definition">plus_outer</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">.1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#dec9bdefe956e49d73ffc4a7400937db"><span class="id" title="notation">).2</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y'"><span class="id" title="variable">y'</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#p"><span class="id" title="variable">p</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(115, '0_3_35');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="plus_lt_r"><span class="id" title="definition">plus_lt_r</span></a> (<span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">y'</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>}) (<span class="id" title="var">p</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y'"><span class="id" title="variable">y'</span></a>)<br>
  : <a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y'"><span class="id" title="variable">y'</span></a><a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">)</span></a><br>
    := <a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.Basics.Overture.html#dec9bdefe956e49d73ffc4a7400937db"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#plus_outer"><span class="id" title="definition">plus_outer</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">.1</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#dec9bdefe956e49d73ffc4a7400937db"><span class="id" title="notation">).2</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y'"><span class="id" title="variable">y'</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#p"><span class="id" title="variable">p</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(116, '0_3_35');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_35"><pre><span></span></pre></div>
<div class="doc" scenenumber="37">
See the remarks above <span class="inlinecode"><a class="idref" href="HoTT.Spaces.No.Addition.html#plus_inner_cut"><span class="id" title="definition">plus_inner_cut</span></a></span> to explain the type of this lemma. 
</div>
<div scenenumber="39" class="code">
<span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(122, '0_3_39');
      ">
  <span class="id" title="keyword">Definition</span> <a name="plus_cut"><span class="id" title="definition">plus_cut</span></a><br>
             {<span class="id" title="var">L</span> <span class="id" title="var">R</span> : <span class="id" title="var">Type@</span>{<span class="id" title="var">i</span>} } {<span class="id" title="var">Sx</span> : <a class="idref" href="HoTT.Spaces.No.Core.html#InSort"><span class="id" title="class">InSort@</span></a>{<span class="id" title="var">i</span>} <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.S"><span class="id" title="variable">S</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#L"><span class="id" title="variable">L</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#R"><span class="id" title="variable">R</span></a>}<br>
             (<span class="id" title="var">xL</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#L"><span class="id" title="variable">L</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>}) (<span class="id" title="var">xR</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>})<br>
             (<span class="id" title="var">xcut</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><span class="id" title="var">l</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#L"><span class="id" title="variable">L</span></a>) (<span class="id" title="var">r</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#R"><span class="id" title="variable">R</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#xL"><span class="id" title="variable">xL</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#xR"><span class="id" title="variable">xR</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a>)<br>
             {<span class="id" title="var">L'</span> <span class="id" title="var">R'</span> : <span class="id" title="var">Type@</span>{<span class="id" title="var">i</span>} } {<span class="id" title="var">Sy</span> : <a class="idref" href="HoTT.Spaces.No.Core.html#InSort"><span class="id" title="class">InSort@</span></a>{<span class="id" title="var">i</span>} <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.S"><span class="id" title="variable">S</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#L'"><span class="id" title="variable">L'</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#R'"><span class="id" title="variable">R'</span></a>}<br>
             (<span class="id" title="var">yL</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#L'"><span class="id" title="variable">L'</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>}) (<span class="id" title="var">yR</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#R'"><span class="id" title="variable">R'</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No@</span></a>{<span class="id" title="var">i</span>})<br>
             (<span class="id" title="var">ycut</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><span class="id" title="var">l</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#L'"><span class="id" title="variable">L'</span></a>) (<span class="id" title="var">r</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#R'"><span class="id" title="variable">R'</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#yL"><span class="id" title="variable">yL</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#yR"><span class="id" title="variable">yR</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a>)<br>
  : <span class="id" title="keyword">let</span> <span class="id" title="var">L''</span> := (<a class="idref" href="HoTT.Spaces.No.Addition.html#L"><span class="id" title="variable">L</span></a> <a class="idref" href="Coq.Init.Datatypes.html#e03f39daf98516fa530d3f6f5a1b4d92"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#L'"><span class="id" title="variable">L'</span></a>)%<span class="id" title="keyword">type</span> <span class="id" title="tactic">in</span><br>
    <span class="id" title="keyword">let</span> <span class="id" title="var">R''</span> := (<a class="idref" href="HoTT.Spaces.No.Addition.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Datatypes.html#e03f39daf98516fa530d3f6f5a1b4d92"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#R'"><span class="id" title="variable">R'</span></a>)%<span class="id" title="keyword">type</span> <span class="id" title="tactic">in</span><br>
    <span class="id" title="keyword">let</span> <span class="id" title="var">x</span> := <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">{{</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#xL"><span class="id" title="variable">xL</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">|</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#xR"><span class="id" title="variable">xR</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">//</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#xcut"><span class="id" title="variable">xcut</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">}}</span></a> <span class="id" title="tactic">in</span><br>
    <span class="id" title="keyword">let</span> <span class="id" title="var">y</span> := <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">{{</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#yL"><span class="id" title="variable">yL</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">|</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#yR"><span class="id" title="variable">yR</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">//</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#ycut"><span class="id" title="variable">ycut</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">}}</span></a> <span class="id" title="tactic">in</span><br>
    <span class="id" title="keyword">let</span> <span class="id" title="var">zL</span> := <a class="idref" href="HoTT.Types.Sum.html#sum_ind"><span class="id" title="definition">sum_ind</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a>)<br>
                      (<span class="id" title="keyword">fun</span> <span class="id" title="var">l</span> ⇒ <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#xL"><span class="id" title="variable">xL</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">l</span> ⇒ <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#yL"><span class="id" title="variable">yL</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">)</span></a>)<br>
              : <a class="idref" href="HoTT.Spaces.No.Addition.html#L''"><span class="id" title="variable">L''</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a> <span class="id" title="tactic">in</span><br>
    <span class="id" title="keyword">let</span> <span class="id" title="var">zR</span> := <a class="idref" href="HoTT.Types.Sum.html#sum_ind"><span class="id" title="definition">sum_ind</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a>)<br>
                      (<span class="id" title="keyword">fun</span> <span class="id" title="var">r</span> ⇒ <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#xR"><span class="id" title="variable">xR</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">r</span> ⇒ <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#yR"><span class="id" title="variable">yR</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">)</span></a>)<br>
              : <a class="idref" href="HoTT.Spaces.No.Addition.html#R''"><span class="id" title="variable">R''</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a> <span class="id" title="tactic">in</span><br>
    <span class="id" title="keyword">let</span> <span class="id" title="var">Sz</span> := <a class="idref" href="HoTT.Spaces.No.Addition.html#sum_options"><span class="id" title="projection">sum_options</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#L"><span class="id" title="variable">L</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#L'"><span class="id" title="variable">L'</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#R'"><span class="id" title="variable">R'</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="tactic">in</span><br>
    <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a> <span class="id" title="var">zcut</span> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><span class="id" title="var">l</span>:<a class="idref" href="HoTT.Spaces.No.Addition.html#L''"><span class="id" title="variable">L''</span></a>) (<span class="id" title="var">r</span>:<a class="idref" href="HoTT.Spaces.No.Addition.html#R''"><span class="id" title="variable">R''</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#zL"><span class="id" title="variable">zL</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#7b286fc2538c11922daa72f22a5b5b6a"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#zR"><span class="id" title="variable">zR</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a><br>
      <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> @<a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.No_cut"><span class="id" title="definition">No_cut</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#Sz"><span class="id" title="variable">Sz</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#zL"><span class="id" title="variable">zL</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#zR"><span class="id" title="variable">zR</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#zcut"><span class="id" title="variable">zcut</span></a> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a><br>
    := <a class="idref" href="HoTT.Spaces.No.Addition.html#plus_inner_cut"><span class="id" title="definition">plus_inner_cut</span></a> (<span class="id" title="var">Sx</span> := <a class="idref" href="HoTT.Spaces.No.Addition.html#Sx"><span class="id" title="variable">Sx</span></a>)<br>
         (<span class="id" title="keyword">fun</span> <span class="id" title="var">l</span> ⇒ <a class="idref" href="HoTT.Spaces.No.Addition.html#plus_outer"><span class="id" title="definition">plus_outer</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">.1</span></a> (<a class="idref" href="HoTT.Spaces.No.Addition.html#xL"><span class="id" title="variable">xL</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a>))<br>
         (<span class="id" title="keyword">fun</span> <span class="id" title="var">r</span> ⇒ <a class="idref" href="HoTT.Spaces.No.Addition.html#plus_outer"><span class="id" title="definition">plus_outer</span></a><a class="idref" href="HoTT.Basics.Overture.html#a0d4c290984547f24aacc208636427e2"><span class="id" title="notation">.1</span></a> (<a class="idref" href="HoTT.Spaces.No.Addition.html#xR"><span class="id" title="variable">xR</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a>))<br>
         (<span class="id" title="keyword">fun</span> <span class="id" title="var">l</span> <span class="id" title="var">r</span> ⇒ <a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#plus_outer"><span class="id" title="definition">plus_outer</span></a><a class="idref" href="HoTT.Basics.Overture.html#dec9bdefe956e49d73ffc4a7400937db"><span class="id" title="notation">.2</span></a> (<a class="idref" href="HoTT.Spaces.No.Addition.html#xL"><span class="id" title="variable">xL</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a>) (<a class="idref" href="HoTT.Spaces.No.Addition.html#xR"><span class="id" title="variable">xR</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a>) (<a class="idref" href="HoTT.Spaces.No.Addition.html#xcut"><span class="id" title="variable">xcut</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#r"><span class="id" title="variable">r</span></a>))<br>
         <a class="idref" href="HoTT.Spaces.No.Addition.html#yL"><span class="id" title="variable">yL</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#yR"><span class="id" title="variable">yR</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#ycut"><span class="id" title="variable">ycut</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(123, '0_3_39');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_39"><pre><span></span></pre></div>
<div class="doc" scenenumber="41">
Because the conclusion of <span class="inlinecode"><a class="idref" href="HoTT.Spaces.No.Addition.html#plus_cut"><span class="id" title="definition">plus_cut</span></a></span> is a sigma-type whose second component is the real equality we want to rewrite along, in order to rewrite along it we have to first destruct it.  This tactic takes care of that for us. 
</div>
<div scenenumber="43" class="code">
<span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(129, '0_3_43');
      ">
  <span class="id" title="keyword">Ltac</span> <span class="id" title="var">do_plus_cut</span> :=<br>
    <span class="id" title="tactic">repeat</span> <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br>
    | [ |- <span class="id" title="keyword">context</span> <span class="id" title="var">ctx</span> [ <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">{{</span></a> ?<span class="id" title="var">xL</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">|</span></a> ?<span class="id" title="var">xR</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">//</span></a> ?<span class="id" title="var">xcut</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">}}</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">{{</span></a> ?<span class="id" title="var">yL</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">|</span></a> ?<span class="id" title="var">yR</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">//</span></a> ?<span class="id" title="var">ycut</span> <a class="idref" href="HoTT.Spaces.No.Core.html#60f5fa9a81abf0771b48c56c465b1ec2"><span class="id" title="notation">}}</span></a> ] ] ⇒<br>
      <span class="id" title="keyword">let</span> <span class="id" title="var">xycut</span> := <span class="id" title="tactic">fresh</span> "cut" <span class="id" title="tactic">in</span><br>
      <span class="id" title="keyword">let</span> <span class="id" title="var">p</span> := <span class="id" title="tactic">fresh</span> "p" <span class="id" title="tactic">in</span><br>
      <span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.Spaces.No.Addition.html#plus_cut"><span class="id" title="definition">plus_cut</span></a> <span class="id" title="var">xL</span> <span class="id" title="var">xR</span> <span class="id" title="var">xcut</span> <span class="id" title="var">yL</span> <span class="id" title="var">yR</span> <span class="id" title="var">ycut</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">xycut</span> <span class="id" title="var">p</span>];<br>
        <span class="id" title="tactic">rewrite</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">clear</span> <span class="id" title="var">p</span><br>
    <span class="id" title="keyword">end</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(130, '0_3_43');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_43"><pre><span></span></pre></div>
<div class="doc" scenenumber="45">
Conway proves the basic properties of arithmetic using "one-line proofs".  We can't quite do them in one line of Ltac, but the following tactic does help a lot.  Note that it is specific to addition.  It requires the caller to specify the equivalences along which to identify the indexing types for the options, as well as a rewriting tactic for evaluating those equivalences on constructors.  Unfortunately, it doesn't usually manage to finish the whole proof, since in general it can't guess how to use the inductive hypotheses.  It's usually fairly easy to finish all the cases it leaves over, but we do generally have to refer by name to the inductive hypotheses that were automatically named by <span class="inlinecode"><span class="id" title="tactic">intros</span></span> here.  I haven't thought of a good solution to that. 
</div>
<div scenenumber="47" class="code">
<span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(136, '0_3_47');
      ">
  <span class="id" title="keyword">Local Opaque</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.No_cut"><span class="id" title="definition">No_cut</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#plus"><span class="id" title="definition">plus</span></a>.   <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Unset</span> <span class="id" title="var">Keyed</span> <span class="id" title="var">Unification</span>.   <span class="id" title="keyword">Tactic Notation</span> "one_line_proof" <span class="id" title="var">uconstr</span>(<span class="id" title="var">eL</span>) <span class="id" title="var">uconstr</span>(<span class="id" title="var">eR</span>) :=<br>
    <span class="id" title="tactic">unfold</span> <span class="id" title="var">No</span> <span class="id" title="tactic">in</span> *;<br>
    <span class="id" title="var">repeat_No_ind_hprop</span>;<br>
    <span class="id" title="var">do_plus_cut</span>;<br>
    <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#path_No_easy"><span class="id" title="definition">path_No_easy</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">eL</span> <span class="id" title="var">eR</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>);<br>
    <span class="id" title="tactic">intros</span>;<br>
    <span class="id" title="tactic">repeat</span> <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br>
           | [ <span class="id" title="var">H</span> : (?<span class="id" title="var">A</span> <a class="idref" href="Coq.Init.Datatypes.html#e03f39daf98516fa530d3f6f5a1b4d92"><span class="id" title="notation">+</span></a> ?<span class="id" title="var">B</span>)%<span class="id" title="keyword">type</span> |- <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span><br>
           <span class="id" title="keyword">end</span>;<br>
    <span class="id" title="tactic">repeat</span> <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br>
           | [ |- <span class="id" title="keyword">context</span>[@<a class="idref" href="HoTT.Basics.Overture.html#equiv_fun"><span class="id" title="projection">equiv_fun</span></a> ?<span class="id" title="var">A</span> ?<span class="id" title="var">B</span> ?<span class="id" title="var">e</span> ?<span class="id" title="var">v</span>] ]<br>
             ⇒ <br>
             <span class="id" title="tactic">first</span> [ <span class="id" title="keyword">let</span> <span class="id" title="var">unif</span> := <span class="id" title="keyword">constr</span>:(<a class="idref" href="HoTT.Basics.Overture.html#idpath"><span class="id" title="constructor">idpath</span></a> : <span class="id" title="var">e</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="var">eL</span>) <span class="id" title="tactic">in</span> <span class="id" title="tactic">idtac</span><br>
                   | <span class="id" title="keyword">let</span> <span class="id" title="var">unif</span> := <span class="id" title="keyword">constr</span>:(<a class="idref" href="HoTT.Basics.Overture.html#idpath"><span class="id" title="constructor">idpath</span></a> : <span class="id" title="var">e</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="var">eR</span>) <span class="id" title="tactic">in</span> <span class="id" title="tactic">idtac</span> ];<br>
             <br>
             <span class="id" title="keyword">let</span> <span class="id" title="var">ef</span> := <span class="id" title="keyword">constr</span>:(@<a class="idref" href="HoTT.Basics.Overture.html#equiv_fun"><span class="id" title="projection">equiv_fun</span></a> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">e</span> <span class="id" title="var">v</span>) <span class="id" title="tactic">in</span><br>
             <span class="id" title="keyword">let</span> <span class="id" title="var">ef'</span> := (<span class="id" title="tactic">eval</span> <span class="id" title="tactic">hnf</span> <span class="id" title="tactic">in</span> <span class="id" title="var">ef</span>) <span class="id" title="tactic">in</span><br>
             <span class="id" title="tactic">progress</span> <span class="id" title="tactic">change</span> <span class="id" title="var">ef</span> <span class="id" title="keyword">with</span> <span class="id" title="var">ef'</span><br>
           <span class="id" title="keyword">end</span>;<br>
    <span class="id" title="tactic">repeat</span> <span class="id" title="var">cbn</span> [<span class="id" title="var">sum_ind</span>];<br>
    <br>
    <span class="id" title="tactic">repeat</span> <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br>
           | [ |- ?<span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> ?<span class="id" title="var">x</span> ] ⇒ <span class="id" title="tactic">reflexivity</span><br>
           | [ |- ?<span class="id" title="var">a</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> ?<span class="id" title="var">a</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a><br>
           | [ |- <span class="id" title="var">_</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> ?<span class="id" title="var">a</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> ?<span class="id" title="var">a</span> ] ⇒ <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <span class="id" title="var">a</span>))<br>
           | [ <span class="id" title="var">e</span> : <a class="idref" href="HoTT.Basics.Overture.html#Empty"><span class="id" title="inductive">Empty</span></a> |- <span class="id" title="var">_</span> ] ⇒ <span class="id" title="tactic">elim</span> <span class="id" title="var">e</span><br>
           | [ <span class="id" title="var">IH</span> : (<a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">lr</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="var">_</span>) |- <span class="id" title="var">_</span> ]<br>
             ⇒ <span class="id" title="tactic">rewrite</span> <span class="id" title="var">IH</span>; <span class="id" title="tactic">clear</span> <span class="id" title="var">IH</span><br>
           | [ <span class="id" title="var">IH</span> : (<a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">lr</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <span class="id" title="var">_</span>) |- <span class="id" title="var">_</span> ]<br>
             ⇒ <span class="id" title="tactic">first</span> [ <span class="id" title="tactic">rewrite</span> <span class="id" title="var">IH</span> | <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">IH</span> ]; <span class="id" title="tactic">clear</span> <span class="id" title="var">IH</span><br>
           | [ <span class="id" title="var">IH</span> : (<a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">lr</span> (<span class="id" title="var">y</span> : <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.GenNo"><span class="id" title="record">GenNo</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <span class="id" title="var">_</span>) |- <span class="id" title="var">_</span> ]<br>
             ⇒ <span class="id" title="tactic">first</span> [ <span class="id" title="tactic">rewrite</span> <span class="id" title="var">IH</span> | <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">IH</span> ]; <span class="id" title="tactic">clear</span> <span class="id" title="var">IH</span><br>
           | [ <span class="id" title="var">IH</span> : (<a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">lr</span> (<span class="id" title="var">y</span> <span class="id" title="var">z</span> : <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.GenNo"><span class="id" title="record">GenNo</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <span class="id" title="var">_</span>) |- <span class="id" title="var">_</span> ]<br>
             ⇒ <span class="id" title="tactic">first</span> [ <span class="id" title="tactic">rewrite</span> <span class="id" title="var">IH</span> | <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">IH</span> ]; <span class="id" title="tactic">clear</span> <span class="id" title="var">IH</span><br>
           <span class="id" title="keyword">end</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(137, '0_3_47');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_47"><pre><span></span></pre></div>
<div class="doc" scenenumber="49">
At last we are ready to prove that the surreal numbers are a commutative monoid under addition. 
</div>
<div scenenumber="51" class="code">
<span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(141, '0_3_51');
      ">
<br>
  <span class="id" title="keyword">Theorem</span> <a name="plus_comm"><span class="id" title="lemma">plus_comm</span></a> (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a>) : <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(142, '0_3_51');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(143, '0_3_51');
      "><br>
    <span class="id" title="var">one_line_proof</span> (<a class="idref" href="HoTT.Types.Sum.html#equiv_sum_symm"><span class="id" title="definition">equiv_sum_symm</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) (<a class="idref" href="HoTT.Types.Sum.html#equiv_sum_symm"><span class="id" title="definition">equiv_sum_symm</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(144, '0_3_51');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(145, '0_3_51');
      "><br>
<br>
  <span class="id" title="keyword">Theorem</span> <a name="plus_assoc"><span class="id" title="lemma">plus_assoc</span></a> (<span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a>) : <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#z"><span class="id" title="variable">z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#z"><span class="id" title="variable">z</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(146, '0_3_51');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(147, '0_3_51');
      "><br>
    <span class="id" title="var">one_line_proof</span> (<a class="idref" href="HoTT.Types.Sum.html#equiv_sum_assoc"><span class="id" title="definition">equiv_sum_assoc</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) (<a class="idref" href="HoTT.Types.Sum.html#equiv_sum_assoc"><span class="id" title="definition">equiv_sum_assoc</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>);<br>
      <span class="id" title="var">one_line_proof</span> 1%<span class="id" title="var">equiv</span> 1%<span class="id" title="var">equiv</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(148, '0_3_51');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(149, '0_3_51');
      "><br>
<br>
  <span class="id" title="keyword">Theorem</span> <a name="plus_zero"><span class="id" title="lemma">plus_zero</span></a> (<span class="id" title="var">x</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a>) : <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#zero"><span class="id" title="definition">zero</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(150, '0_3_51');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(151, '0_3_51');
      "><br>
    <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Spaces.No.Core.html#zero"><span class="id" title="definition">zero</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(152, '0_3_51');
      "><br>
    <span class="id" title="var">one_line_proof</span> (<a class="idref" href="HoTT.Types.Sum.html#sum_empty_r"><span class="id" title="definition">sum_empty_r</span></a> <span class="id" title="var">_</span>) (<a class="idref" href="HoTT.Types.Sum.html#sum_empty_r"><span class="id" title="definition">sum_empty_r</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(153, '0_3_51');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(154, '0_3_51');
      "><br>
<br>
  <span class="id" title="keyword">Theorem</span> <a name="zero_plus"><span class="id" title="lemma">zero_plus</span></a> (<span class="id" title="var">x</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a>) : <a class="idref" href="HoTT.Spaces.No.Core.html#zero"><span class="id" title="definition">zero</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(155, '0_3_51');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(156, '0_3_51');
      "><br>
    <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Spaces.No.Core.html#zero"><span class="id" title="definition">zero</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(157, '0_3_51');
      "><br>
    <span class="id" title="var">one_line_proof</span> (<a class="idref" href="HoTT.Types.Sum.html#sum_empty_l"><span class="id" title="definition">sum_empty_l</span></a> <span class="id" title="var">_</span>) (<a class="idref" href="HoTT.Types.Sum.html#sum_empty_l"><span class="id" title="definition">sum_empty_l</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(158, '0_3_51');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(159, '0_3_51');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_51"><pre><span></span></pre></div>
<div class="doc" scenenumber="53">
If we also have negation, we can prove that it gives additive inverses, so that we have an abelian group. 
</div>
<div scenenumber="55" class="code">
<span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(163, '0_3_55');
      ">
  <span class="id" title="keyword">Context</span> `{<a class="idref" href="HoTT.Spaces.No.Negation.html#HasNegation"><span class="id" title="class">HasNegation</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.S"><span class="id" title="variable">S</span></a>}.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(164, '0_3_55');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="plus_negate"><span class="id" title="definition">plus_negate</span></a> (<span class="id" title="var">x</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a>) : <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Negation.html#negate"><span class="id" title="definition">negate</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Spaces.No.Core.html#zero"><span class="id" title="definition">zero</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(165, '0_3_55');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(166, '0_3_55');
      "><br>
    <span class="id" title="tactic">unfold</span> <span class="id" title="var">No</span> <span class="id" title="tactic">in</span> *;<br>
    <span class="id" title="var">repeat_No_ind_hprop</span>;<br>
    <span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.Spaces.No.Negation.html#negate_cut"><span class="id" title="definition">negate_cut</span></a> <span class="id" title="var">xL</span> <span class="id" title="var">xR</span> <span class="id" title="var">xcut</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">nxcut</span> <span class="id" title="var">p</span>];<br>
    <span class="id" title="tactic">rewrite</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">clear</span> <span class="id" title="var">p</span>;<br>
    <span class="id" title="var">do_plus_cut</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(167, '0_3_55');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.path_No"><span class="id" title="axiom">path_No</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(168, '0_3_55');
      "><br>
    - <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.le_lr"><span class="id" title="definition">le_lr</span></a>; [ <span class="id" title="tactic">intros</span> [<span class="id" title="var">l</span>|<span class="id" title="var">r</span>]; <span class="id" title="var">cbn</span> [<span class="id" title="var">sum_ind</span>] | <span class="id" title="tactic">intros</span> [] ].</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(169, '0_3_55');
      "><br>
      + <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Spaces.No.Core.html#zero"><span class="id" title="definition">zero</span></a> <span class="id" title="tactic">in</span> <span class="id" title="var">IHL</span>; <span class="id" title="tactic">rewrite</span> &lt;- (<span class="id" title="var">IHL</span> <span class="id" title="var">l</span>); <span class="id" title="tactic">clear</span> <span class="id" title="var">IHL</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(170, '0_3_55');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#plus_lt_r"><span class="id" title="definition">plus_lt_r</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(171, '0_3_55');
      "><br>
        <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#lt_ropt"><span class="id" title="lemma">lt_ropt</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">l</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(172, '0_3_55');
      "><br>
      + <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Spaces.No.Core.html#zero"><span class="id" title="definition">zero</span></a> <span class="id" title="tactic">in</span> <span class="id" title="var">IHR</span>; <span class="id" title="tactic">rewrite</span> &lt;- (<span class="id" title="var">IHR</span> <span class="id" title="var">r</span>); <span class="id" title="tactic">clear</span> <span class="id" title="var">IHR</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(173, '0_3_55');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#plus_lt_l"><span class="id" title="definition">plus_lt_l</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(174, '0_3_55');
      "><br>
        <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#lt_ropt"><span class="id" title="lemma">lt_ropt</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">r</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(175, '0_3_55');
      "><br>
    - <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Core.html#Surreals.le_lr"><span class="id" title="definition">le_lr</span></a>; [ <span class="id" title="tactic">intros</span> [] | <span class="id" title="tactic">intros</span> [<span class="id" title="var">r</span>|<span class="id" title="var">l</span>] ]; <span class="id" title="var">cbn</span> [<span class="id" title="var">sum_ind</span>].</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(176, '0_3_55');
      "><br>
      + <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Spaces.No.Core.html#zero"><span class="id" title="definition">zero</span></a> <span class="id" title="tactic">in</span> <span class="id" title="var">IHR</span>; <span class="id" title="tactic">rewrite</span> &lt;- (<span class="id" title="var">IHR</span> <span class="id" title="var">r</span>); <span class="id" title="tactic">clear</span> <span class="id" title="var">IHR</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(177, '0_3_55');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#plus_lt_r"><span class="id" title="definition">plus_lt_r</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(178, '0_3_55');
      "><br>
        <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#lt_lopt"><span class="id" title="lemma">lt_lopt</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">r</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(179, '0_3_55');
      "><br>
      + <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Spaces.No.Core.html#zero"><span class="id" title="definition">zero</span></a> <span class="id" title="tactic">in</span> <span class="id" title="var">IHL</span>; <span class="id" title="tactic">rewrite</span> &lt;- (<span class="id" title="var">IHL</span> <span class="id" title="var">l</span>); <span class="id" title="tactic">clear</span> <span class="id" title="var">IHL</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(180, '0_3_55');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#plus_lt_l"><span class="id" title="definition">plus_lt_l</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(181, '0_3_55');
      "><br>
        <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.No.Core.html#lt_lopt"><span class="id" title="lemma">lt_lopt</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">l</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(182, '0_3_55');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(183, '0_3_55');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="sub"><span class="id" title="definition">sub</span></a> (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a>) : <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition.No"><span class="id" title="variable">No</span></a> := <a class="idref" href="HoTT.Spaces.No.Addition.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.No.Negation.html#negate"><span class="id" title="definition">negate</span></a> <a class="idref" href="HoTT.Spaces.No.Addition.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Spaces.No.Addition.html#d21c1645827282d949c61e83d7a679f6"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(184, '0_3_55');
      "><br>
<br>
  <span class="id" title="keyword">Infix</span> <a name="fd5eeee08e33dbb0d05fd933a924f5e7"><span class="id" title="notation">"</span></a>-" := <a class="idref" href="HoTT.Spaces.No.Addition.html#sub"><span class="id" title="definition">sub</span></a> : <span class="id" title="var">surreal_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(185, '0_3_55');
      "><br>
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.Spaces.No.Addition.html#Addition"><span class="id" title="section">Addition</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(186, '0_3_55');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_55"><pre><span></span></pre></div>
</div>
<div id="footer" scenenumber="5" class="doc">
<hr>
<a href="index.html">Index</a><hr>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>
</div></body>
</html>
