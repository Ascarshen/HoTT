<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="coqdoc.css" type="text/css" rel="stylesheet">
<link href="proviola.css" type="text/css" rel="stylesheet">
<script type="text/javascript">
        var responses = new Array();

        function mouseover(id, scene) {
          set_response(get_response(id), scene);
        };

        function mouseout(scene) {
          set_response("", scene);
        };

        function set_array() {
          

            i = 0;
            data = "";
            responses[i]=data;
          

            i = 1;
            data = "";
            responses[i]=data;
          

            i = 2;
            data = "";
            responses[i]=data;
          

            i = 3;
            data = "";
            responses[i]=data;
          

            i = 4;
            data = "";
            responses[i]=data;
          

            i = 5;
            data = "";
            responses[i]=data;
          

            i = 6;
            data = "";
            responses[i]=data;
          

            i = 7;
            data = "";
            responses[i]=data;
          

            i = 8;
            data = "";
            responses[i]=data;
          

            i = 9;
            data = "";
            responses[i]=data;
          

            i = 10;
            data = "";
            responses[i]=data;
          

            i = 11;
            data = "";
            responses[i]=data;
          

            i = 12;
            data = "";
            responses[i]=data;
          

            i = 13;
            data = "";
            responses[i]=data;
          

            i = 14;
            data = "";
            responses[i]=data;
          

            i = 15;
            data = "";
            responses[i]=data;
          

            i = 16;
            data = "";
            responses[i]=data;
          

            i = 17;
            data = "";
            responses[i]=data;
          

            i = 18;
            data = "";
            responses[i]=data;
          

            i = 19;
            data = "";
            responses[i]=data;
          

            i = 20;
            data = "";
            responses[i]=data;
          

            i = 21;
            data = "";
            responses[i]=data;
          

            i = 22;
            data = "";
            responses[i]=data;
          

            i = 23;
            data = "";
            responses[i]=data;
          

            i = 24;
            data = "";
            responses[i]=data;
          

            i = 25;
            data = "";
            responses[i]=data;
          

            i = 26;
            data = "";
            responses[i]=data;
          

            i = 27;
            data = "";
            responses[i]=data;
          

            i = 28;
            data = "";
            responses[i]=data;
          

            i = 29;
            data = "1 subgoal (ID 1)	  	  ============================	  graph	";
            responses[i]=data;
          

            i = 30;
            data = "";
            responses[i]=data;
          

            i = 31;
            data = "2 subgoals (ID 3)	  	  ============================	  Type		subgoal 2 (ID 5) is:	 ?graph0 -> ?graph0 -> Type	";
            responses[i]=data;
          

            i = 32;
            data = "1 subgoal (ID 3)	  	  ============================	  Type	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 5)		subgoal 1 (ID 5) is:	 Unit + Bool -> Unit + Bool -> Type	";
            responses[i]=data;
          

            i = 33;
            data = "1 subgoal (ID 5)	  	  ============================	  Unit + Bool -> Unit + Bool -> Type	4 subgoals (ID 17)	  	  i, j : Unit	  ============================	  Type		subgoal 2 (ID 18) is:	 Type	subgoal 3 (ID 25) is:	 Type	subgoal 4 (ID 26) is:	 Type	";
            responses[i]=data;
          

            i = 34;
            data = "3 subgoals (ID 17)	  	  i, j : Unit	  ============================	  Type		subgoal 2 (ID 25) is:	 Type	subgoal 3 (ID 26) is:	 Type	";
            responses[i]=data;
          

            i = 35;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 36;
            data = "<infomsg>PO_graph is defined</infomsg>	";
            responses[i]=data;
          

            i = 37;
            data = "";
            responses[i]=data;
          

            i = 38;
            data = "<infomsg>A is declared</infomsg>	<infomsg>B is declared</infomsg>	<infomsg>C is declared</infomsg>	";
            responses[i]=data;
          

            i = 39;
            data = "";
            responses[i]=data;
          

            i = 40;
            data = "";
            responses[i]=data;
          

            i = 41;
            data = "";
            responses[i]=data;
          

            i = 42;
            data = "";
            responses[i]=data;
          

            i = 43;
            data = "1 subgoal (ID 4)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  diagram PO_graph	";
            responses[i]=data;
          

            i = 44;
            data = "";
            responses[i]=data;
          

            i = 45;
            data = "2 subgoals (ID 8)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  PO_graph -> Type		subgoal 2 (ID 10) is:	 forall i j : PO_graph, PO_graph i j -> ?diagram0 i -> ?diagram0 j	";
            responses[i]=data;
          

            i = 46;
            data = "1 subgoal (ID 8)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  PO_graph -> Type	2 subgoals (ID 16)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  i : Unit	  ============================	  Type		subgoal 2 (ID 17) is:	 Type	";
            responses[i]=data;
          

            i = 47;
            data = "1 subgoal (ID 16)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  i : Unit	  ============================	  Type	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 subgoals (ID 17)		subgoal 1 (ID 17) is:	 Type	subgoal 2 (ID 10) is:	 forall i j : PO_graph,	 PO_graph i j ->	 (fun X : PO_graph => match X with	                      | inl _ => A	                      | inr i0 => ?Goal@{i:=i0}	                      end) i ->	 (fun X : PO_graph => match X with	                      | inl _ => A	                      | inr i0 => ?Goal@{i:=i0}	                      end) j	";
            responses[i]=data;
          

            i = 48;
            data = "1 subgoal (ID 17)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  i : Bool	  ============================	  Type	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 10)		subgoal 1 (ID 10) is:	 forall i j : PO_graph,	 PO_graph i j ->	 (fun X : PO_graph =>	  match X with	  | inl _ => A	  | inr true => B	  | inr false => C	  end) i ->	 (fun X : PO_graph =>	  match X with	  | inl _ => A	  | inr true => B	  | inr false => C	  end) j	";
            responses[i]=data;
          

            i = 49;
            data = "1 subgoal (ID 10)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  forall i j : PO_graph,	  PO_graph i j ->	  (fun X : PO_graph =>	   match X with	   | inl _ => A	   | inr true => B	   | inr false => C	   end) i ->	  (fun X : PO_graph =>	   match X with	   | inl _ => A	   | inr true => B	   | inr false => C	   end) j	1 subgoal (ID 46)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  i : Unit	  j : Bool	  u : PO_graph (inl i) (inr j)	  ============================	  A -> if j then B else C	";
            responses[i]=data;
          

            i = 50;
            data = "2 subgoals (ID 63)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  i : Unit	  u : PO_graph (inl i) (inr true)	  ============================	  A -> B		subgoal 2 (ID 64) is:	 A -> C	";
            responses[i]=data;
          

            i = 51;
            data = "1 subgoal (ID 63)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  i : Unit	  u : PO_graph (inl i) (inr true)	  ============================	  A -> B	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 subgoal (ID 64)		subgoal 1 (ID 64) is:	 A -> C	";
            responses[i]=data;
          

            i = 52;
            data = "1 subgoal (ID 64)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  i : Unit	  u : PO_graph (inl i) (inr false)	  ============================	  A -> C	No more subgoals.	";
            responses[i]=data;
          

            i = 53;
            data = "<infomsg>span is defined</infomsg>	";
            responses[i]=data;
          

            i = 54;
            data = "1 subgoal (ID 32)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Z : Type	  inl' : B -> Z	  inr' : C -> Z	  pp' : inl' o f == inr' o g	  ============================	  cocone (span f g) Z	";
            responses[i]=data;
          

            i = 55;
            data = "";
            responses[i]=data;
          

            i = 56;
            data = "2 subgoals (ID 34)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Z : Type	  inl' : B -> Z	  inr' : C -> Z	  pp' : inl' o f == inr' o g	  ============================	  forall i : PO_graph, span f g i -> Z		subgoal 2 (ID 35) is:	 forall (i j : PO_graph) (g0 : PO_graph i j) (x : span f g i),	 ?q j (((span f g) _f g0) x) = ?q i x	";
            responses[i]=data;
          

            i = 57;
            data = "1 subgoal (ID 34)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Z : Type	  inl' : B -> Z	  inr' : C -> Z	  pp' : inl' o f == inr' o g	  ============================	  forall i : PO_graph, span f g i -> Z	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 35)		subgoal 1 (ID 35) is:	 forall (i j : PO_graph) (g0 : PO_graph i j) (x : span f g i),	 (fun i0 : PO_graph =>	  match i0 as s return (span f g s -> Z) with	  | inl _ => inr' o g	  | inr b => if b as b0 return (span f g (inr b0) -> Z) then inl' else inr'	  end) j (((span f g) _f g0) x) =	 (fun i0 : PO_graph =>	  match i0 as s return (span f g s -> Z) with	  | inl _ => inr' o g	  | inr b => if b as b0 return (span f g (inr b0) -> Z) then inl' else inr'	  end) i x	";
            responses[i]=data;
          

            i = 58;
            data = "1 subgoal (ID 35)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Z : Type	  inl' : B -> Z	  inr' : C -> Z	  pp' : inl' o f == inr' o g	  ============================	  forall (i j : PO_graph) (g0 : PO_graph i j) (x : span f g i),	  (fun i0 : PO_graph =>	   match i0 as s return (span f g s -> Z) with	   | inl _ => inr' o g	   | inr b => if b as b0 return (span f g (inr b0) -> Z) then inl' else inr'	   end) j (((span f g) _f g0) x) =	  (fun i0 : PO_graph =>	   match i0 as s return (span f g s -> Z) with	   | inl _ => inr' o g	   | inr b => if b as b0 return (span f g (inr b0) -> Z) then inl' else inr'	   end) i x	1 subgoal (ID 84)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Z : Type	  inl' : B -> Z	  inr' : C -> Z	  pp' : inl' o f == inr' o g	  u : Unit	  b : Bool	  ============================	  forall x : A,	  (if b as b0 return ((if b0 then B else C) -> Z) then inl' else inr')	    ((if b as b0 return (Unit -> A -> if b0 then B else C)	      then unit_name f	      else unit_name g) tt x) = inr' (g x)	";
            responses[i]=data;
          

            i = 59;
            data = "2 subgoals (ID 88)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Z : Type	  inl' : B -> Z	  inr' : C -> Z	  pp' : inl' o f == inr' o g	  u : Unit	  ============================	  forall x : A, inl' (f x) = inr' (g x)		subgoal 2 (ID 89) is:	 forall x : A, inr' (g x) = inr' (g x)	";
            responses[i]=data;
          

            i = 60;
            data = "1 subgoal (ID 88)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Z : Type	  inl' : B -> Z	  inr' : C -> Z	  pp' : inl' o f == inr' o g	  u : Unit	  ============================	  forall x : A, inl' (f x) = inr' (g x)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 subgoal (ID 89)		subgoal 1 (ID 89) is:	 forall x : A, inr' (g x) = inr' (g x)	";
            responses[i]=data;
          

            i = 61;
            data = "1 subgoal (ID 89)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Z : Type	  inl' : B -> Z	  inr' : C -> Z	  pp' : inl' o f == inr' o g	  u : Unit	  ============================	  forall x : A, inr' (g x) = inr' (g x)	No more subgoals.	";
            responses[i]=data;
          

            i = 62;
            data = "<infomsg>Build_span_cocone is defined</infomsg>	";
            responses[i]=data;
          

            i = 63;
            data = "<infomsg>pol' is defined</infomsg>	";
            responses[i]=data;
          

            i = 64;
            data = "<infomsg>por' is defined</infomsg>	";
            responses[i]=data;
          

            i = 65;
            data = "<infomsg>popp' is defined</infomsg>	";
            responses[i]=data;
          

            i = 66;
            data = "<infomsg>is_PO is defined</infomsg>	";
            responses[i]=data;
          

            i = 67;
            data = "<infomsg>PO is defined</infomsg>	";
            responses[i]=data;
          

            i = 68;
            data = "<infomsg>f is declared</infomsg>	<infomsg>g is declared</infomsg>	";
            responses[i]=data;
          

            i = 69;
            data = "<infomsg>pol is defined</infomsg>	";
            responses[i]=data;
          

            i = 70;
            data = "<infomsg>por is defined</infomsg>	";
            responses[i]=data;
          

            i = 71;
            data = "<infomsg>popp is defined</infomsg>	";
            responses[i]=data;
          

            i = 72;
            data = "";
            responses[i]=data;
          

            i = 73;
            data = "";
            responses[i]=data;
          

            i = 74;
            data = "";
            responses[i]=data;
          

            i = 75;
            data = "";
            responses[i]=data;
          

            i = 76;
            data = "";
            responses[i]=data;
          

            i = 77;
            data = "";
            responses[i]=data;
          

            i = 78;
            data = "";
            responses[i]=data;
          

            i = 79;
            data = "";
            responses[i]=data;
          

            i = 80;
            data = "1 subgoal (ID 139)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  ============================	  forall w : PO f g, P w	";
            responses[i]=data;
          

            i = 81;
            data = "";
            responses[i]=data;
          

            i = 82;
            data = "2 subgoals (ID 143)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  ============================	  forall (i : PO_graph) (x : span f g i), P (colim i x)		subgoal 2 (ID 145) is:	 forall (i j : PO_graph) (g0 : PO_graph i j) (x : span f g i),	 transport P (colimp i j g0 x) (?q j (((span f g) _f g0) x)) = ?q i x	";
            responses[i]=data;
          

            i = 83;
            data = "1 subgoal (ID 143)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  ============================	  forall (i : PO_graph) (x : span f g i), P (colim i x)	3 subgoals (ID 163)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : span f g (inl tt)	  ============================	  P (colim (inl tt) x)		subgoal 2 (ID 165) is:	 P (colim (inr true) x)	subgoal 3 (ID 167) is:	 P (colim (inr false) x)	";
            responses[i]=data;
          

            i = 84;
            data = "1 subgoal (ID 163)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : span f g (inl tt)	  ============================	  P (colim (inl tt) x)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	3 subgoals (ID 165)		subgoal 1 (ID 165) is:	 P (colim (inr true) x)	subgoal 2 (ID 167) is:	 P (colim (inr false) x)	subgoal 3 (ID 145) is:	 forall (i j : PO_graph) (g0 : PO_graph i j) (x : span f g i),	 transport P (colimp i j g0 x)	   ((fun i0 : PO_graph =>	     match i0 as s return (forall x0 : span f g s, P (colim s x0)) with	     | inl u =>	         match	           u as u0	           return (forall x0 : span f g (inl u0), P (colim (inl u0) x0))	         with	         | tt =>	             fun x0 : span f g (inl tt) =>	             transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	         end	     | inr b =>	         if b as b0	          return (forall x0 : span f g (inr b0), P (colim (inr b0) x0))	         then fun x0 : span f g (inr true) => ?Goal@{x:=x0}	         else fun x0 : span f g (inr false) => ?Goal0@{x:=x0}	     end) j (((span f g) _f g0) x)) =	 (fun i0 : PO_graph =>	  match i0 as s return (forall x0 : span f g s, P (colim s x0)) with	  | inl u =>	      match	        u as u0 return (forall x0 : span f g (inl u0), P (colim (inl u0) x0))	      with	      | tt =>	          fun x0 : span f g (inl tt) =>	          transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	      end	  | inr b =>	      if b as b0	       return (forall x0 : span f g (inr b0), P (colim (inr b0) x0))	      then fun x0 : span f g (inr true) => ?Goal@{x:=x0}	      else fun x0 : span f g (inr false) => ?Goal0@{x:=x0}	  end) i x	";
            responses[i]=data;
          

            i = 85;
            data = "1 subgoal (ID 165)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : span f g (inr true)	  ============================	  P (colim (inr true) x)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 subgoals (ID 167)		subgoal 1 (ID 167) is:	 P (colim (inr false) x)	subgoal 2 (ID 145) is:	 forall (i j : PO_graph) (g0 : PO_graph i j) (x : span f g i),	 transport P (colimp i j g0 x)	   ((fun i0 : PO_graph =>	     match i0 as s return (forall x0 : span f g s, P (colim s x0)) with	     | inl u =>	         match	           u as u0	           return (forall x0 : span f g (inl u0), P (colim (inl u0) x0))	         with	         | tt =>	             fun x0 : span f g (inl tt) =>	             transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	         end	     | inr b =>	         if b as b0	          return (forall x0 : span f g (inr b0), P (colim (inr b0) x0))	         then fun x0 : span f g (inr true) => l' x0	         else fun x0 : span f g (inr false) => ?Goal@{x:=x0}	     end) j (((span f g) _f g0) x)) =	 (fun i0 : PO_graph =>	  match i0 as s return (forall x0 : span f g s, P (colim s x0)) with	  | inl u =>	      match	        u as u0 return (forall x0 : span f g (inl u0), P (colim (inl u0) x0))	      with	      | tt =>	          fun x0 : span f g (inl tt) =>	          transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	      end	  | inr b =>	      if b as b0	       return (forall x0 : span f g (inr b0), P (colim (inr b0) x0))	      then fun x0 : span f g (inr true) => l' x0	      else fun x0 : span f g (inr false) => ?Goal@{x:=x0}	  end) i x	";
            responses[i]=data;
          

            i = 86;
            data = "1 subgoal (ID 167)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : span f g (inr false)	  ============================	  P (colim (inr false) x)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 145)		subgoal 1 (ID 145) is:	 forall (i j : PO_graph) (g0 : PO_graph i j) (x : span f g i),	 transport P (colimp i j g0 x)	   ((fun i0 : PO_graph =>	     match i0 as s return (forall x0 : span f g s, P (colim s x0)) with	     | inl u =>	         match	           u as u0	           return (forall x0 : span f g (inl u0), P (colim (inl u0) x0))	         with	         | tt =>	             fun x0 : span f g (inl tt) =>	             transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	         end	     | inr b =>	         if b as b0	          return (forall x0 : span f g (inr b0), P (colim (inr b0) x0))	         then fun x0 : span f g (inr true) => l' x0	         else fun x0 : span f g (inr false) => r' x0	     end) j (((span f g) _f g0) x)) =	 (fun i0 : PO_graph =>	  match i0 as s return (forall x0 : span f g s, P (colim s x0)) with	  | inl u =>	      match	        u as u0 return (forall x0 : span f g (inl u0), P (colim (inl u0) x0))	      with	      | tt =>	          fun x0 : span f g (inl tt) =>	          transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	      end	  | inr b =>	      if b as b0	       return (forall x0 : span f g (inr b0), P (colim (inr b0) x0))	      then fun x0 : span f g (inr true) => l' x0	      else fun x0 : span f g (inr false) => r' x0	  end) i x	";
            responses[i]=data;
          

            i = 87;
            data = "1 subgoal (ID 145)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  ============================	  forall (i j : PO_graph) (g0 : PO_graph i j) (x : span f g i),	  transport P (colimp i j g0 x)	    ((fun i0 : PO_graph =>	      match i0 as s return (forall x0 : span f g s, P (colim s x0)) with	      | inl u =>	          match	            u as u0	            return (forall x0 : span f g (inl u0), P (colim (inl u0) x0))	          with	          | tt =>	              fun x0 : span f g (inl tt) =>	              transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	          end	      | inr b =>	          if b as b0	           return (forall x0 : span f g (inr b0), P (colim (inr b0) x0))	          then fun x0 : span f g (inr true) => l' x0	          else fun x0 : span f g (inr false) => r' x0	      end) j (((span f g) _f g0) x)) =	  (fun i0 : PO_graph =>	   match i0 as s return (forall x0 : span f g s, P (colim s x0)) with	   | inl u =>	       match	         u as u0	         return (forall x0 : span f g (inl u0), P (colim (inl u0) x0))	       with	       | tt =>	           fun x0 : span f g (inl tt) =>	           transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	       end	   | inr b =>	       if b as b0	        return (forall x0 : span f g (inr b0), P (colim (inr b0) x0))	       then fun x0 : span f g (inr true) => l' x0	       else fun x0 : span f g (inr false) => r' x0	   end) i x	1 subgoal (ID 207)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  u : Unit	  b : Bool	  ============================	  forall x : A,	  transport P (colimp (inl u) (inr b) tt x)	    ((if b as b0	       return (forall x0 : if b0 then B else C, P (colim (inr b0) x0))	      then fun x0 : B => l' x0	      else fun x0 : C => r' x0)	       ((if b as b0 return (Unit -> A -> if b0 then B else C)	         then unit_name f	         else unit_name g) tt x)) =	  match u as u0 return (forall x0 : A, P (colim (inl u0) x0)) with	  | tt =>	      fun x0 : A =>	      transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	  end x	";
            responses[i]=data;
          

            i = 88;
            data = "2 subgoals (ID 217)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  ============================	  forall x : A,	  transport P (colimp (inl tt) (inr true) tt x) (l' (f x)) =	  transport P (colimp (inl tt) (inr true) tt x) (l' (f x))		subgoal 2 (ID 219) is:	 forall x : A,	 transport P (colimp (inl tt) (inr false) tt x) (r' (g x)) =	 transport P (colimp (inl tt) (inr true) tt x) (l' (f x))	";
            responses[i]=data;
          

            i = 89;
            data = "1 subgoal (ID 217)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  ============================	  forall x : A,	  transport P (colimp (inl tt) (inr true) tt x) (l' (f x)) =	  transport P (colimp (inl tt) (inr true) tt x) (l' (f x))	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 subgoal (ID 219)		subgoal 1 (ID 219) is:	 forall x : A,	 transport P (colimp (inl tt) (inr false) tt x) (r' (g x)) =	 transport P (colimp (inl tt) (inr true) tt x) (l' (f x))	";
            responses[i]=data;
          

            i = 90;
            data = "1 subgoal (ID 219)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  ============================	  forall x : A,	  transport P (colimp (inl tt) (inr false) tt x) (r' (g x)) =	  transport P (colimp (inl tt) (inr true) tt x) (l' (f x))	1 subgoal (ID 222)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A,	        transport P	          (colimp (inl tt) (inr true) tt a @	           (colimp (inl tt) (inr false) tt a)^) (l' (f a)) = 	        r' (g a)	  ============================	  forall x : A,	  transport P (colimp (inl tt) (inr false) tt x) (r' (g x)) =	  transport P (colimp (inl tt) (inr true) tt x) (l' (f x))	";
            responses[i]=data;
          

            i = 91;
            data = "1 subgoal (ID 223)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A,	        transport P	          (colimp (inl tt) (inr true) tt a @	           (colimp (inl tt) (inr false) tt a)^) (l' (f a)) = 	        r' (g a)	  a : A	  ============================	  transport P (colimp (inl tt) (inr false) tt a) (r' (g a)) =	  transport P (colimp (inl tt) (inr true) tt a) (l' (f a))	";
            responses[i]=data;
          

            i = 92;
            data = "1 subgoal (ID 225)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A,	        transport P	          (colimp (inl tt) (inr true) tt a @	           (colimp (inl tt) (inr false) tt a)^) (l' (f a)) = 	        r' (g a)	  a : A	  ============================	  r' (g a) =	  transport P (colimp (inl tt) (inr false) tt a)^	    (transport P (colimp (inl tt) (inr true) tt a) (l' (f a)))	";
            responses[i]=data;
          

            i = 93;
            data = "1 subgoal (ID 246)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A,	        transport P	          (colimp (inl tt) (inr true) tt a @	           (colimp (inl tt) (inr false) tt a)^) (l' (f a)) = 	        r' (g a)	  a : A	  ============================	  r' (g a) =	  transport P	    (colimp (inl tt) (inr true) tt a @ (colimp (inl tt) (inr false) tt a)^)	    (l' (f a))	";
            responses[i]=data;
          

            i = 94;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 95;
            data = "<infomsg>PO_ind is defined</infomsg>	";
            responses[i]=data;
          

            i = 96;
            data = "1 subgoal (ID 161)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  ============================	  forall x : A, apD (PO_ind P l' r' pp') (popp x) = pp' x	";
            responses[i]=data;
          

            i = 97;
            data = "";
            responses[i]=data;
          

            i = 98;
            data = "1 subgoal (ID 162)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  apD (PO_ind P l' r' pp') (popp x) = pp' x	";
            responses[i]=data;
          

            i = 99;
            data = "2 focused subgoals	(shelved: 1) (ID 183)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  apD (PO_ind P l' r' pp') (popp x) = ?Goal		subgoal 2 (ID 185) is:	 ?Goal = pp' x	";
            responses[i]=data;
          

            i = 100;
            data = "1 focused subgoal	(shelved: 1) (ID 183)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  apD (PO_ind P l' r' pp') (popp x) = ?Goal	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 185)		subgoal 1 (ID 185) is:	 (transport_pp P (colimp (inl tt) (inr true) tt x)	    (colimp (inl tt) (inr false) tt x)^	    (PO_ind P l' r' pp' (colim (inr true) (((span f g) _f tt) x))) @	  ap (transport P (colimp (inl tt) (inr false) tt x)^)	    (apD (PO_ind P l' r' pp') (colimp (inl tt) (inr true) tt x))) @	 apD (PO_ind P l' r' pp') (colimp (inl tt) (inr false) tt x)^ = 	 pp' x	";
            responses[i]=data;
          

            i = 101;
            data = "1 subgoal (ID 185)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  (transport_pp P (colimp (inl tt) (inr true) tt x)	     (colimp (inl tt) (inr false) tt x)^	     (PO_ind P l' r' pp' (colim (inr true) (((span f g) _f tt) x))) @	   ap (transport P (colimp (inl tt) (inr false) tt x)^)	     (apD (PO_ind P l' r' pp') (colimp (inl tt) (inr true) tt x))) @	  apD (PO_ind P l' r' pp') (colimp (inl tt) (inr false) tt x)^ = 	  pp' x	2 subgoals (ID 202)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  apD (PO_ind P l' r' pp') (colimp (inl tt) (inr true) tt x) = 1		subgoal 2 (ID 203) is:	 (transport_pp P (colimp (inl tt) (inr true) tt x)	    (colimp (inl tt) (inr false) tt x)^	    (PO_ind P l' r' pp' (colim (inr true) (((span f g) _f tt) x))) @	  ap (transport P (colimp (inl tt) (inr false) tt x)^)	    (apD (PO_ind P l' r' pp') (colimp (inl tt) (inr true) tt x))) @	 apD (PO_ind P l' r' pp') (colimp (inl tt) (inr false) tt x)^ = 	 pp' x	";
            responses[i]=data;
          

            i = 102;
            data = "1 subgoal (ID 202)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  apD (PO_ind P l' r' pp') (colimp (inl tt) (inr true) tt x) = 1	1 subgoal (ID 205)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  apD	    (colimit_ind P	       (fun i : PO_graph =>	        match i as s return (forall x0 : span f g s, P (colim s x0)) with	        | inl u =>	            match	              u as u0	              return (forall x0 : span f g (inl u0), P (colim (inl u0) x0))	            with	            | tt =>	                fun x0 : span f g (inl tt) =>	                transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	            end	        | inr b =>	            if b as b0	             return (forall x0 : span f g (inr b0), P (colim (inr b0) x0))	            then fun x0 : span f g (inr true) => l' x0	            else fun x0 : span f g (inr false) => r' x0	        end)	       (fun i : PO_graph =>	        match	          i as s	          return	            (forall (j : PO_graph) (g0 : PO_graph s j) 	             (x0 : span f g s),	             transport P (colimp s j g0 x0)	               (match	                  j as s0 return (forall x1 : span f g s0, P (colim s0 x1))	                with	                | inl u =>	                    match	                      u as u0	                      return	                        (forall x1 : span f g (inl u0), P (colim (inl u0) x1))	                    with	                    | tt =>	                        fun x1 : span f g (inl tt) =>	                        transport P (colimp (inl tt) (inr true) tt x1)	                          (l' (f x1))	                    end	                | inr b =>	                    if b as b0	                     return	                       (forall x1 : span f g (inr b0), P (colim (inr b0) x1))	                    then fun x1 : span f g (inr true) => l' x1	                    else fun x1 : span f g (inr false) => r' x1	                end (((span f g) _f g0) x0)) =	             match	               s as s0 return (forall x1 : span f g s0, P (colim s0 x1))	             with	             | inl u =>	                 match	                   u as u0	                   return	                     (forall x1 : span f g (inl u0), P (colim (inl u0) x1))	                 with	                 | tt =>	                     fun x1 : span f g (inl tt) =>	                     transport P (colimp (inl tt) (inr true) tt x1)	                       (l' (f x1))	                 end	             | inr b =>	                 if b as b0	                  return	                    (forall x1 : span f g (inr b0), P (colim (inr b0) x1))	                 then fun x1 : span f g (inr true) => l' x1	                 else fun x1 : span f g (inr false) => r' x1	             end x0)	        with	        | inl u =>	            fun j : PO_graph =>	            match	              j as s	              return	                (forall (g0 : PO_graph (inl u) s) 	                 (x0 : span f g (inl u)),	                 transport P (colimp (inl u) s g0 x0)	                   (match	                      s as s0	                      return (forall x1 : span f g s0, P (colim s0 x1))	                    with	                    | inl u0 =>	                        match	                          u0 as u1	                          return	                            (forall x1 : span f g (inl u1),	                             P (colim (inl u1) x1))	                        with	                        | tt =>	                            fun x1 : span f g (inl tt) =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end	                    | inr b =>	                        if b as b0	                         return	                           (forall x1 : span f g (inr b0),	                            P (colim (inr b0) x1))	                        then fun x1 : span f g (inr true) => l' x1	                        else fun x1 : span f g (inr false) => r' x1	                    end (((span f g) _f g0) x0)) =	                 match	                   u as u0	                   return	                     (forall x1 : span f g (inl u0), P (colim (inl u0) x1))	                 with	                 | tt =>	                     fun x1 : span f g (inl tt) =>	                     transport P (colimp (inl tt) (inr true) tt x1)	                       (l' (f x1))	                 end x0)	            with	            | inl u0 =>	                fun g0 : PO_graph (inl u) (inl u0) =>	                match	                  g0 as e	                  return	                    (forall x0 : span f g (inl u),	                     transport P (colimp (inl u) (inl u0) e x0)	                       (match	                          u0 as u1	                          return	                            (forall x1 : span f g (inl u1),	                             P (colim (inl u1) x1))	                        with	                        | tt =>	                            fun x1 : span f g (inl tt) =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end (((span f g) _f e) x0)) =	                     match	                       u as u1	                       return	                         (forall x1 : span f g (inl u1),	                          P (colim (inl u1) x1))	                     with	                     | tt =>	                         fun x1 : span f g (inl tt) =>	                         transport P (colimp (inl tt) (inr true) tt x1)	                           (l' (f x1))	                     end x0)	                with	                end	            | inr b =>	                fun g0 : PO_graph (inl u) (inr b) =>	                match	                  g0 as u0	                  return	                    (forall x0 : span f g (inl u),	                     transport P (colimp (inl u) (inr b) u0 x0)	                       ((if b as b0	                          return	                            (forall x1 : span f g (inr b0),	                             P (colim (inr b0) x1))	                         then fun x1 : span f g (inr true) => l' x1	                         else fun x1 : span f g (inr false) => r' x1)	                          (((span f g) _f u0) x0)) =	                     match	                       u as u1	                       return	                         (forall x1 : span f g (inl u1),	                          P (colim (inl u1) x1))	                     with	                     | tt =>	                         fun x1 : span f g (inl tt) =>	                         transport P (colimp (inl tt) (inr true) tt x1)	                           (l' (f x1))	                     end x0)	                with	                | tt =>	                    match	                      u as u0	                      return	                        (forall x0 : A,	                         transport P (colimp (inl u0) (inr b) tt x0)	                           ((if b as b0	                              return	                                (forall x1 : if b0 then B else C,	                                 P (colim (inr b0) x1))	                             then fun x1 : B => l' x1	                             else fun x1 : C => r' x1)	                              ((if b as b0	                                 return (Unit -> A -> if b0 then B else C)	                                then unit_name f	                                else unit_name g) tt x0)) =	                         match	                           u0 as u1	                           return (forall x1 : A, P (colim (inl u1) x1))	                         with	                         | tt =>	                             fun x1 : A =>	                             transport P (colimp (inl tt) (inr true) tt x1)	                               (l' (f x1))	                         end x0)	                    with	                    | tt =>	                        if b as b0	                         return	                           (forall x0 : A,	                            transport P (colimp (inl tt) (inr b0) tt x0)	                              ((if b0 as b1	                                 return	                                   (forall x1 : if b1 then B else C,	                                    P (colim (inr b1) x1))	                                then fun x1 : B => l' x1	                                else fun x1 : C => r' x1)	                                 ((if b0 as b1	                                    return (Unit -> A -> if b1 then B else C)	                                   then unit_name f	                                   else unit_name g) tt x0)) =	                            transport P (colimp (inl tt) (inr true) tt x0)	                              (l' (f x0)))	                        then fun x0 : A => 1	                        else	                         fun a : A =>	                         moveR_transport_p P	                           (colimp (inl tt) (inr false) tt a) 	                           (r' (g a))	                           (transport P (colimp (inl tt) (inr true) tt a)	                              (l' (f a)))	                           ((pp' a)^ @	                            transport_pp P (colimp (inl tt) (inr true) tt a)	                              (colimp (inl tt) (inr false) tt a)^ 	                              (l' (f a)))	                    end	                end	            end	        | inr b =>	            fun j : PO_graph =>	            match	              j as s	              return	                (forall (g0 : PO_graph (inr b) s) 	                 (x0 : span f g (inr b)),	                 transport P (colimp (inr b) s g0 x0)	                   (match	                      s as s0	                      return (forall x1 : span f g s0, P (colim s0 x1))	                    with	                    | inl u =>	                        match	                          u as u0	                          return	                            (forall x1 : span f g (inl u0),	                             P (colim (inl u0) x1))	                        with	                        | tt =>	                            fun x1 : span f g (inl tt) =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end	                    | inr b0 =>	                        if b0 as b1	                         return	                           (forall x1 : span f g (inr b1),	                            P (colim (inr b1) x1))	                        then fun x1 : span f g (inr true) => l' x1	                        else fun x1 : span f g (inr false) => r' x1	                    end (((span f g) _f g0) x0)) =	                 (if b as b0	                   return	                     (forall x1 : span f g (inr b0), P (colim (inr b0) x1))	                  then fun x1 : span f g (inr true) => l' x1	                  else fun x1 : span f g (inr false) => r' x1) x0)	            with	            | inl u =>	                fun g0 : PO_graph (inr b) (inl u) =>	                match	                  g0 as e	                  return	                    (forall x0 : span f g (inr b),	                     transport P (colimp (inr b) (inl u) e x0)	                       (match	                          u as u0	                          return	                            (forall x1 : span f g (inl u0),	                             P (colim (inl u0) x1))	                        with	                        | tt =>	                            fun x1 : span f g (inl tt) =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end (((span f g) _f e) x0)) =	                     (if b as b0	                       return	                         (forall x1 : span f g (inr b0),	                          P (colim (inr b0) x1))	                      then fun x1 : span f g (inr true) => l' x1	                      else fun x1 : span f g (inr false) => r' x1) x0)	                with	                end	            | inr b0 =>	                fun g0 : PO_graph (inr b) (inr b0) =>	                match	                  g0 as e	                  return	                    (forall x0 : span f g (inr b),	                     transport P (colimp (inr b) (inr b0) e x0)	                       ((if b0 as b1	                          return	                            (forall x1 : span f g (inr b1),	                             P (colim (inr b1) x1))	                         then fun x1 : span f g (inr true) => l' x1	                         else fun x1 : span f g (inr false) => r' x1)	                          (((span f g) _f e) x0)) =	                     (if b as b1	                       return	                         (forall x1 : span f g (inr b1),	                          P (colim (inr b1) x1))	                      then fun x1 : span f g (inr true) => l' x1	                      else fun x1 : span f g (inr false) => r' x1) x0)	                with	                end	            end	        end)) (colimp (inl tt) (inr true) tt x) = 1	";
            responses[i]=data;
          

            i = 103;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 subgoal (ID 203)		subgoal 1 (ID 203) is:	 (transport_pp P (colimp (inl tt) (inr true) tt x)	    (colimp (inl tt) (inr false) tt x)^	    (PO_ind P l' r' pp' (colim (inr true) (((span f g) _f tt) x))) @	  ap (transport P (colimp (inl tt) (inr false) tt x)^)	    (apD (PO_ind P l' r' pp') (colimp (inl tt) (inr true) tt x))) @	 apD (PO_ind P l' r' pp') (colimp (inl tt) (inr false) tt x)^ = 	 pp' x	1 subgoal (ID 203)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  X : apD (PO_ind P l' r' pp') (colimp (inl tt) (inr true) tt x) = 1	  ============================	  (transport_pp P (colimp (inl tt) (inr true) tt x)	     (colimp (inl tt) (inr false) tt x)^	     (PO_ind P l' r' pp' (colim (inr true) (((span f g) _f tt) x))) @	   ap (transport P (colimp (inl tt) (inr false) tt x)^)	     (apD (PO_ind P l' r' pp') (colimp (inl tt) (inr true) tt x))) @	  apD (PO_ind P l' r' pp') (colimp (inl tt) (inr false) tt x)^ = 	  pp' x	1 subgoal (ID 212)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  X : apD (PO_ind P l' r' pp') (colimp (inl tt) (inr true) tt x) = 1	  ============================	  (transport_pp P (colimp (inl tt) (inr true) tt x)	     (colimp (inl tt) (inr false) tt x)^	     (PO_ind P l' r' pp' (colim (inr true) (((span f g) _f tt) x))) @	   ap (transport P (colimp (inl tt) (inr false) tt x)^) 1) @	  apD (PO_ind P l' r' pp') (colimp (inl tt) (inr false) tt x)^ = 	  pp' x	";
            responses[i]=data;
          

            i = 104;
            data = "1 subgoal (ID 213)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  (transport_pp P (colimp (inl tt) (inr true) tt x)	     (colimp (inl tt) (inr false) tt x)^	     (PO_ind P l' r' pp' (colim (inr true) (((span f g) _f tt) x))) @	   ap (transport P (colimp (inl tt) (inr false) tt x)^) 1) @	  apD (PO_ind P l' r' pp') (colimp (inl tt) (inr false) tt x)^ = 	  pp' x	";
            responses[i]=data;
          

            i = 105;
            data = "1 subgoal (ID 215)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  (transport_pp P (colimp (inl tt) (inr true) tt x)	     (colimp (inl tt) (inr false) tt x)^ (l' (f x)) @ 1) @	  apD (PO_ind P l' r' pp') (colimp (inl tt) (inr false) tt x)^ = 	  pp' x	";
            responses[i]=data;
          

            i = 106;
            data = "1 subgoal (ID 219)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  transport_pp P (colimp (inl tt) (inr true) tt x)	    (colimp (inl tt) (inr false) tt x)^ (l' (f x)) @	  apD (PO_ind P l' r' pp') (colimp (inl tt) (inr false) tt x)^ = 	  pp' x	";
            responses[i]=data;
          

            i = 107;
            data = "1 subgoal (ID 225)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  transport_pp P (colimp (inl tt) (inr true) tt x)	    (colimp (inl tt) (inr false) tt x)^ (l' (f x)) @	  moveR_transport_V P (colimp (inl tt) (inr false) tt x)	    (PO_ind P l' r' pp' (colim (inl tt) x))	    (PO_ind P l' r' pp' (colim (inr false) (g x)))	    (apD (PO_ind P l' r' pp') (colimp (inl tt) (inr false) tt x))^ = 	  pp' x	";
            responses[i]=data;
          

            i = 108;
            data = "1 subgoal (ID 229)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  transport_pp P (colimp (inl tt) (inr true) tt x)	    (colimp (inl tt) (inr false) tt x)^ (l' (f x)) @	  moveR_transport_V P (colimp (inl tt) (inr false) tt x)	    (colimit_ind P	       (fun i : PO_graph =>	        match i as s return (forall x0 : span f g s, P (colim s x0)) with	        | inl u =>	            match	              u as u0	              return (forall x0 : span f g (inl u0), P (colim (inl u0) x0))	            with	            | tt =>	                fun x0 : span f g (inl tt) =>	                transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	            end	        | inr b =>	            if b as b0	             return (forall x0 : span f g (inr b0), P (colim (inr b0) x0))	            then fun x0 : span f g (inr true) => l' x0	            else fun x0 : span f g (inr false) => r' x0	        end)	       (fun i : PO_graph =>	        match	          i as s	          return	            (forall (j : PO_graph) (g0 : PO_graph s j) 	             (x0 : span f g s),	             transport P (colimp s j g0 x0)	               (match	                  j as s0 return (forall x1 : span f g s0, P (colim s0 x1))	                with	                | inl u =>	                    match	                      u as u0	                      return	                        (forall x1 : span f g (inl u0), P (colim (inl u0) x1))	                    with	                    | tt =>	                        fun x1 : span f g (inl tt) =>	                        transport P (colimp (inl tt) (inr true) tt x1)	                          (l' (f x1))	                    end	                | inr b =>	                    if b as b0	                     return	                       (forall x1 : span f g (inr b0), P (colim (inr b0) x1))	                    then fun x1 : span f g (inr true) => l' x1	                    else fun x1 : span f g (inr false) => r' x1	                end (((span f g) _f g0) x0)) =	             match	               s as s0 return (forall x1 : span f g s0, P (colim s0 x1))	             with	             | inl u =>	                 match	                   u as u0	                   return	                     (forall x1 : span f g (inl u0), P (colim (inl u0) x1))	                 with	                 | tt =>	                     fun x1 : span f g (inl tt) =>	                     transport P (colimp (inl tt) (inr true) tt x1)	                       (l' (f x1))	                 end	             | inr b =>	                 if b as b0	                  return	                    (forall x1 : span f g (inr b0), P (colim (inr b0) x1))	                 then fun x1 : span f g (inr true) => l' x1	                 else fun x1 : span f g (inr false) => r' x1	             end x0)	        with	        | inl u =>	            fun j : PO_graph =>	            match	              j as s	              return	                (forall (g0 : PO_graph (inl u) s) 	                 (x0 : span f g (inl u)),	                 transport P (colimp (inl u) s g0 x0)	                   (match	                      s as s0	                      return (forall x1 : span f g s0, P (colim s0 x1))	                    with	                    | inl u0 =>	                        match	                          u0 as u1	                          return	                            (forall x1 : span f g (inl u1),	                             P (colim (inl u1) x1))	                        with	                        | tt =>	                            fun x1 : span f g (inl tt) =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end	                    | inr b =>	                        if b as b0	                         return	                           (forall x1 : span f g (inr b0),	                            P (colim (inr b0) x1))	                        then fun x1 : span f g (inr true) => l' x1	                        else fun x1 : span f g (inr false) => r' x1	                    end (((span f g) _f g0) x0)) =	                 match	                   u as u0	                   return	                     (forall x1 : span f g (inl u0), P (colim (inl u0) x1))	                 with	                 | tt =>	                     fun x1 : span f g (inl tt) =>	                     transport P (colimp (inl tt) (inr true) tt x1)	                       (l' (f x1))	                 end x0)	            with	            | inl u0 =>	                fun g0 : PO_graph (inl u) (inl u0) =>	                match	                  g0 as e	                  return	                    (forall x0 : span f g (inl u),	                     transport P (colimp (inl u) (inl u0) e x0)	                       (match	                          u0 as u1	                          return	                            (forall x1 : span f g (inl u1),	                             P (colim (inl u1) x1))	                        with	                        | tt =>	                            fun x1 : span f g (inl tt) =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end (((span f g) _f e) x0)) =	                     match	                       u as u1	                       return	                         (forall x1 : span f g (inl u1),	                          P (colim (inl u1) x1))	                     with	                     | tt =>	                         fun x1 : span f g (inl tt) =>	                         transport P (colimp (inl tt) (inr true) tt x1)	                           (l' (f x1))	                     end x0)	                with	                end	            | inr b =>	                fun g0 : PO_graph (inl u) (inr b) =>	                match	                  g0 as u0	                  return	                    (forall x0 : span f g (inl u),	                     transport P (colimp (inl u) (inr b) u0 x0)	                       ((if b as b0	                          return	                            (forall x1 : span f g (inr b0),	                             P (colim (inr b0) x1))	                         then fun x1 : span f g (inr true) => l' x1	                         else fun x1 : span f g (inr false) => r' x1)	                          (((span f g) _f u0) x0)) =	                     match	                       u as u1	                       return	                         (forall x1 : span f g (inl u1),	                          P (colim (inl u1) x1))	                     with	                     | tt =>	                         fun x1 : span f g (inl tt) =>	                         transport P (colimp (inl tt) (inr true) tt x1)	                           (l' (f x1))	                     end x0)	                with	                | tt =>	                    match	                      u as u0	                      return	                        (forall x0 : A,	                         transport P (colimp (inl u0) (inr b) tt x0)	                           ((if b as b0	                              return	                                (forall x1 : if b0 then B else C,	                                 P (colim (inr b0) x1))	                             then fun x1 : B => l' x1	                             else fun x1 : C => r' x1)	                              ((if b as b0	                                 return (Unit -> A -> if b0 then B else C)	                                then unit_name f	                                else unit_name g) tt x0)) =	                         match	                           u0 as u1	                           return (forall x1 : A, P (colim (inl u1) x1))	                         with	                         | tt =>	                             fun x1 : A =>	                             transport P (colimp (inl tt) (inr true) tt x1)	                               (l' (f x1))	                         end x0)	                    with	                    | tt =>	                        if b as b0	                         return	                           (forall x0 : A,	                            transport P (colimp (inl tt) (inr b0) tt x0)	                              ((if b0 as b1	                                 return	                                   (forall x1 : if b1 then B else C,	                                    P (colim (inr b1) x1))	                                then fun x1 : B => l' x1	                                else fun x1 : C => r' x1)	                                 ((if b0 as b1	                                    return (Unit -> A -> if b1 then B else C)	                                   then unit_name f	                                   else unit_name g) tt x0)) =	                            transport P (colimp (inl tt) (inr true) tt x0)	                              (l' (f x0)))	                        then fun x0 : A => 1	                        else	                         fun a : A =>	                         moveR_transport_p P	                           (colimp (inl tt) (inr false) tt a) 	                           (r' (g a))	                           (transport P (colimp (inl tt) (inr true) tt a)	                              (l' (f a)))	                           ((pp' a)^ @	                            transport_pp P (colimp (inl tt) (inr true) tt a)	                              (colimp (inl tt) (inr false) tt a)^ 	                              (l' (f a)))	                    end	                end	            end	        | inr b =>	            fun j : PO_graph =>	            match	              j as s	              return	                (forall (g0 : PO_graph (inr b) s) 	                 (x0 : span f g (inr b)),	                 transport P (colimp (inr b) s g0 x0)	                   (match	                      s as s0	                      return (forall x1 : span f g s0, P (colim s0 x1))	                    with	                    | inl u =>	                        match	                          u as u0	                          return	                            (forall x1 : span f g (inl u0),	                             P (colim (inl u0) x1))	                        with	                        | tt =>	                            fun x1 : span f g (inl tt) =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end	                    | inr b0 =>	                        if b0 as b1	                         return	                           (forall x1 : span f g (inr b1),	                            P (colim (inr b1) x1))	                        then fun x1 : span f g (inr true) => l' x1	                        else fun x1 : span f g (inr false) => r' x1	                    end (((span f g) _f g0) x0)) =	                 (if b as b0	                   return	                     (forall x1 : span f g (inr b0), P (colim (inr b0) x1))	                  then fun x1 : span f g (inr true) => l' x1	                  else fun x1 : span f g (inr false) => r' x1) x0)	            with	            | inl u =>	                fun g0 : PO_graph (inr b) (inl u) =>	                match	                  g0 as e	                  return	                    (forall x0 : span f g (inr b),	                     transport P (colimp (inr b) (inl u) e x0)	                       (match	                          u as u0	                          return	                            (forall x1 : span f g (inl u0),	                             P (colim (inl u0) x1))	                        with	                        | tt =>	                            fun x1 : span f g (inl tt) =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end (((span f g) _f e) x0)) =	                     (if b as b0	                       return	                         (forall x1 : span f g (inr b0),	                          P (colim (inr b0) x1))	                      then fun x1 : span f g (inr true) => l' x1	                      else fun x1 : span f g (inr false) => r' x1) x0)	                with	                end	            | inr b0 =>	                fun g0 : PO_graph (inr b) (inr b0) =>	                match	                  g0 as e	                  return	                    (forall x0 : span f g (inr b),	                     transport P (colimp (inr b) (inr b0) e x0)	                       ((if b0 as b1	                          return	                            (forall x1 : span f g (inr b1),	                             P (colim (inr b1) x1))	                         then fun x1 : span f g (inr true) => l' x1	                         else fun x1 : span f g (inr false) => r' x1)	                          (((span f g) _f e) x0)) =	                     (if b as b1	                       return	                         (forall x1 : span f g (inr b1),	                          P (colim (inr b1) x1))	                      then fun x1 : span f g (inr true) => l' x1	                      else fun x1 : span f g (inr false) => r' x1) x0)	                with	                end	            end	        end) (colim (inl tt) x))	    (colimit_ind P	       (fun i : PO_graph =>	        match i as s return (forall x0 : span f g s, P (colim s x0)) with	        | inl u =>	            match	              u as u0	              return (forall x0 : span f g (inl u0), P (colim (inl u0) x0))	            with	            | tt =>	                fun x0 : span f g (inl tt) =>	                transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	            end	        | inr b =>	            if b as b0	             return (forall x0 : span f g (inr b0), P (colim (inr b0) x0))	            then fun x0 : span f g (inr true) => l' x0	            else fun x0 : span f g (inr false) => r' x0	        end)	       (fun i : PO_graph =>	        match	          i as s	          return	            (forall (j : PO_graph) (g0 : PO_graph s j) 	             (x0 : span f g s),	             transport P (colimp s j g0 x0)	               (match	                  j as s0 return (forall x1 : span f g s0, P (colim s0 x1))	                with	                | inl u =>	                    match	                      u as u0	                      return	                        (forall x1 : span f g (inl u0), P (colim (inl u0) x1))	                    with	                    | tt =>	                        fun x1 : span f g (inl tt) =>	                        transport P (colimp (inl tt) (inr true) tt x1)	                          (l' (f x1))	                    end	                | inr b =>	                    if b as b0	                     return	                       (forall x1 : span f g (inr b0), P (colim (inr b0) x1))	                    then fun x1 : span f g (inr true) => l' x1	                    else fun x1 : span f g (inr false) => r' x1	                end (((span f g) _f g0) x0)) =	             match	               s as s0 return (forall x1 : span f g s0, P (colim s0 x1))	             with	             | inl u =>	                 match	                   u as u0	                   return	                     (forall x1 : span f g (inl u0), P (colim (inl u0) x1))	                 with	                 | tt =>	                     fun x1 : span f g (inl tt) =>	                     transport P (colimp (inl tt) (inr true) tt x1)	                       (l' (f x1))	                 end	             | inr b =>	                 if b as b0	                  return	                    (forall x1 : span f g (inr b0), P (colim (inr b0) x1))	                 then fun x1 : span f g (inr true) => l' x1	                 else fun x1 : span f g (inr false) => r' x1	             end x0)	        with	        | inl u =>	            fun j : PO_graph =>	            match	              j as s	              return	                (forall (g0 : PO_graph (inl u) s) 	                 (x0 : span f g (inl u)),	                 transport P (colimp (inl u) s g0 x0)	                   (match	                      s as s0	                      return (forall x1 : span f g s0, P (colim s0 x1))	                    with	                    | inl u0 =>	                        match	                          u0 as u1	                          return	                            (forall x1 : span f g (inl u1),	                             P (colim (inl u1) x1))	                        with	                        | tt =>	                            fun x1 : span f g (inl tt) =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end	                    | inr b =>	                        if b as b0	                         return	                           (forall x1 : span f g (inr b0),	                            P (colim (inr b0) x1))	                        then fun x1 : span f g (inr true) => l' x1	                        else fun x1 : span f g (inr false) => r' x1	                    end (((span f g) _f g0) x0)) =	                 match	                   u as u0	                   return	                     (forall x1 : span f g (inl u0), P (colim (inl u0) x1))	                 with	                 | tt =>	                     fun x1 : span f g (inl tt) =>	                     transport P (colimp (inl tt) (inr true) tt x1)	                       (l' (f x1))	                 end x0)	            with	            | inl u0 =>	                fun g0 : PO_graph (inl u) (inl u0) =>	                match	                  g0 as e	                  return	                    (forall x0 : span f g (inl u),	                     transport P (colimp (inl u) (inl u0) e x0)	                       (match	                          u0 as u1	                          return	                            (forall x1 : span f g (inl u1),	                             P (colim (inl u1) x1))	                        with	                        | tt =>	                            fun x1 : span f g (inl tt) =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end (((span f g) _f e) x0)) =	                     match	                       u as u1	                       return	                         (forall x1 : span f g (inl u1),	                          P (colim (inl u1) x1))	                     with	                     | tt =>	                         fun x1 : span f g (inl tt) =>	                         transport P (colimp (inl tt) (inr true) tt x1)	                           (l' (f x1))	                     end x0)	                with	                end	            | inr b =>	                fun g0 : PO_graph (inl u) (inr b) =>	                match	                  g0 as u0	                  return	                    (forall x0 : span f g (inl u),	                     transport P (colimp (inl u) (inr b) u0 x0)	                       ((if b as b0	                          return	                            (forall x1 : span f g (inr b0),	                             P (colim (inr b0) x1))	                         then fun x1 : span f g (inr true) => l' x1	                         else fun x1 : span f g (inr false) => r' x1)	                          (((span f g) _f u0) x0)) =	                     match	                       u as u1	                       return	                         (forall x1 : span f g (inl u1),	                          P (colim (inl u1) x1))	                     with	                     | tt =>	                         fun x1 : span f g (inl tt) =>	                         transport P (colimp (inl tt) (inr true) tt x1)	                           (l' (f x1))	                     end x0)	                with	                | tt =>	                    match	                      u as u0	                      return	                        (forall x0 : A,	                         transport P (colimp (inl u0) (inr b) tt x0)	                           ((if b as b0	                              return	                                (forall x1 : if b0 then B else C,	                                 P (colim (inr b0) x1))	                             then fun x1 : B => l' x1	                             else fun x1 : C => r' x1)	                              ((if b as b0	                                 return (Unit -> A -> if b0 then B else C)	                                then unit_name f	                                else unit_name g) tt x0)) =	                         match	                           u0 as u1	                           return (forall x1 : A, P (colim (inl u1) x1))	                         with	                         | tt =>	                             fun x1 : A =>	                             transport P (colimp (inl tt) (inr true) tt x1)	                               (l' (f x1))	                         end x0)	                    with	                    | tt =>	                        if b as b0	                         return	                           (forall x0 : A,	                            transport P (colimp (inl tt) (inr b0) tt x0)	                              ((if b0 as b1	                                 return	                                   (forall x1 : if b1 then B else C,	                                    P (colim (inr b1) x1))	                                then fun x1 : B => l' x1	                                else fun x1 : C => r' x1)	                                 ((if b0 as b1	                                    return (Unit -> A -> if b1 then B else C)	                                   then unit_name f	                                   else unit_name g) tt x0)) =	                            transport P (colimp (inl tt) (inr true) tt x0)	                              (l' (f x0)))	                        then fun x0 : A => 1	                        else	                         fun a : A =>	                         moveR_transport_p P	                           (colimp (inl tt) (inr false) tt a) 	                           (r' (g a))	                           (transport P (colimp (inl tt) (inr true) tt a)	                              (l' (f a)))	                           ((pp' a)^ @	                            transport_pp P (colimp (inl tt) (inr true) tt a)	                              (colimp (inl tt) (inr false) tt a)^ 	                              (l' (f a)))	                    end	                end	            end	        | inr b =>	            fun j : PO_graph =>	            match	              j as s	              return	                (forall (g0 : PO_graph (inr b) s) 	                 (x0 : span f g (inr b)),	                 transport P (colimp (inr b) s g0 x0)	                   (match	                      s as s0	                      return (forall x1 : span f g s0, P (colim s0 x1))	                    with	                    | inl u =>	                        match	                          u as u0	                          return	                            (forall x1 : span f g (inl u0),	                             P (colim (inl u0) x1))	                        with	                        | tt =>	                            fun x1 : span f g (inl tt) =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end	                    | inr b0 =>	                        if b0 as b1	                         return	                           (forall x1 : span f g (inr b1),	                            P (colim (inr b1) x1))	                        then fun x1 : span f g (inr true) => l' x1	                        else fun x1 : span f g (inr false) => r' x1	                    end (((span f g) _f g0) x0)) =	                 (if b as b0	                   return	                     (forall x1 : span f g (inr b0), P (colim (inr b0) x1))	                  then fun x1 : span f g (inr true) => l' x1	                  else fun x1 : span f g (inr false) => r' x1) x0)	            with	            | inl u =>	                fun g0 : PO_graph (inr b) (inl u) =>	                match	                  g0 as e	                  return	                    (forall x0 : span f g (inr b),	                     transport P (colimp (inr b) (inl u) e x0)	                       (match	                          u as u0	                          return	                            (forall x1 : span f g (inl u0),	                             P (colim (inl u0) x1))	                        with	                        | tt =>	                            fun x1 : span f g (inl tt) =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end (((span f g) _f e) x0)) =	                     (if b as b0	                       return	                         (forall x1 : span f g (inr b0),	                          P (colim (inr b0) x1))	                      then fun x1 : span f g (inr true) => l' x1	                      else fun x1 : span f g (inr false) => r' x1) x0)	                with	                end	            | inr b0 =>	                fun g0 : PO_graph (inr b) (inr b0) =>	                match	                  g0 as e	                  return	                    (forall x0 : span f g (inr b),	                     transport P (colimp (inr b) (inr b0) e x0)	                       ((if b0 as b1	                          return	                            (forall x1 : span f g (inr b1),	                             P (colim (inr b1) x1))	                         then fun x1 : span f g (inr true) => l' x1	                         else fun x1 : span f g (inr false) => r' x1)	                          (((span f g) _f e) x0)) =	                     (if b as b1	                       return	                         (forall x1 : span f g (inr b1),	                          P (colim (inr b1) x1))	                      then fun x1 : span f g (inr true) => l' x1	                      else fun x1 : span f g (inr false) => r' x1) x0)	                with	                end	            end	        end) (colim (inr false) (g x)))	    (apD	       (colimit_ind P	          (fun i : PO_graph =>	           match i as s return (forall x0 : span f g s, P (colim s x0)) with	           | inl u =>	               match	                 u as u0	                 return	                   (forall x0 : span f g (inl u0), P (colim (inl u0) x0))	               with	               | tt =>	                   fun x0 : span f g (inl tt) =>	                   transport P (colimp (inl tt) (inr true) tt x0) (l' (f x0))	               end	           | inr b =>	               if b as b0	                return (forall x0 : span f g (inr b0), P (colim (inr b0) x0))	               then fun x0 : span f g (inr true) => l' x0	               else fun x0 : span f g (inr false) => r' x0	           end)	          (fun i : PO_graph =>	           match	             i as s	             return	               (forall (j : PO_graph) (g0 : PO_graph s j) 	                (x0 : span f g s),	                transport P (colimp s j g0 x0)	                  (match	                     j as s0	                     return (forall x1 : span f g s0, P (colim s0 x1))	                   with	                   | inl u =>	                       match	                         u as u0	                         return	                           (forall x1 : span f g (inl u0),	                            P (colim (inl u0) x1))	                       with	                       | tt =>	                           fun x1 : span f g (inl tt) =>	                           transport P (colimp (inl tt) (inr true) tt x1)	                             (l' (f x1))	                       end	                   | inr b =>	                       if b as b0	                        return	                          (forall x1 : span f g (inr b0),	                           P (colim (inr b0) x1))	                       then fun x1 : span f g (inr true) => l' x1	                       else fun x1 : span f g (inr false) => r' x1	                   end (((span f g) _f g0) x0)) =	                match	                  s as s0 return (forall x1 : span f g s0, P (colim s0 x1))	                with	                | inl u =>	                    match	                      u as u0	                      return	                        (forall x1 : span f g (inl u0), P (colim (inl u0) x1))	                    with	                    | tt =>	                        fun x1 : span f g (inl tt) =>	                        transport P (colimp (inl tt) (inr true) tt x1)	                          (l' (f x1))	                    end	                | inr b =>	                    if b as b0	                     return	                       (forall x1 : span f g (inr b0), P (colim (inr b0) x1))	                    then fun x1 : span f g (inr true) => l' x1	                    else fun x1 : span f g (inr false) => r' x1	                end x0)	           with	           | inl u =>	               fun j : PO_graph =>	               match	                 j as s	                 return	                   (forall (g0 : PO_graph (inl u) s) 	                    (x0 : span f g (inl u)),	                    transport P (colimp (inl u) s g0 x0)	                      (match	                         s as s0	                         return (forall x1 : span f g s0, P (colim s0 x1))	                       with	                       | inl u0 =>	                           match	                             u0 as u1	                             return	                               (forall x1 : span f g (inl u1),	                                P (colim (inl u1) x1))	                           with	                           | tt =>	                               fun x1 : span f g (inl tt) =>	                               transport P (colimp (inl tt) (inr true) tt x1)	                                 (l' (f x1))	                           end	                       | inr b =>	                           if b as b0	                            return	                              (forall x1 : span f g (inr b0),	                               P (colim (inr b0) x1))	                           then fun x1 : span f g (inr true) => l' x1	                           else fun x1 : span f g (inr false) => r' x1	                       end (((span f g) _f g0) x0)) =	                    match	                      u as u0	                      return	                        (forall x1 : span f g (inl u0), P (colim (inl u0) x1))	                    with	                    | tt =>	                        fun x1 : span f g (inl tt) =>	                        transport P (colimp (inl tt) (inr true) tt x1)	                          (l' (f x1))	                    end x0)	               with	               | inl u0 =>	                   fun g0 : PO_graph (inl u) (inl u0) =>	                   match	                     g0 as e	                     return	                       (forall x0 : span f g (inl u),	                        transport P (colimp (inl u) (inl u0) e x0)	                          (match	                             u0 as u1	                             return	                               (forall x1 : span f g (inl u1),	                                P (colim (inl u1) x1))	                           with	                           | tt =>	                               fun x1 : span f g (inl tt) =>	                               transport P (colimp (inl tt) (inr true) tt x1)	                                 (l' (f x1))	                           end (((span f g) _f e) x0)) =	                        match	                          u as u1	                          return	                            (forall x1 : span f g (inl u1),	                             P (colim (inl u1) x1))	                        with	                        | tt =>	                            fun x1 : span f g (inl tt) =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end x0)	                   with	                   end	               | inr b =>	                   fun g0 : PO_graph (inl u) (inr b) =>	                   match	                     g0 as u0	                     return	                       (forall x0 : span f g (inl u),	                        transport P (colimp (inl u) (inr b) u0 x0)	                          ((if b as b0	                             return	                               (forall x1 : span f g (inr b0),	                                P (colim (inr b0) x1))	                            then fun x1 : span f g (inr true) => l' x1	                            else fun x1 : span f g (inr false) => r' x1)	                             (((span f g) _f u0) x0)) =	                        match	                          u as u1	                          return	                            (forall x1 : span f g (inl u1),	                             P (colim (inl u1) x1))	                        with	                        | tt =>	                            fun x1 : span f g (inl tt) =>	                            transport P (colimp (inl tt) (inr true) tt x1)	                              (l' (f x1))	                        end x0)	                   with	                   | tt =>	                       match	                         u as u0	                         return	                           (forall x0 : A,	                            transport P (colimp (inl u0) (inr b) tt x0)	                              ((if b as b0	                                 return	                                   (forall x1 : if b0 then B else C,	                                    P (colim (inr b0) x1))	                                then fun x1 : B => l' x1	                                else fun x1 : C => r' x1)	                                 ((if b as b0	                                    return (Unit -> A -> if b0 then B else C)	                                   then unit_name f	                                   else unit_name g) tt x0)) =	                            match	                              u0 as u1	                              return (forall x1 : A, P (colim (inl u1) x1))	                            with	                            | tt =>	                                fun x1 : A =>	                                transport P	                                  (colimp (inl tt) (inr true) tt x1)	                                  (l' (f x1))	                            end x0)	                       with	                       | tt =>	                           if b as b0	                            return	                              (forall x0 : A,	                               transport P (colimp (inl tt) (inr b0) tt x0)	                                 ((if b0 as b1	                                    return	                                      (forall x1 : if b1 then B else C,	                                       P (colim (inr b1) x1))	                                   then fun x1 : B => l' x1	                                   else fun x1 : C => r' x1)	                                    ((if b0 as b1	                                       return	                                         (Unit -> A -> if b1 then B else C)	                                      then unit_name f	                                      else unit_name g) tt x0)) =	                               transport P (colimp (inl tt) (inr true) tt x0)	                                 (l' (f x0)))	                           then fun x0 : A => 1	                           else	                            fun a : A =>	                            moveR_transport_p P	                              (colimp (inl tt) (inr false) tt a) 	                              (r' (g a))	                              (transport P (colimp (inl tt) (inr true) tt a)	                                 (l' (f a)))	                              ((pp' a)^ @	                               transport_pp P	                                 (colimp (inl tt) (inr true) tt a)	                                 (colimp (inl tt) (inr false) tt a)^	                                 (l' (f a)))	                       end	                   end	               end	           | inr b =>	               fun j : PO_graph =>	               match	                 j as s	                 return	                   (forall (g0 : PO_graph (inr b) s) 	                    (x0 : span f g (inr b)),	                    transport P (colimp (inr b) s g0 x0)	                      (match	                         s as s0	                         return (forall x1 : span f g s0, P (colim s0 x1))	                       with	                       | inl u =>	                           match	                             u as u0	                             return	                               (forall x1 : span f g (inl u0),	                                P (colim (inl u0) x1))	                           with	                           | tt =>	                               fun x1 : span f g (inl tt) =>	                               transport P (colimp (inl tt) (inr true) tt x1)	                                 (l' (f x1))	                           end	                       | inr b0 =>	                           if b0 as b1	                            return	                              (forall x1 : span f g (inr b1),	                               P (colim (inr b1) x1))	                           then fun x1 : span f g (inr true) => l' x1	                           else fun x1 : span f g (inr false) => r' x1	                       end (((span f g) _f g0) x0)) =	                    (if b as b0	                      return	                        (forall x1 : span f g (inr b0), P (colim (inr b0) x1))	                     then fun x1 : span f g (inr true) => l' x1	                     else fun x1 : span f g (inr false) => r' x1) x0)	               with	               | inl u =>	                   fun g0 : PO_graph (inr b) (inl u) =>	                   match	                     g0 as e	                     return	                       (forall x0 : span f g (inr b),	                        transport P (colimp (inr b) (inl u) e x0)	                          (match	                             u as u0	                             return	                               (forall x1 : span f g (inl u0),	                                P (colim (inl u0) x1))	                           with	                           | tt =>	                               fun x1 : span f g (inl tt) =>	                               transport P (colimp (inl tt) (inr true) tt x1)	                                 (l' (f x1))	                           end (((span f g) _f e) x0)) =	                        (if b as b0	                          return	                            (forall x1 : span f g (inr b0),	                             P (colim (inr b0) x1))	                         then fun x1 : span f g (inr true) => l' x1	                         else fun x1 : span f g (inr false) => r' x1) x0)	                   with	                   end	               | inr b0 =>	                   fun g0 : PO_graph (inr b) (inr b0) =>	                   match	                     g0 as e	                     return	                       (forall x0 : span f g (inr b),	                        transport P (colimp (inr b) (inr b0) e x0)	                          ((if b0 as b1	                             return	                               (forall x1 : span f g (inr b1),	                                P (colim (inr b1) x1))	                            then fun x1 : span f g (inr true) => l' x1	                            else fun x1 : span f g (inr false) => r' x1)	                             (((span f g) _f e) x0)) =	                        (if b as b1	                          return	                            (forall x1 : span f g (inr b1),	                             P (colim (inr b1) x1))	                         then fun x1 : span f g (inr true) => l' x1	                         else fun x1 : span f g (inr false) => r' x1) x0)	                   with	                   end	               end	           end)) (colimp (inl tt) (inr false) tt x))^ = 	  pp' x	";
            responses[i]=data;
          

            i = 109;
            data = "1 subgoal (ID 244)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  ============================	  transport_pp P (colimp (inl tt) (inr true) tt x)	    (colimp (inl tt) (inr false) tt x)^ (l' (f x)) @	  moveR_transport_V P (colimp (inl tt) (inr false) tt x)	    (transport P (colimp (inl tt) (inr true) tt x) (l' (f x))) 	    (r' (g x))	    (moveR_transport_p P (colimp (inl tt) (inr false) tt x) 	       (r' (g x)) (transport P (colimp (inl tt) (inr true) tt x) (l' (f x)))	       ((pp' x)^ @	        transport_pp P (colimp (inl tt) (inr true) tt x)	          (colimp (inl tt) (inr false) tt x)^ (l' (f x))))^ = 	  pp' x	";
            responses[i]=data;
          

            i = 110;
            data = "1 subgoal (ID 248)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  q := (pp' x)^ @	       transport_pp P (colimp (inl tt) (inr true) tt x)	         (colimp (inl tt) (inr false) tt x)^ (l' (f x))	   : r' (g x) =	     transport P (colimp (inl tt) (inr false) tt x)^	       (transport P (colimp (inl tt) (inr true) tt x) (l' (f x)))	  p := transport_pp P (colimp (inl tt) (inr true) tt x)	         (colimp (inl tt) (inr false) tt x)^ (l' (f x))	   : transport P	       (colimp (inl tt) (inr true) tt x @ (colimp (inl tt) (inr false) tt x)^)	       (l' (f x)) =	     transport P (colimp (inl tt) (inr false) tt x)^	       (transport P (colimp (inl tt) (inr true) tt x) (l' (f x)))	  ============================	  p @	  moveR_transport_V P (colimp (inl tt) (inr false) tt x)	    (transport P (colimp (inl tt) (inr true) tt x) (l' (f x))) 	    (r' (g x))	    (moveR_transport_p P (colimp (inl tt) (inr false) tt x) 	       (r' (g x)) (transport P (colimp (inl tt) (inr true) tt x) (l' (f x)))	       q)^ = pp' x	";
            responses[i]=data;
          

            i = 111;
            data = "1 subgoal (ID 250)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  q := (pp' x)^ @	       transport_pp P (colimp (inl tt) (inr true) tt x)	         (colimp (inl tt) (inr false) tt x)^ (l' (f x))	   : r' (g x) =	     transport P (colimp (inl tt) (inr false) tt x)^	       (transport P (colimp (inl tt) (inr true) tt x) (l' (f x)))	  p := transport_pp P (colimp (inl tt) (inr true) tt x)	         (colimp (inl tt) (inr false) tt x)^ (l' (f x))	   : transport P	       (colimp (inl tt) (inr true) tt x @ (colimp (inl tt) (inr false) tt x)^)	       (l' (f x)) =	     transport P (colimp (inl tt) (inr false) tt x)^	       (transport P (colimp (inl tt) (inr true) tt x) (l' (f x)))	  ============================	  p @	  moveR_transport_V P (colimp (inl tt) (inr false) tt x)	    (transport P (colimp (inl tt) (inr true) tt x) (l' (f x))) 	    (r' (g x))	    (moveL_transport_p P (colimp (inl tt) (inr false) tt x)	       (transport P (colimp (inl tt) (inr true) tt x) (l' (f x))) 	       (r' (g x)) q^) = pp' x	";
            responses[i]=data;
          

            i = 112;
            data = "1 subgoal (ID 253)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  q := (pp' x)^ @	       transport_pp P (colimp (inl tt) (inr true) tt x)	         (colimp (inl tt) (inr false) tt x)^ (l' (f x))	   : r' (g x) =	     transport P (colimp (inl tt) (inr false) tt x)^	       (transport P (colimp (inl tt) (inr true) tt x) (l' (f x)))	  p := transport_pp P (colimp (inl tt) (inr true) tt x)	         (colimp (inl tt) (inr false) tt x)^ (l' (f x))	   : transport P	       (colimp (inl tt) (inr true) tt x @ (colimp (inl tt) (inr false) tt x)^)	       (l' (f x)) =	     transport P (colimp (inl tt) (inr false) tt x)^	       (transport P (colimp (inl tt) (inr true) tt x) (l' (f x)))	  ============================	  p @ q^ = pp' x	";
            responses[i]=data;
          

            i = 113;
            data = "1 subgoal (ID 257)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  p := transport_pp P (colimp (inl tt) (inr true) tt x)	         (colimp (inl tt) (inr false) tt x)^ (l' (f x))	   : transport P	       (colimp (inl tt) (inr true) tt x @ (colimp (inl tt) (inr false) tt x)^)	       (l' (f x)) =	     transport P (colimp (inl tt) (inr false) tt x)^	       (transport P (colimp (inl tt) (inr true) tt x) (l' (f x)))	  ============================	  p @	  ((pp' x)^ @	   transport_pp P (colimp (inl tt) (inr true) tt x)	     (colimp (inl tt) (inr false) tt x)^ (l' (f x)))^ = 	  pp' x	";
            responses[i]=data;
          

            i = 114;
            data = "1 subgoal (ID 262)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : PO f g -> Type	  l' : forall b : B, P (pol b)	  r' : forall c : C, P (por c)	  pp' : forall a : A, transport P (popp a) (l' (f a)) = r' (g a)	  x : A	  p := transport_pp P (colimp (inl tt) (inr true) tt x)	         (colimp (inl tt) (inr false) tt x)^ (l' (f x))	   : transport P	       (colimp (inl tt) (inr true) tt x @ (colimp (inl tt) (inr false) tt x)^)	       (l' (f x)) =	     transport P (colimp (inl tt) (inr false) tt x)^	       (transport P (colimp (inl tt) (inr true) tt x) (l' (f x)))	  ============================	  p @	  ((transport_pp P (colimp (inl tt) (inr true) tt x)	      (colimp (inl tt) (inr false) tt x)^ (l' (f x)))^ @ 	   ((pp' x)^)^) = pp' x	";
            responses[i]=data;
          

            i = 115;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 116;
            data = "<infomsg>PO_ind_beta_pp is defined</infomsg>	";
            responses[i]=data;
          

            i = 117;
            data = "<infomsg>PO_rec is defined</infomsg>	";
            responses[i]=data;
          

            i = 118;
            data = "1 subgoal (ID 218)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : Type	  l' : B -> P	  r' : C -> P	  pp' : l' o f == r' o g	  ============================	  forall x : A, ap (PO_rec P l' r' pp') (popp x) = pp' x	";
            responses[i]=data;
          

            i = 119;
            data = "";
            responses[i]=data;
          

            i = 120;
            data = "1 subgoal (ID 219)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : Type	  l' : B -> P	  r' : C -> P	  pp' : l' o f == r' o g	  x : A	  ============================	  ap (PO_rec P l' r' pp') (popp x) = pp' x	";
            responses[i]=data;
          

            i = 121;
            data = "1 subgoal (ID 230)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : Type	  l' : B -> P	  r' : C -> P	  pp' : l' o f == r' o g	  x : A	  X : ap (colimit_rec P (Build_span_cocone l' r' pp'))	        (colimp (inl tt) (inr true) tt x) =	      qq (Build_span_cocone l' r' pp') (inl tt) (inr true) tt x	  ============================	  ap (PO_rec P l' r' pp') (popp x) = pp' x	";
            responses[i]=data;
          

            i = 122;
            data = "1 subgoal (ID 241)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : Type	  l' : B -> P	  r' : C -> P	  pp' : l' o f == r' o g	  x : A	  X : ap (colimit_rec P (Build_span_cocone l' r' pp'))	        (colimp (inl tt) (inr true) tt x) =	      qq (Build_span_cocone l' r' pp') (inl tt) (inr true) tt x	  X0 : ap (colimit_rec P (Build_span_cocone l' r' pp'))	         (colimp (inl tt) (inr false) tt x) =	       qq (Build_span_cocone l' r' pp') (inl tt) (inr false) tt x	  ============================	  ap (PO_rec P l' r' pp') (popp x) = pp' x	";
            responses[i]=data;
          

            i = 123;
            data = "1 subgoal (ID 245)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : Type	  l' : B -> P	  r' : C -> P	  pp' : (fun x : A => l' (f x)) == (fun x : A => r' (g x))	  x : A	  X : ap (colimit_rec P (Build_span_cocone l' r' pp'))	        (colimp (inl tt) (inr true) tt x) = pp' x	  X0 : ap (colimit_rec P (Build_span_cocone l' r' pp'))	         (colimp (inl tt) (inr false) tt x) = 1	  ============================	  ap (PO_rec P l' r' pp')	    (colimp (inl tt) (inr true) tt x @ (colimp (inl tt) (inr false) tt x)^) =	  pp' x	";
            responses[i]=data;
          

            i = 124;
            data = "1 subgoal (ID 264)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : Type	  l' : B -> P	  r' : C -> P	  pp' : (fun x : A => l' (f x)) == (fun x : A => r' (g x))	  x : A	  X : ap (colimit_rec P (Build_span_cocone l' r' pp'))	        (colimp (inl tt) (inr true) tt x) = pp' x	  X0 : ap (colimit_rec P (Build_span_cocone l' r' pp'))	         (colimp (inl tt) (inr false) tt x) = 1	  ============================	  ap (PO_rec P l' r' pp') (colimp (inl tt) (inr true) tt x) @	  ap (PO_rec P l' r' pp') (colimp (inl tt) (inr false) tt x)^ = 	  pp' x	";
            responses[i]=data;
          

            i = 125;
            data = "1 subgoal (ID 277)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : Type	  l' : B -> P	  r' : C -> P	  pp' : (fun x : A => l' (f x)) == (fun x : A => r' (g x))	  x : A	  X : ap (colimit_rec P (Build_span_cocone l' r' pp'))	        (colimp (inl tt) (inr true) tt x) = pp' x	  X0 : ap (colimit_rec P (Build_span_cocone l' r' pp'))	         (colimp (inl tt) (inr false) tt x) = 1	  ============================	  ap (PO_rec P l' r' pp') (colimp (inl tt) (inr true) tt x) @	  ap (PO_rec P l' r' pp') (colimp (inl tt) (inr false) tt x)^ = 	  pp' x @ 1	";
            responses[i]=data;
          

            i = 126;
            data = "1 subgoal (ID 289)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : Type	  l' : B -> P	  r' : C -> P	  pp' : (fun x : A => l' (f x)) == (fun x : A => r' (g x))	  x : A	  X : ap (colimit_rec P (Build_span_cocone l' r' pp'))	        (colimp (inl tt) (inr true) tt x) = pp' x	  X0 : ap (colimit_rec P (Build_span_cocone l' r' pp'))	         (colimp (inl tt) (inr false) tt x) = 1	  ============================	  ap (PO_rec P l' r' pp') (colimp (inl tt) (inr false) tt x)^ = 1	";
            responses[i]=data;
          

            i = 127;
            data = "1 subgoal (ID 302)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  P : Type	  l' : B -> P	  r' : C -> P	  pp' : (fun x : A => l' (f x)) == (fun x : A => r' (g x))	  x : A	  X : ap (colimit_rec P (Build_span_cocone l' r' pp'))	        (colimp (inl tt) (inr true) tt x) = pp' x	  X0 : ap (colimit_rec P (Build_span_cocone l' r' pp'))	         (colimp (inl tt) (inr false) tt x) = 1	  ============================	  ap (PO_rec P l' r' pp') (colimp (inl tt) (inr false) tt x)^ =	  (ap (colimit_rec P (Build_span_cocone l' r' pp'))	     (colimp (inl tt) (inr false) tt x))^	";
            responses[i]=data;
          

            i = 128;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 129;
            data = "<infomsg>PO_rec_beta_pp is defined</infomsg>	";
            responses[i]=data;
          

            i = 130;
            data = "";
            responses[i]=data;
          

            i = 131;
            data = "";
            responses[i]=data;
          

            i = 132;
            data = "";
            responses[i]=data;
          

            i = 133;
            data = "";
            responses[i]=data;
          

            i = 134;
            data = "1 subgoal (ID 224)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  IsEquiv por	";
            responses[i]=data;
          

            i = 135;
            data = "";
            responses[i]=data;
          

            i = 136;
            data = "3 subgoals (ID 250)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  PO f g -> C		subgoal 2 (ID 252) is:	 Sect ?g por	subgoal 3 (ID 254) is:	 Sect por ?g	";
            responses[i]=data;
          

            i = 137;
            data = "1 subgoal (ID 250)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  PO f g -> C	3 subgoals (ID 270)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  B -> C		subgoal 2 (ID 272) is:	 C -> C	subgoal 3 (ID 274) is:	 ?l' o f == ?r' o g	";
            responses[i]=data;
          

            i = 138;
            data = "1 subgoal (ID 270)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  B -> C	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	4 subgoals (ID 272)		subgoal 1 (ID 272) is:	 C -> C	subgoal 2 (ID 274) is:	 g o _^-1 o f == ?r' o g	subgoal 3 (ID 252) is:	 Sect (PO_rec C (g o _^-1) ?r' ?pp') por	subgoal 4 (ID 254) is:	 Sect por (PO_rec C (g o _^-1) ?r' ?pp')	";
            responses[i]=data;
          

            i = 139;
            data = "1 subgoal (ID 272)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  C -> C	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	3 subgoals (ID 274)		subgoal 1 (ID 274) is:	 g o _^-1 o f == idmap o g	subgoal 2 (ID 252) is:	 Sect (PO_rec C (g o _^-1) idmap ?pp') por	subgoal 3 (ID 254) is:	 Sect por (PO_rec C (g o _^-1) idmap ?pp')	";
            responses[i]=data;
          

            i = 140;
            data = "1 subgoal (ID 274)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  g o _^-1 o f == idmap o g	1 subgoal (ID 292)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  x : A	  ============================	  g (_^-1 (f x)) = g x	";
            responses[i]=data;
          

            i = 141;
            data = "1 subgoal (ID 295)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  x : A	  ============================	  _^-1 (f x) = x	";
            responses[i]=data;
          

            i = 142;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	2 subgoals (ID 252)		subgoal 1 (ID 252) is:	 Sect (PO_rec C (g o _^-1) idmap (fun x : A => ap g (eissect f x))) por	subgoal 2 (ID 254) is:	 Sect por (PO_rec C (g o _^-1) idmap (fun x : A => ap g (eissect f x)))	";
            responses[i]=data;
          

            i = 143;
            data = "1 subgoal (ID 252)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  Sect (PO_rec C (g o _^-1) idmap (fun x : A => ap g (eissect f x))) por	3 subgoals (ID 319)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  forall b : B, por (g (_^-1 b)) = pol b		subgoal 2 (ID 321) is:	 forall c : C, por c = por c	subgoal 3 (ID 323) is:	 forall a : A,	 transport	   (fun w : PO f g =>	    por	      (PO_rec C (fun x : B => g (_^-1 x)) idmap	         (fun x : A => ap g (eissect f x)) w) = w) 	   (popp a) (?Goal (f a)) = ?Goal0 (g a)	";
            responses[i]=data;
          

            i = 144;
            data = "1 subgoal (ID 319)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  forall b : B, por (g (_^-1 b)) = pol b	1 subgoal (ID 324)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  b : B	  ============================	  por (g (_^-1 b)) = pol b	";
            responses[i]=data;
          

            i = 145;
            data = "1 subgoal (ID 337)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  b : B	  ============================	  pol (f (_^-1 b)) = pol b	";
            responses[i]=data;
          

            i = 146;
            data = "1 subgoal (ID 340)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  b : B	  ============================	  f (_^-1 b) = b	";
            responses[i]=data;
          

            i = 147;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	3 subgoals (ID 321)		subgoal 1 (ID 321) is:	 forall c : C, por c = por c	subgoal 2 (ID 323) is:	 forall a : A,	 transport	   (fun w : PO f g =>	    por	      (PO_rec C (fun x : B => g (_^-1 x)) idmap	         (fun x : A => ap g (eissect f x)) w) = w) 	   (popp a) ((fun b : B => (popp (_^-1 b))^ @ ap pol (eisretr f b)) (f a)) =	 ?Goal (g a)	subgoal 3 (ID 254) is:	 Sect por (PO_rec C (g o _^-1) idmap (fun x : A => ap g (eissect f x)))	";
            responses[i]=data;
          

            i = 148;
            data = "1 subgoal (ID 321)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  forall c : C, por c = por c	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 subgoals (ID 323)		subgoal 1 (ID 323) is:	 forall a : A,	 transport	   (fun w : PO f g =>	    por	      (PO_rec C (fun x : B => g (_^-1 x)) idmap	         (fun x : A => ap g (eissect f x)) w) = w) 	   (popp a) ((fun b : B => (popp (_^-1 b))^ @ ap pol (eisretr f b)) (f a)) =	 (fun c : C => 1) (g a)	subgoal 2 (ID 254) is:	 Sect por (PO_rec C (g o _^-1) idmap (fun x : A => ap g (eissect f x)))	";
            responses[i]=data;
          

            i = 149;
            data = "1 subgoal (ID 323)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  forall a : A,	  transport	    (fun w : PO f g =>	     por	       (PO_rec C (fun x : B => g (_^-1 x)) idmap	          (fun x : A => ap g (eissect f x)) w) = w) 	    (popp a) ((fun b : B => (popp (_^-1 b))^ @ ap pol (eisretr f b)) (f a)) =	  (fun c : C => 1) (g a)	1 subgoal (ID 347)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  a : A	  ============================	  transport	    (fun w : PO f g =>	     por	       (PO_rec C (fun x : B => g (_^-1 x)) idmap	          (fun x : A => ap g (eissect f x)) w) = w) 	    (popp a) ((popp (_^-1 (f a)))^ @ ap pol (eisretr f (f a))) = 1	";
            responses[i]=data;
          

            i = 150;
            data = "1 subgoal (ID 364)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  a : A	  ============================	  ((ap	      (fun x : PO f g =>	       por	         (PO_rec C (fun x0 : B => g (_^-1 x0)) idmap	            (fun x0 : A => ap g (eissect f x0)) x)) 	      (popp a))^ @ ((popp (_^-1 (f a)))^ @ ap pol (eisretr f (f a)))) @	  popp a = 1	";
            responses[i]=data;
          

            i = 151;
            data = "1 subgoal (ID 371)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  a : A	  ============================	  ((ap por	      (ap	         (PO_rec C (fun x : B => g (_^-1 x)) idmap	            (fun x : A => ap g (eissect f x))) (popp a)))^ @	   ((popp (_^-1 (f a)))^ @ ap pol (eisretr f (f a)))) @ 	  popp a = 1	";
            responses[i]=data;
          

            i = 152;
            data = "1 subgoal (ID 375)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  a : A	  ============================	  ((ap por (ap g (eissect f a)))^ @	   ((popp (_^-1 (f a)))^ @ ap pol (eisretr f (f a)))) @ 	  popp a = 1	";
            responses[i]=data;
          

            i = 153;
            data = "1 subgoal (ID 378)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  a : A	  ============================	  ((ap por (ap g (eissect f a)))^ @	   ((popp (_^-1 (f a)))^ @ ap pol (ap f (eissect _ a)))) @ 	  popp a = 1	";
            responses[i]=data;
          

            i = 154;
            data = "1 subgoal (ID 443)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  a : A	  ============================	  ((ap por (ap g 1))^ @ ((popp (_^-1 (f a)))^ @ ap pol (ap f 1))) @	  popp (_^-1 (f a)) = 1	";
            responses[i]=data;
          

            i = 155;
            data = "1 subgoal (ID 445)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  a : A	  ============================	  (1 @ ((popp (_^-1 (f a)))^ @ 1)) @ popp (_^-1 (f a)) = 1	";
            responses[i]=data;
          

            i = 156;
            data = "1 subgoal (ID 456)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  a : A	  ============================	  (popp (_^-1 (f a)))^ @ popp (_^-1 (f a)) = 1	";
            responses[i]=data;
          

            i = 157;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 254)		subgoal 1 (ID 254) is:	 Sect por (PO_rec C (g o _^-1) idmap (fun x : A => ap g (eissect f x)))	";
            responses[i]=data;
          

            i = 158;
            data = "1 subgoal (ID 254)	  	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Hf : IsEquiv f	  ============================	  Sect por (PO_rec C (g o _^-1) idmap (fun x : A => ap g (eissect f x)))	No more subgoals.	";
            responses[i]=data;
          

            i = 159;
            data = "<infomsg>PO_of_equiv is defined</infomsg>	";
            responses[i]=data;
          

            i = 160;
            data = "";
            responses[i]=data;
          

            i = 161;
            data = "";
            responses[i]=data;
          

            i = 162;
            data = "";
            responses[i]=data;
          

            i = 163;
            data = "";
            responses[i]=data;
          

            i = 164;
            data = "";
            responses[i]=data;
          

            i = 165;
            data = "";
            responses[i]=data;
          

            i = 166;
            data = "";
            responses[i]=data;
          

            i = 167;
            data = "";
            responses[i]=data;
          

            i = 168;
            data = "";
            responses[i]=data;
          

            i = 169;
            data = "";
            responses[i]=data;
          

            i = 170;
            data = "<infomsg>H is declared</infomsg>	<infomsg>A is declared</infomsg>	<infomsg>B is declared</infomsg>	<infomsg>C is declared</infomsg>	<infomsg>f is declared</infomsg>	<infomsg>g is declared</infomsg>	";
            responses[i]=data;
          

            i = 171;
            data = "1 subgoal (ID 8)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  is_PO f g (pushout f g)	";
            responses[i]=data;
          

            i = 172;
            data = "";
            responses[i]=data;
          

            i = 173;
            data = "2 subgoals (ID 10)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  cocone (span f g) (pushout f g)		subgoal 2 (ID 11) is:	 is_universal ?C	";
            responses[i]=data;
          

            i = 174;
            data = "1 subgoal (ID 10)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  cocone (span f g) (pushout f g)	3 subgoals (ID 43)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  B -> pushout f g		subgoal 2 (ID 45) is:	 C -> pushout f g	subgoal 3 (ID 47) is:	 ?inl' o f == ?inr' o g	";
            responses[i]=data;
          

            i = 175;
            data = "1 subgoal (ID 43)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  B -> pushout f g	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	3 subgoals (ID 45)		subgoal 1 (ID 45) is:	 C -> pushout f g	subgoal 2 (ID 47) is:	 push o inl o f == ?inr' o g	subgoal 3 (ID 11) is:	 is_universal (Build_span_cocone (push o inl) ?inr' ?pp')	";
            responses[i]=data;
          

            i = 176;
            data = "1 subgoal (ID 45)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  C -> pushout f g	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 subgoals (ID 47)		subgoal 1 (ID 47) is:	 push o inl o f == push o inr o g	subgoal 2 (ID 11) is:	 is_universal (Build_span_cocone (push o inl) (push o inr) ?pp')	";
            responses[i]=data;
          

            i = 177;
            data = "1 subgoal (ID 47)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  push o inl o f == push o inr o g	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 11)		subgoal 1 (ID 11) is:	 is_universal (Build_span_cocone (push o inl) (push o inr) pp)	";
            responses[i]=data;
          

            i = 178;
            data = "1 subgoal (ID 11)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  is_universal (Build_span_cocone (push o inl) (push o inr) pp)	3 subgoals (ID 112)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  ============================	  cocone (span f g) Y -> pushout f g -> Y		subgoal 2 (ID 114) is:	 Sect ?g	   (postcompose_cocone	      (Build_span_cocone (fun x : B => push (inl x))	         (fun x : C => push (inr x)) pp))	subgoal 3 (ID 116) is:	 Sect	   (postcompose_cocone	      (Build_span_cocone (fun x : B => push (inl x))	         (fun x : C => push (inr x)) pp)) ?g	";
            responses[i]=data;
          

            i = 179;
            data = "1 subgoal (ID 112)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  ============================	  cocone (span f g) Y -> pushout f g -> Y	1 subgoal (ID 117)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : cocone (span f g) Y	  ============================	  pushout f g -> Y	";
            responses[i]=data;
          

            i = 180;
            data = "3 subgoals (ID 158)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : cocone (span f g) Y	  ============================	  B -> Y		subgoal 2 (ID 160) is:	 C -> Y	subgoal 3 (ID 162) is:	 forall a : A, ?pushb (f a) = ?pushc (g a)	";
            responses[i]=data;
          

            i = 181;
            data = "1 subgoal (ID 158)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : cocone (span f g) Y	  ============================	  B -> Y	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	4 subgoals (ID 160)		subgoal 1 (ID 160) is:	 C -> Y	subgoal 2 (ID 162) is:	 forall a : A, pol' Co (f a) = ?pushc (g a)	subgoal 3 (ID 114) is:	 Sect (fun Co : cocone (span f g) Y => pushout_rec Y (pol' Co) ?pushc ?pp')	   (postcompose_cocone	      (Build_span_cocone (fun x : B => push (inl x))	         (fun x : C => push (inr x)) pp))	subgoal 4 (ID 116) is:	 Sect	   (postcompose_cocone	      (Build_span_cocone (fun x : B => push (inl x))	         (fun x : C => push (inr x)) pp))	   (fun Co : cocone (span f g) Y => pushout_rec Y (pol' Co) ?pushc ?pp')	";
            responses[i]=data;
          

            i = 182;
            data = "1 subgoal (ID 160)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : cocone (span f g) Y	  ============================	  C -> Y	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	3 subgoals (ID 162)		subgoal 1 (ID 162) is:	 forall a : A, pol' Co (f a) = por' Co (g a)	subgoal 2 (ID 114) is:	 Sect	   (fun Co : cocone (span f g) Y => pushout_rec Y (pol' Co) (por' Co) ?pp')	   (postcompose_cocone	      (Build_span_cocone (fun x : B => push (inl x))	         (fun x : C => push (inr x)) pp))	subgoal 3 (ID 116) is:	 Sect	   (postcompose_cocone	      (Build_span_cocone (fun x : B => push (inl x))	         (fun x : C => push (inr x)) pp))	   (fun Co : cocone (span f g) Y => pushout_rec Y (pol' Co) (por' Co) ?pp')	";
            responses[i]=data;
          

            i = 183;
            data = "1 subgoal (ID 162)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : cocone (span f g) Y	  ============================	  forall a : A, pol' Co (f a) = por' Co (g a)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 subgoals (ID 114)		subgoal 1 (ID 114) is:	 Sect	   (fun Co : cocone (span f g) Y =>	    pushout_rec Y (pol' Co) (por' Co) (popp' Co))	   (postcompose_cocone	      (Build_span_cocone (fun x : B => push (inl x))	         (fun x : C => push (inr x)) pp))	subgoal 2 (ID 116) is:	 Sect	   (postcompose_cocone	      (Build_span_cocone (fun x : B => push (inl x))	         (fun x : C => push (inr x)) pp))	   (fun Co : cocone (span f g) Y =>	    pushout_rec Y (pol' Co) (por' Co) (popp' Co))	";
            responses[i]=data;
          

            i = 184;
            data = "1 subgoal (ID 114)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  ============================	  Sect	    (fun Co : cocone (span f g) Y =>	     pushout_rec Y (pol' Co) (por' Co) (popp' Co))	    (postcompose_cocone	       (Build_span_cocone (fun x : B => push (inl x))	          (fun x : C => push (inr x)) pp))	1 subgoal (ID 186)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : PO_graph, span f g i -> Y	  Co' : forall (i j : PO_graph) (g0 : PO_graph i j) 	        (x : span f g i), Co j (((span f g) _f g0) x) = Co i x	  ============================	  postcompose_cocone	    (Build_span_cocone (fun x : B => push (inl x))	       (fun x : C => push (inr x)) pp)	    (pushout_rec Y (pol' {| q := Co; qq := Co' |})	       (por' {| q := Co; qq := Co' |}) (popp' {| q := Co; qq := Co' |})) =	  {| q := Co; qq := Co' |}	";
            responses[i]=data;
          

            i = 185;
            data = "2 subgoals (ID 212)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : PO_graph, span f g i -> Y	  Co' : forall (i j : PO_graph) (g0 : PO_graph i j) 	        (x : span f g i), Co j (((span f g) _f g0) x) = Co i x	  ============================	  forall i : Unit + Bool,	  (fun x : match i with	           | inl _ => A	           | inr true => B	           | inr false => C	           end =>	   pushout_rec Y (Co (inr true)) (Co (inr false))	     (popp' {| q := Co; qq := Co' |})	     (match	        i as s	        return	          (match s with	           | inl _ => A	           | inr true => B	           | inr false => C	           end -> pushout f g)	      with	      | inl _ => fun x0 : A => push (inr (g x0))	      | inr b =>	          if b as b0 return ((if b0 then B else C) -> pushout f g)	          then fun x0 : B => push (inl x0)	          else fun x0 : C => push (inr x0)	      end x)) == Co i		subgoal 2 (ID 214) is:	 forall (i j : Unit + Bool)	 (g0 : match i with	       | inl _ =>	           fun X : Unit + Bool =>	           match X with	           | inl _ => Empty	           | inr _ => Unit	           end	       | inr _ =>	           fun X : Unit + Bool => match X with	                                  | inl _ | _ => Empty	                                  end	       end j)	 (x : match i with	      | inl _ => A	      | inr true => B	      | inr false => C	      end),	 ap	   (pushout_rec Y (Co (inr true)) (Co (inr false))	      (popp' {| q := Co; qq := Co' |}))	   (match	      i as s	      return	        (forall (j0 : Unit + Bool)	         (g1 : match s with	               | inl _ =>	                   fun X : Unit + Bool =>	                   match X with	                   | inl _ => Empty	                   | inr _ => Unit	                   end	               | inr _ =>	                   fun X : Unit + Bool =>	                   match X with	                   | inl _ | _ => Empty	                   end	               end j0)	         (x0 : match s with	               | inl _ => A	               | inr true => B	               | inr false => C	               end),	         match	           j0 as s0	           return	             (match s0 with	              | inl _ => A	              | inr true => B	              | inr false => C	              end -> pushout f g)	         with	         | inl _ => fun x1 : A => push (inr (g x1))	         | inr b =>	             if b as b0 return ((if b0 then B else C) -> pushout f g)	             then fun x1 : B => push (inl x1)	             else fun x1 : C => push (inr x1)	         end	           (match	              s as s0	              return	                (forall j1 : Unit + Bool,	                 match s0 with	                 | inl _ =>	                     fun X : Unit + Bool =>	                     match X with	                     | inl _ => Empty	                     | inr _ => Unit	                     end	                 | inr _ =>	                     fun X : Unit + Bool =>	                     match X with	                     | inl _ | _ => Empty	                     end	                 end j1 ->	                 match s0 with	                 | inl _ => A	                 | inr true => B	                 | inr false => C	                 end ->	                 match j1 with	                 | inl _ => A	                 | inr true => B	                 | inr false => C	                 end)	            with	            | inl _ =>	                fun j1 : Unit + Bool =>	                match	                  j1 as s0	                  return	                    (match s0 with	                     | inl _ => Empty	                     | inr _ => Unit	                     end ->	                     A ->	                     match s0 with	                     | inl _ => A	                     | inr true => B	                     | inr false => C	                     end)	                with	                | inl _ =>	                    fun (u : Empty) (_ : A) =>	                    Empty_rect (fun _ : Empty => A) u	                | inr j2 =>	                    fun u : Unit =>	                    (if j2 as b return (Unit -> A -> if b then B else C)	                     then unit_name f	                     else unit_name g) u	                end	            | inr i0 =>	                fun j1 : Unit + Bool =>	                match	                  j1 as s0	                  return	                    (match s0 with	                     | inl _ | _ => Empty	                     end ->	                     (if i0 then B else C) ->	                     match s0 with	                     | inl _ => A	                     | inr true => B	                     | inr false => C	                     end)	                with	                | inl _ =>	                    fun (u : Empty) (_ : if i0 then B else C) =>	                    Empty_rect (fun _ : Empty => A) u	                | inr j2 =>	                    fun (u : Empty) (_ : if i0 then B else C) =>	                    Empty_rect (fun _ : Empty => if j2 then B else C) u	                end	            end j0 g1 x0) =	         match	           s as s0	           return	             (match s0 with	              | inl _ => A	              | inr true => B	              | inr false => C	              end -> pushout f g)	         with	         | inl _ => fun x1 : A => push (inr (g x1))	         | inr b =>	             if b as b0 return ((if b0 then B else C) -> pushout f g)	             then fun x1 : B => push (inl x1)	             else fun x1 : C => push (inr x1)	         end x0)	    with	    | inl _ =>	        fun j0 : Unit + Bool =>	        match	          j0 as s	          return	            (forall (g1 : match s with	                          | inl _ => Empty	                          | inr _ => Unit	                          end) (x0 : A),	             match	               s as s0	               return	                 (match s0 with	                  | inl _ => A	                  | inr true => B	                  | inr false => C	                  end -> pushout f g)	             with	             | inl _ => fun x1 : A => push (inr (g x1))	             | inr b =>	                 if b as b0 return ((if b0 then B else C) -> pushout f g)	                 then fun x1 : B => push (inl x1)	                 else fun x1 : C => push (inr x1)	             end	               (match	                  s as s0	                  return	                    (match s0 with	                     | inl _ => Empty	                     | inr _ => Unit	                     end ->	                     A ->	                     match s0 with	                     | inl _ => A	                     | inr true => B	                     | inr false => C	                     end)	                with	                | inl _ =>	                    fun (u0 : Empty) (_ : A) =>	                    Empty_rect (fun _ : Empty => A) u0	                | inr j1 =>	                    fun u0 : Unit =>	                    (if j1 as b return (Unit -> A -> if b then B else C)	                     then unit_name f	                     else unit_name g) u0	                end g1 x0) = push (inr (g x0)))	        with	        | inl _ =>	            fun g1 : Empty =>	            match	              g1 as e	              return	                (forall x0 : A,	                 push (inr (g (Empty_rect (fun _ : Empty => A) e))) =	                 push (inr (g x0)))	            with	            end	        | inr b =>	            fun g1 : Unit =>	            match	              g1 as u0	              return	                (forall x0 : A,	                 (if b as b0 return ((if b0 then B else C) -> pushout f g)	                  then fun x1 : B => push (inl x1)	                  else fun x1 : C => push (inr x1))	                   ((if b as b0 return (Unit -> A -> if b0 then B else C)	                     then unit_name f	                     else unit_name g) u0 x0) = push (inr (g x0)))	            with	            | tt =>	                if b as b0	                 return	                   (forall x0 : A,	                    (if b0 as b1	                      return ((if b1 then B else C) -> pushout f g)	                     then fun x1 : B => push (inl x1)	                     else fun x1 : C => push (inr x1))	                      ((if b0 as b1 return (Unit -> A -> if b1 then B else C)	                        then unit_name f	                        else unit_name g) tt x0) = 	                    push (inr (g x0)))	                then pp	                else fun x0 : A => 1	            end	        end	    | inr b =>	        fun j0 : Unit + Bool =>	        match	          j0 as s	          return	            (forall (g1 : match s with	                          | inl _ | _ => Empty	                          end) (x0 : if b then B else C),	             match	               s as s0	               return	                 (match s0 with	                  | inl _ => A	                  | inr true => B	                  | inr false => C	                  end -> pushout f g)	             with	             | inl _ => fun x1 : A => push (inr (g x1))	             | inr b0 =>	                 if b0 as b1 return ((if b1 then B else C) -> pushout f g)	                 then fun x1 : B => push (inl x1)	                 else fun x1 : C => push (inr x1)	             end	               (match	                  s as s0	                  return	                    (match s0 with	                     | inl _ | _ => Empty	                     end ->	                     (if b then B else C) ->	                     match s0 with	                     | inl _ => A	                     | inr true => B	                     | inr false => C	                     end)	                with	                | inl _ =>	                    fun (u : Empty) (_ : if b then B else C) =>	                    Empty_rect (fun _ : Empty => A) u	                | inr j1 =>	                    fun (u : Empty) (_ : if b then B else C) =>	                    Empty_rect (fun _ : Empty => if j1 then B else C) u	                end g1 x0) =	             (if b as b0 return ((if b0 then B else C) -> pushout f g)	              then fun x1 : B => push (inl x1)	              else fun x1 : C => push (inr x1)) x0)	        with	        | inl _ =>	            fun g1 : Empty =>	            match	              g1 as e	              return	                (forall x0 : if b then B else C,	                 push (inr (g (Empty_rect (fun _ : Empty => A) e))) =	                 (if b as b0 return ((if b0 then B else C) -> pushout f g)	                  then fun x1 : B => push (inl x1)	                  else fun x1 : C => push (inr x1)) x0)	            with	            end	        | inr b0 =>	            fun g1 : Empty =>	            match	              g1 as e	              return	                (forall x0 : if b then B else C,	                 (if b0 as b1 return ((if b1 then B else C) -> pushout f g)	                  then fun x1 : B => push (inl x1)	                  else fun x1 : C => push (inr x1))	                   (Empty_rect (fun _ : Empty => if b0 then B else C) e) =	                 (if b as b1 return ((if b1 then B else C) -> pushout f g)	                  then fun x1 : B => push (inl x1)	                  else fun x1 : C => push (inr x1)) x0)	            with	            end	        end	    end j g0 x) @ ?Goal i x =	 ?Goal j	   (match	      i as s	      return	        (forall j0 : Unit + Bool,	         match s with	         | inl _ =>	             fun X : Unit + Bool =>	             match X with	             | inl _ => Empty	             | inr _ => Unit	             end	         | inr _ =>	             fun X : Unit + Bool => match X with	                                    | inl _ | _ => Empty	                                    end	         end j0 ->	         match s with	         | inl _ => A	         | inr true => B	         | inr false => C	         end ->	         match j0 with	         | inl _ => A	         | inr true => B	         | inr false => C	         end)	    with	    | inl _ =>	        fun j0 : Unit + Bool =>	        match	          j0 as s	          return	            (match s with	             | inl _ => Empty	             | inr _ => Unit	             end ->	             A ->	             match s with	             | inl _ => A	             | inr true => B	             | inr false => C	             end)	        with	        | inl _ =>	            fun (u : Empty) (_ : A) => Empty_rect (fun _ : Empty => A) u	        | inr j1 =>	            fun u : Unit =>	            (if j1 as b return (Unit -> A -> if b then B else C)	             then unit_name f	             else unit_name g) u	        end	    | inr i0 =>	        fun j0 : Unit + Bool =>	        match	          j0 as s	          return	            (match s with	             | inl _ | _ => Empty	             end ->	             (if i0 then B else C) ->	             match s with	             | inl _ => A	             | inr true => B	             | inr false => C	             end)	        with	        | inl _ =>	            fun (u : Empty) (_ : if i0 then B else C) =>	            Empty_rect (fun _ : Empty => A) u	        | inr j1 =>	            fun (u : Empty) (_ : if i0 then B else C) =>	            Empty_rect (fun _ : Empty => if j1 then B else C) u	        end	    end j g0 x) @ Co' i j g0 x	";
            responses[i]=data;
          

            i = 186;
            data = "1 subgoal (ID 212)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : PO_graph, span f g i -> Y	  Co' : forall (i j : PO_graph) (g0 : PO_graph i j) 	        (x : span f g i), Co j (((span f g) _f g0) x) = Co i x	  ============================	  forall i : Unit + Bool,	  (fun x : match i with	           | inl _ => A	           | inr true => B	           | inr false => C	           end =>	   pushout_rec Y (Co (inr true)) (Co (inr false))	     (popp' {| q := Co; qq := Co' |})	     (match	        i as s	        return	          (match s with	           | inl _ => A	           | inr true => B	           | inr false => C	           end -> pushout f g)	      with	      | inl _ => fun x0 : A => push (inr (g x0))	      | inr b =>	          if b as b0 return ((if b0 then B else C) -> pushout f g)	          then fun x0 : B => push (inl x0)	          else fun x0 : C => push (inr x0)	      end x)) == Co i	3 subgoals (ID 235)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : PO_graph, span f g i -> Y	  Co' : forall (i j : PO_graph) (g0 : PO_graph i j) 	        (x : span f g i), Co j (((span f g) _f g0) x) = Co i x	  x : A	  ============================	  Co (inr false) (g x) = Co (inl tt) x		subgoal 2 (ID 237) is:	 Co (inr true) x = Co (inr true) x	subgoal 3 (ID 239) is:	 Co (inr false) x = Co (inr false) x	";
            responses[i]=data;
          

            i = 187;
            data = "1 subgoal (ID 235)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : PO_graph, span f g i -> Y	  Co' : forall (i j : PO_graph) (g0 : PO_graph i j) 	        (x : span f g i), Co j (((span f g) _f g0) x) = Co i x	  x : A	  ============================	  Co (inr false) (g x) = Co (inl tt) x	<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	4 subgoals (ID 237)		subgoal 1 (ID 237) is:	 Co (inr true) x = Co (inr true) x	subgoal 2 (ID 239) is:	 Co (inr false) x = Co (inr false) x	subgoal 3 (ID 214) is:	 forall (i j : Unit + Bool)	 (g0 : match i with	       | inl _ =>	           fun X : Unit + Bool =>	           match X with	           | inl _ => Empty	           | inr _ => Unit	           end	       | inr _ =>	           fun X : Unit + Bool => match X with	                                  | inl _ | _ => Empty	                                  end	       end j)	 (x : match i with	      | inl _ => A	      | inr true => B	      | inr false => C	      end),	 ap	   (pushout_rec Y (Co (inr true)) (Co (inr false))	      (popp' {| q := Co; qq := Co' |}))	   (match	      i as s	      return	        (forall (j0 : Unit + Bool)	         (g1 : match s with	               | inl _ =>	                   fun X : Unit + Bool =>	                   match X with	                   | inl _ => Empty	                   | inr _ => Unit	                   end	               | inr _ =>	                   fun X : Unit + Bool =>	                   match X with	                   | inl _ | _ => Empty	                   end	               end j0)	         (x0 : match s with	               | inl _ => A	               | inr true => B	               | inr false => C	               end),	         match	           j0 as s0	           return	             (match s0 with	              | inl _ => A	              | inr true => B	              | inr false => C	              end -> pushout f g)	         with	         | inl _ => fun x1 : A => push (inr (g x1))	         | inr b =>	             if b as b0 return ((if b0 then B else C) -> pushout f g)	             then fun x1 : B => push (inl x1)	             else fun x1 : C => push (inr x1)	         end	           (match	              s as s0	              return	                (forall j1 : Unit + Bool,	                 match s0 with	                 | inl _ =>	                     fun X : Unit + Bool =>	                     match X with	                     | inl _ => Empty	                     | inr _ => Unit	                     end	                 | inr _ =>	                     fun X : Unit + Bool =>	                     match X with	                     | inl _ | _ => Empty	                     end	                 end j1 ->	                 match s0 with	                 | inl _ => A	                 | inr true => B	                 | inr false => C	                 end ->	                 match j1 with	                 | inl _ => A	                 | inr true => B	                 | inr false => C	                 end)	            with	            | inl _ =>	                fun j1 : Unit + Bool =>	                match	                  j1 as s0	                  return	                    (match s0 with	                     | inl _ => Empty	                     | inr _ => Unit	                     end ->	                     A ->	                     match s0 with	                     | inl _ => A	                     | inr true => B	                     | inr false => C	                     end)	                with	                | inl _ =>	                    fun (u : Empty) (_ : A) =>	                    Empty_rect (fun _ : Empty => A) u	                | inr j2 =>	                    fun u : Unit =>	                    (if j2 as b return (Unit -> A -> if b then B else C)	                     then unit_name f	                     else unit_name g) u	                end	            | inr i0 =>	                fun j1 : Unit + Bool =>	                match	                  j1 as s0	                  return	                    (match s0 with	                     | inl _ | _ => Empty	                     end ->	                     (if i0 then B else C) ->	                     match s0 with	                     | inl _ => A	                     | inr true => B	                     | inr false => C	                     end)	                with	                | inl _ =>	                    fun (u : Empty) (_ : if i0 then B else C) =>	                    Empty_rect (fun _ : Empty => A) u	                | inr j2 =>	                    fun (u : Empty) (_ : if i0 then B else C) =>	                    Empty_rect (fun _ : Empty => if j2 then B else C) u	                end	            end j0 g1 x0) =	         match	           s as s0	           return	             (match s0 with	              | inl _ => A	              | inr true => B	              | inr false => C	              end -> pushout f g)	         with	         | inl _ => fun x1 : A => push (inr (g x1))	         | inr b =>	             if b as b0 return ((if b0 then B else C) -> pushout f g)	             then fun x1 : B => push (inl x1)	             else fun x1 : C => push (inr x1)	         end x0)	    with	    | inl _ =>	        fun j0 : Unit + Bool =>	        match	          j0 as s	          return	            (forall (g1 : match s with	                          | inl _ => Empty	                          | inr _ => Unit	                          end) (x0 : A),	             match	               s as s0	               return	                 (match s0 with	                  | inl _ => A	                  | inr true => B	                  | inr false => C	                  end -> pushout f g)	             with	             | inl _ => fun x1 : A => push (inr (g x1))	             | inr b =>	                 if b as b0 return ((if b0 then B else C) -> pushout f g)	                 then fun x1 : B => push (inl x1)	                 else fun x1 : C => push (inr x1)	             end	               (match	                  s as s0	                  return	                    (match s0 with	                     | inl _ => Empty	                     | inr _ => Unit	                     end ->	                     A ->	                     match s0 with	                     | inl _ => A	                     | inr true => B	                     | inr false => C	                     end)	                with	                | inl _ =>	                    fun (u0 : Empty) (_ : A) =>	                    Empty_rect (fun _ : Empty => A) u0	                | inr j1 =>	                    fun u0 : Unit =>	                    (if j1 as b return (Unit -> A -> if b then B else C)	                     then unit_name f	                     else unit_name g) u0	                end g1 x0) = push (inr (g x0)))	        with	        | inl _ =>	            fun g1 : Empty =>	            match	              g1 as e	              return	                (forall x0 : A,	                 push (inr (g (Empty_rect (fun _ : Empty => A) e))) =	                 push (inr (g x0)))	            with	            end	        | inr b =>	            fun g1 : Unit =>	            match	              g1 as u0	              return	                (forall x0 : A,	                 (if b as b0 return ((if b0 then B else C) -> pushout f g)	                  then fun x1 : B => push (inl x1)	                  else fun x1 : C => push (inr x1))	                   ((if b as b0 return (Unit -> A -> if b0 then B else C)	                     then unit_name f	                     else unit_name g) u0 x0) = push (inr (g x0)))	            with	            | tt =>	                if b as b0	                 return	                   (forall x0 : A,	                    (if b0 as b1	                      return ((if b1 then B else C) -> pushout f g)	                     then fun x1 : B => push (inl x1)	                     else fun x1 : C => push (inr x1))	                      ((if b0 as b1 return (Unit -> A -> if b1 then B else C)	                        then unit_name f	                        else unit_name g) tt x0) = 	                    push (inr (g x0)))	                then pp	                else fun x0 : A => 1	            end	        end	    | inr b =>	        fun j0 : Unit + Bool =>	        match	          j0 as s	          return	            (forall (g1 : match s with	                          | inl _ | _ => Empty	                          end) (x0 : if b then B else C),	             match	               s as s0	               return	                 (match s0 with	                  | inl _ => A	                  | inr true => B	                  | inr false => C	                  end -> pushout f g)	             with	             | inl _ => fun x1 : A => push (inr (g x1))	             | inr b0 =>	                 if b0 as b1 return ((if b1 then B else C) -> pushout f g)	                 then fun x1 : B => push (inl x1)	                 else fun x1 : C => push (inr x1)	             end	               (match	                  s as s0	                  return	                    (match s0 with	                     | inl _ | _ => Empty	                     end ->	                     (if b then B else C) ->	                     match s0 with	                     | inl _ => A	                     | inr true => B	                     | inr false => C	                     end)	                with	                | inl _ =>	                    fun (u : Empty) (_ : if b then B else C) =>	                    Empty_rect (fun _ : Empty => A) u	                | inr j1 =>	                    fun (u : Empty) (_ : if b then B else C) =>	                    Empty_rect (fun _ : Empty => if j1 then B else C) u	                end g1 x0) =	             (if b as b0 return ((if b0 then B else C) -> pushout f g)	              then fun x1 : B => push (inl x1)	              else fun x1 : C => push (inr x1)) x0)	        with	        | inl _ =>	            fun g1 : Empty =>	            match	              g1 as e	              return	                (forall x0 : if b then B else C,	                 push (inr (g (Empty_rect (fun _ : Empty => A) e))) =	                 (if b as b0 return ((if b0 then B else C) -> pushout f g)	                  then fun x1 : B => push (inl x1)	                  else fun x1 : C => push (inr x1)) x0)	            with	            end	        | inr b0 =>	            fun g1 : Empty =>	            match	              g1 as e	              return	                (forall x0 : if b then B else C,	                 (if b0 as b1 return ((if b1 then B else C) -> pushout f g)	                  then fun x1 : B => push (inl x1)	                  else fun x1 : C => push (inr x1))	                   (Empty_rect (fun _ : Empty => if b0 then B else C) e) =	                 (if b as b1 return ((if b1 then B else C) -> pushout f g)	                  then fun x1 : B => push (inl x1)	                  else fun x1 : C => push (inr x1)) x0)	            with	            end	        end	    end j g0 x) @	 (fun i0 : Unit + Bool =>	  match	    i0 as s	    return	      ((fun	          x0 : match s with	               | inl _ => A	               | inr true => B	               | inr false => C	               end =>	        pushout_rec Y (Co (inr true)) (Co (inr false))	          (popp' {| q := Co; qq := Co' |})	          (match	             s as s0	             return	               (match s0 with	                | inl _ => A	                | inr true => B	                | inr false => C	                end -> pushout f g)	           with	           | inl _ => fun x1 : A => push (inr (g x1))	           | inr b =>	               if b as b0 return ((if b0 then B else C) -> pushout f g)	               then fun x1 : B => push (inl x1)	               else fun x1 : C => push (inr x1)	           end x0)) == Co s)	  with	  | inl u =>	      match	        u as u0	        return	          ((fun x0 : A =>	            pushout_rec Y (Co (inr true)) (Co (inr false))	              (popp' {| q := Co; qq := Co' |}) (push (inr (g x0)))) ==	           Co (inl u0))	      with	      | tt => fun x0 : A => Co' (inl tt) (inr false) tt x0	      end	  | inr b =>	      if b as b0	       return	         ((fun x0 : if b0 then B else C =>	           pushout_rec Y (Co (inr true)) (Co (inr false))	             (popp' {| q := Co; qq := Co' |})	             ((if b0 as b1 return ((if b1 then B else C) -> pushout f g)	               then fun x1 : B => push (inl x1)	               else fun x1 : C => push (inr x1)) x0)) == 	          Co (inr b0))	      then fun x0 : B => ?Goal0@{x:=x0}	      else fun x0 : C => ?Goal1@{x:=x0}	  end) i x =	 (fun i0 : Unit + Bool =>	  match	    i0 as s	    return	      ((fun	          x0 : match s with	               | inl _ => A	               | inr true => B	               | inr false => C	               end =>	        pushout_rec Y (Co (inr true)) (Co (inr false))	          (popp' {| q := Co; qq := Co' |})	          (match	             s as s0	             return	               (match s0 with	                | inl _ => A	                | inr true => B	                | inr false => C	                end -> pushout f g)	           with	           | inl _ => fun x1 : A => push (inr (g x1))	           | inr b =>	               if b as b0 return ((if b0 then B else C) -> pushout f g)	               then fun x1 : B => push (inl x1)	               else fun x1 : C => push (inr x1)	           end x0)) == Co s)	  with	  | inl u =>	      match	        u as u0	        return	          ((fun x0 : A =>	            pushout_rec Y (Co (inr true)) (Co (inr false))	              (popp' {| q := Co; qq := Co' |}) (push (inr (g x0)))) ==	           Co (inl u0))	      with	      | tt => fun x0 : A => Co' (inl tt) (inr false) tt x0	      end	  | inr b =>	      if b as b0	       return	         ((fun x0 : if b0 then B else C =>	           pushout_rec Y (Co (inr true)) (Co (inr false))	             (popp' {| q := Co; qq := Co' |})	             ((if b0 as b1 return ((if b1 then B else C) -> pushout f g)	               then fun x1 : B => push (inl x1)	               else fun x1 : C => push (inr x1)) x0)) == 	          Co (inr b0))	      then fun x0 : B => ?Goal0@{x:=x0}	      else fun x0 : C => ?Goal1@{x:=x0}	  end) j	   (match	      i as s	      return	        (forall j0 : Unit + Bool,	         match s with	         | inl _ =>	             fun X : Unit + Bool =>	             match X with	             | inl _ => Empty	             | inr _ => Unit	             end	         | inr _ =>	             fun X : Unit + Bool => match X with	                                    | inl _ | _ => Empty	                                    end	         end j0 ->	         match s with	         | inl _ => A	         | inr true => B	         | inr false => C	         end ->	         match j0 with	         | inl _ => A	         | inr true => B	         | inr false => C	         end)	    with	    | inl _ =>	        fun j0 : Unit + Bool =>	        match	          j0 as s	          return	            (match s with	             | inl _ => Empty	             | inr _ => Unit	             end ->	             A ->	             match s with	             | inl _ => A	             | inr true => B	             | inr false => C	             end)	        with	        | inl _ =>	            fun (u : Empty) (_ : A) => Empty_rect (fun _ : Empty => A) u	        | inr j1 =>	            fun u : Unit =>	            (if j1 as b return (Unit -> A -> if b then B else C)	             then unit_name f	             else unit_name g) u	        end	    | inr i0 =>	        fun j0 : Unit + Bool =>	        match	          j0 as s	          return	            (match s with	             | inl _ | _ => Empty	             end ->	             (if i0 then B else C) ->	             match s with	             | inl _ => A	             | inr true => B	             | inr false => C	             end)	        with	        | inl _ =>	            fun (u : Empty) (_ : if i0 then B else C) =>	            Empty_rect (fun _ : Empty => A) u	        | inr j1 =>	            fun (u : Empty) (_ : if i0 then B else C) =>	            Empty_rect (fun _ : Empty => if j1 then B else C) u	        end	    end j g0 x) @ Co' i j g0 x	subgoal 4 (ID 116) is:	 Sect	   (postcompose_cocone	      (Build_span_cocone (fun x : B => push (inl x))	         (fun x : C => push (inr x)) pp))	   (fun Co : cocone (span f g) Y =>	    pushout_rec Y (pol' Co) (por' Co) (popp' Co))	";
            responses[i]=data;
          

            i = 188;
            data = "2 subgoals (ID 237)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : PO_graph, span f g i -> Y	  Co' : forall (i j : PO_graph) (g0 : PO_graph i j) 	        (x : span f g i), Co j (((span f g) _f g0) x) = Co i x	  x : B	  ============================	  Co (inr true) x = Co (inr true) x		subgoal 2 (ID 239) is:	 Co (inr false) x = Co (inr false) x	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	";
            responses[i]=data;
          

            i = 189;
            data = "2 subgoals (ID 214)		subgoal 1 (ID 214) is:	 forall (i j : Unit + Bool)	 (g0 : match i with	       | inl _ =>	           fun X : Unit + Bool =>	           match X with	           | inl _ => Empty	           | inr _ => Unit	           end	       | inr _ =>	           fun X : Unit + Bool => match X with	                                  | inl _ | _ => Empty	                                  end	       end j)	 (x : match i with	      | inl _ => A	      | inr true => B	      | inr false => C	      end),	 ap	   (pushout_rec Y (Co (inr true)) (Co (inr false))	      (popp' {| q := Co; qq := Co' |}))	   (match	      i as s	      return	        (forall (j0 : Unit + Bool)	         (g1 : match s with	               | inl _ =>	                   fun X : Unit + Bool =>	                   match X with	                   | inl _ => Empty	                   | inr _ => Unit	                   end	               | inr _ =>	                   fun X : Unit + Bool =>	                   match X with	                   | inl _ | _ => Empty	                   end	               end j0)	         (x0 : match s with	               | inl _ => A	               | inr true => B	               | inr false => C	               end),	         match	           j0 as s0	           return	             (match s0 with	              | inl _ => A	              | inr true => B	              | inr false => C	              end -> pushout f g)	         with	         | inl _ => fun x1 : A => push (inr (g x1))	         | inr b =>	             if b as b0 return ((if b0 then B else C) -> pushout f g)	             then fun x1 : B => push (inl x1)	             else fun x1 : C => push (inr x1)	         end	           (match	              s as s0	              return	                (forall j1 : Unit + Bool,	                 match s0 with	                 | inl _ =>	                     fun X : Unit + Bool =>	                     match X with	                     | inl _ => Empty	                     | inr _ => Unit	                     end	                 | inr _ =>	                     fun X : Unit + Bool =>	                     match X with	                     | inl _ | _ => Empty	                     end	                 end j1 ->	                 match s0 with	                 | inl _ => A	                 | inr true => B	                 | inr false => C	                 end ->	                 match j1 with	                 | inl _ => A	                 | inr true => B	                 | inr false => C	                 end)	            with	            | inl _ =>	                fun j1 : Unit + Bool =>	                match	                  j1 as s0	                  return	                    (match s0 with	                     | inl _ => Empty	                     | inr _ => Unit	                     end ->	                     A ->	                     match s0 with	                     | inl _ => A	                     | inr true => B	                     | inr false => C	                     end)	                with	                | inl _ =>	                    fun (u : Empty) (_ : A) =>	                    Empty_rect (fun _ : Empty => A) u	                | inr j2 =>	                    fun u : Unit =>	                    (if j2 as b return (Unit -> A -> if b then B else C)	                     then unit_name f	                     else unit_name g) u	                end	            | inr i0 =>	                fun j1 : Unit + Bool =>	                match	                  j1 as s0	                  return	                    (match s0 with	                     | inl _ | _ => Empty	                     end ->	                     (if i0 then B else C) ->	                     match s0 with	                     | inl _ => A	                     | inr true => B	                     | inr false => C	                     end)	                with	                | inl _ =>	                    fun (u : Empty) (_ : if i0 then B else C) =>	                    Empty_rect (fun _ : Empty => A) u	                | inr j2 =>	                    fun (u : Empty) (_ : if i0 then B else C) =>	                    Empty_rect (fun _ : Empty => if j2 then B else C) u	                end	            end j0 g1 x0) =	         match	           s as s0	           return	             (match s0 with	              | inl _ => A	              | inr true => B	              | inr false => C	              end -> pushout f g)	         with	         | inl _ => fun x1 : A => push (inr (g x1))	         | inr b =>	             if b as b0 return ((if b0 then B else C) -> pushout f g)	             then fun x1 : B => push (inl x1)	             else fun x1 : C => push (inr x1)	         end x0)	    with	    | inl _ =>	        fun j0 : Unit + Bool =>	        match	          j0 as s	          return	            (forall (g1 : match s with	                          | inl _ => Empty	                          | inr _ => Unit	                          end) (x0 : A),	             match	               s as s0	               return	                 (match s0 with	                  | inl _ => A	                  | inr true => B	                  | inr false => C	                  end -> pushout f g)	             with	             | inl _ => fun x1 : A => push (inr (g x1))	             | inr b =>	                 if b as b0 return ((if b0 then B else C) -> pushout f g)	                 then fun x1 : B => push (inl x1)	                 else fun x1 : C => push (inr x1)	             end	               (match	                  s as s0	                  return	                    (match s0 with	                     | inl _ => Empty	                     | inr _ => Unit	                     end ->	                     A ->	                     match s0 with	                     | inl _ => A	                     | inr true => B	                     | inr false => C	                     end)	                with	                | inl _ =>	                    fun (u0 : Empty) (_ : A) =>	                    Empty_rect (fun _ : Empty => A) u0	                | inr j1 =>	                    fun u0 : Unit =>	                    (if j1 as b return (Unit -> A -> if b then B else C)	                     then unit_name f	                     else unit_name g) u0	                end g1 x0) = push (inr (g x0)))	        with	        | inl _ =>	            fun g1 : Empty =>	            match	              g1 as e	              return	                (forall x0 : A,	                 push (inr (g (Empty_rect (fun _ : Empty => A) e))) =	                 push (inr (g x0)))	            with	            end	        | inr b =>	            fun g1 : Unit =>	            match	              g1 as u0	              return	                (forall x0 : A,	                 (if b as b0 return ((if b0 then B else C) -> pushout f g)	                  then fun x1 : B => push (inl x1)	                  else fun x1 : C => push (inr x1))	                   ((if b as b0 return (Unit -> A -> if b0 then B else C)	                     then unit_name f	                     else unit_name g) u0 x0) = push (inr (g x0)))	            with	            | tt =>	                if b as b0	                 return	                   (forall x0 : A,	                    (if b0 as b1	                      return ((if b1 then B else C) -> pushout f g)	                     then fun x1 : B => push (inl x1)	                     else fun x1 : C => push (inr x1))	                      ((if b0 as b1 return (Unit -> A -> if b1 then B else C)	                        then unit_name f	                        else unit_name g) tt x0) = 	                    push (inr (g x0)))	                then pp	                else fun x0 : A => 1	            end	        end	    | inr b =>	        fun j0 : Unit + Bool =>	        match	          j0 as s	          return	            (forall (g1 : match s with	                          | inl _ | _ => Empty	                          end) (x0 : if b then B else C),	             match	               s as s0	               return	                 (match s0 with	                  | inl _ => A	                  | inr true => B	                  | inr false => C	                  end -> pushout f g)	             with	             | inl _ => fun x1 : A => push (inr (g x1))	             | inr b0 =>	                 if b0 as b1 return ((if b1 then B else C) -> pushout f g)	                 then fun x1 : B => push (inl x1)	                 else fun x1 : C => push (inr x1)	             end	               (match	                  s as s0	                  return	                    (match s0 with	                     | inl _ | _ => Empty	                     end ->	                     (if b then B else C) ->	                     match s0 with	                     | inl _ => A	                     | inr true => B	                     | inr false => C	                     end)	                with	                | inl _ =>	                    fun (u : Empty) (_ : if b then B else C) =>	                    Empty_rect (fun _ : Empty => A) u	                | inr j1 =>	                    fun (u : Empty) (_ : if b then B else C) =>	                    Empty_rect (fun _ : Empty => if j1 then B else C) u	                end g1 x0) =	             (if b as b0 return ((if b0 then B else C) -> pushout f g)	              then fun x1 : B => push (inl x1)	              else fun x1 : C => push (inr x1)) x0)	        with	        | inl _ =>	            fun g1 : Empty =>	            match	              g1 as e	              return	                (forall x0 : if b then B else C,	                 push (inr (g (Empty_rect (fun _ : Empty => A) e))) =	                 (if b as b0 return ((if b0 then B else C) -> pushout f g)	                  then fun x1 : B => push (inl x1)	                  else fun x1 : C => push (inr x1)) x0)	            with	            end	        | inr b0 =>	            fun g1 : Empty =>	            match	              g1 as e	              return	                (forall x0 : if b then B else C,	                 (if b0 as b1 return ((if b1 then B else C) -> pushout f g)	                  then fun x1 : B => push (inl x1)	                  else fun x1 : C => push (inr x1))	                   (Empty_rect (fun _ : Empty => if b0 then B else C) e) =	                 (if b as b1 return ((if b1 then B else C) -> pushout f g)	                  then fun x1 : B => push (inl x1)	                  else fun x1 : C => push (inr x1)) x0)	            with	            end	        end	    end j g0 x) @	 (fun i0 : Unit + Bool =>	  match	    i0 as s	    return	      ((fun	          x0 : match s with	               | inl _ => A	               | inr true => B	               | inr false => C	               end =>	        pushout_rec Y (Co (inr true)) (Co (inr false))	          (popp' {| q := Co; qq := Co' |})	          (match	             s as s0	             return	               (match s0 with	                | inl _ => A	                | inr true => B	                | inr false => C	                end -> pushout f g)	           with	           | inl _ => fun x1 : A => push (inr (g x1))	           | inr b =>	               if b as b0 return ((if b0 then B else C) -> pushout f g)	               then fun x1 : B => push (inl x1)	               else fun x1 : C => push (inr x1)	           end x0)) == Co s)	  with	  | inl u =>	      match	        u as u0	        return	          ((fun x0 : A =>	            pushout_rec Y (Co (inr true)) (Co (inr false))	              (popp' {| q := Co; qq := Co' |}) (push (inr (g x0)))) ==	           Co (inl u0))	      with	      | tt => fun x0 : A => Co' (inl tt) (inr false) tt x0	      end	  | inr b =>	      if b as b0	       return	         ((fun x0 : if b0 then B else C =>	           pushout_rec Y (Co (inr true)) (Co (inr false))	             (popp' {| q := Co; qq := Co' |})	             ((if b0 as b1 return ((if b1 then B else C) -> pushout f g)	               then fun x1 : B => push (inl x1)	               else fun x1 : C => push (inr x1)) x0)) == 	          Co (inr b0))	      then fun x0 : B => 1	      else fun x0 : C => 1	  end) i x =	 (fun i0 : Unit + Bool =>	  match	    i0 as s	    return	      ((fun	          x0 : match s with	               | inl _ => A	               | inr true => B	               | inr false => C	               end =>	        pushout_rec Y (Co (inr true)) (Co (inr false))	          (popp' {| q := Co; qq := Co' |})	          (match	             s as s0	             return	               (match s0 with	                | inl _ => A	                | inr true => B	                | inr false => C	                end -> pushout f g)	           with	           | inl _ => fun x1 : A => push (inr (g x1))	           | inr b =>	               if b as b0 return ((if b0 then B else C) -> pushout f g)	               then fun x1 : B => push (inl x1)	               else fun x1 : C => push (inr x1)	           end x0)) == Co s)	  with	  | inl u =>	      match	        u as u0	        return	          ((fun x0 : A =>	            pushout_rec Y (Co (inr true)) (Co (inr false))	              (popp' {| q := Co; qq := Co' |}) (push (inr (g x0)))) ==	           Co (inl u0))	      with	      | tt => fun x0 : A => Co' (inl tt) (inr false) tt x0	      end	  | inr b =>	      if b as b0	       return	         ((fun x0 : if b0 then B else C =>	           pushout_rec Y (Co (inr true)) (Co (inr false))	             (popp' {| q := Co; qq := Co' |})	             ((if b0 as b1 return ((if b1 then B else C) -> pushout f g)	               then fun x1 : B => push (inl x1)	               else fun x1 : C => push (inr x1)) x0)) == 	          Co (inr b0))	      then fun x0 : B => 1	      else fun x0 : C => 1	  end) j	   (match	      i as s	      return	        (forall j0 : Unit + Bool,	         match s with	         | inl _ =>	             fun X : Unit + Bool =>	             match X with	             | inl _ => Empty	             | inr _ => Unit	             end	         | inr _ =>	             fun X : Unit + Bool => match X with	                                    | inl _ | _ => Empty	                                    end	         end j0 ->	         match s with	         | inl _ => A	         | inr true => B	         | inr false => C	         end ->	         match j0 with	         | inl _ => A	         | inr true => B	         | inr false => C	         end)	    with	    | inl _ =>	        fun j0 : Unit + Bool =>	        match	          j0 as s	          return	            (match s with	             | inl _ => Empty	             | inr _ => Unit	             end ->	             A ->	             match s with	             | inl _ => A	             | inr true => B	             | inr false => C	             end)	        with	        | inl _ =>	            fun (u : Empty) (_ : A) => Empty_rect (fun _ : Empty => A) u	        | inr j1 =>	            fun u : Unit =>	            (if j1 as b return (Unit -> A -> if b then B else C)	             then unit_name f	             else unit_name g) u	        end	    | inr i0 =>	        fun j0 : Unit + Bool =>	        match	          j0 as s	          return	            (match s with	             | inl _ | _ => Empty	             end ->	             (if i0 then B else C) ->	             match s with	             | inl _ => A	             | inr true => B	             | inr false => C	             end)	        with	        | inl _ =>	            fun (u : Empty) (_ : if i0 then B else C) =>	            Empty_rect (fun _ : Empty => A) u	        | inr j1 =>	            fun (u : Empty) (_ : if i0 then B else C) =>	            Empty_rect (fun _ : Empty => if j1 then B else C) u	        end	    end j g0 x) @ Co' i j g0 x	subgoal 2 (ID 116) is:	 Sect	   (postcompose_cocone	      (Build_span_cocone (fun x : B => push (inl x))	         (fun x : C => push (inr x)) pp))	   (fun Co : cocone (span f g) Y =>	    pushout_rec Y (pol' Co) (por' Co) (popp' Co))	1 subgoal (ID 214)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : PO_graph, span f g i -> Y	  Co' : forall (i j : PO_graph) (g0 : PO_graph i j) 	        (x : span f g i), Co j (((span f g) _f g0) x) = Co i x	  ============================	  forall (i j : Unit + Bool)	  (g0 : match i with	        | inl _ =>	            fun X : Unit + Bool =>	            match X with	            | inl _ => Empty	            | inr _ => Unit	            end	        | inr _ =>	            fun X : Unit + Bool => match X with	                                   | inl _ | _ => Empty	                                   end	        end j)	  (x : match i with	       | inl _ => A	       | inr true => B	       | inr false => C	       end),	  ap	    (pushout_rec Y (Co (inr true)) (Co (inr false))	       (popp' {| q := Co; qq := Co' |}))	    (match	       i as s	       return	         (forall (j0 : Unit + Bool)	          (g1 : match s with	                | inl _ =>	                    fun X : Unit + Bool =>	                    match X with	                    | inl _ => Empty	                    | inr _ => Unit	                    end	                | inr _ =>	                    fun X : Unit + Bool =>	                    match X with	                    | inl _ | _ => Empty	                    end	                end j0)	          (x0 : match s with	                | inl _ => A	                | inr true => B	                | inr false => C	                end),	          match	            j0 as s0	            return	              (match s0 with	               | inl _ => A	               | inr true => B	               | inr false => C	               end -> pushout f g)	          with	          | inl _ => fun x1 : A => push (inr (g x1))	          | inr b =>	              if b as b0 return ((if b0 then B else C) -> pushout f g)	              then fun x1 : B => push (inl x1)	              else fun x1 : C => push (inr x1)	          end	            (match	               s as s0	               return	                 (forall j1 : Unit + Bool,	                  match s0 with	                  | inl _ =>	                      fun X : Unit + Bool =>	                      match X with	                      | inl _ => Empty	                      | inr _ => Unit	                      end	                  | inr _ =>	                      fun X : Unit + Bool =>	                      match X with	                      | inl _ | _ => Empty	                      end	                  end j1 ->	                  match s0 with	                  | inl _ => A	                  | inr true => B	                  | inr false => C	                  end ->	                  match j1 with	                  | inl _ => A	                  | inr true => B	                  | inr false => C	                  end)	             with	             | inl _ =>	                 fun j1 : Unit + Bool =>	                 match	                   j1 as s0	                   return	                     (match s0 with	                      | inl _ => Empty	                      | inr _ => Unit	                      end ->	                      A ->	                      match s0 with	                      | inl _ => A	                      | inr true => B	                      | inr false => C	                      end)	                 with	                 | inl _ =>	                     fun (u : Empty) (_ : A) =>	                     Empty_rect (fun _ : Empty => A) u	                 | inr j2 =>	                     fun u : Unit =>	                     (if j2 as b return (Unit -> A -> if b then B else C)	                      then unit_name f	                      else unit_name g) u	                 end	             | inr i0 =>	                 fun j1 : Unit + Bool =>	                 match	                   j1 as s0	                   return	                     (match s0 with	                      | inl _ | _ => Empty	                      end ->	                      (if i0 then B else C) ->	                      match s0 with	                      | inl _ => A	                      | inr true => B	                      | inr false => C	                      end)	                 with	                 | inl _ =>	                     fun (u : Empty) (_ : if i0 then B else C) =>	                     Empty_rect (fun _ : Empty => A) u	                 | inr j2 =>	                     fun (u : Empty) (_ : if i0 then B else C) =>	                     Empty_rect (fun _ : Empty => if j2 then B else C) u	                 end	             end j0 g1 x0) =	          match	            s as s0	            return	              (match s0 with	               | inl _ => A	               | inr true => B	               | inr false => C	               end -> pushout f g)	          with	          | inl _ => fun x1 : A => push (inr (g x1))	          | inr b =>	              if b as b0 return ((if b0 then B else C) -> pushout f g)	              then fun x1 : B => push (inl x1)	              else fun x1 : C => push (inr x1)	          end x0)	     with	     | inl _ =>	         fun j0 : Unit + Bool =>	         match	           j0 as s	           return	             (forall (g1 : match s with	                           | inl _ => Empty	                           | inr _ => Unit	                           end) (x0 : A),	              match	                s as s0	                return	                  (match s0 with	                   | inl _ => A	                   | inr true => B	                   | inr false => C	                   end -> pushout f g)	              with	              | inl _ => fun x1 : A => push (inr (g x1))	              | inr b =>	                  if b as b0 return ((if b0 then B else C) -> pushout f g)	                  then fun x1 : B => push (inl x1)	                  else fun x1 : C => push (inr x1)	              end	                (match	                   s as s0	                   return	                     (match s0 with	                      | inl _ => Empty	                      | inr _ => Unit	                      end ->	                      A ->	                      match s0 with	                      | inl _ => A	                      | inr true => B	                      | inr false => C	                      end)	                 with	                 | inl _ =>	                     fun (u0 : Empty) (_ : A) =>	                     Empty_rect (fun _ : Empty => A) u0	                 | inr j1 =>	                     fun u0 : Unit =>	                     (if j1 as b return (Unit -> A -> if b then B else C)	                      then unit_name f	                      else unit_name g) u0	                 end g1 x0) = push (inr (g x0)))	         with	         | inl _ =>	             fun g1 : Empty =>	             match	               g1 as e	               return	                 (forall x0 : A,	                  push (inr (g (Empty_rect (fun _ : Empty => A) e))) =	                  push (inr (g x0)))	             with	             end	         | inr b =>	             fun g1 : Unit =>	             match	               g1 as u0	               return	                 (forall x0 : A,	                  (if b as b0 return ((if b0 then B else C) -> pushout f g)	                   then fun x1 : B => push (inl x1)	                   else fun x1 : C => push (inr x1))	                    ((if b as b0 return (Unit -> A -> if b0 then B else C)	                      then unit_name f	                      else unit_name g) u0 x0) = push (inr (g x0)))	             with	             | tt =>	                 if b as b0	                  return	                    (forall x0 : A,	                     (if b0 as b1	                       return ((if b1 then B else C) -> pushout f g)	                      then fun x1 : B => push (inl x1)	                      else fun x1 : C => push (inr x1))	                       ((if b0 as b1	                          return (Unit -> A -> if b1 then B else C)	                         then unit_name f	                         else unit_name g) tt x0) = 	                     push (inr (g x0)))	                 then pp	                 else fun x0 : A => 1	             end	         end	     | inr b =>	         fun j0 : Unit + Bool =>	         match	           j0 as s	           return	             (forall (g1 : match s with	                           | inl _ | _ => Empty	                           end) (x0 : if b then B else C),	              match	                s as s0	                return	                  (match s0 with	                   | inl _ => A	                   | inr true => B	                   | inr false => C	                   end -> pushout f g)	              with	              | inl _ => fun x1 : A => push (inr (g x1))	              | inr b0 =>	                  if b0 as b1 return ((if b1 then B else C) -> pushout f g)	                  then fun x1 : B => push (inl x1)	                  else fun x1 : C => push (inr x1)	              end	                (match	                   s as s0	                   return	                     (match s0 with	                      | inl _ | _ => Empty	                      end ->	                      (if b then B else C) ->	                      match s0 with	                      | inl _ => A	                      | inr true => B	                      | inr false => C	                      end)	                 with	                 | inl _ =>	                     fun (u : Empty) (_ : if b then B else C) =>	                     Empty_rect (fun _ : Empty => A) u	                 | inr j1 =>	                     fun (u : Empty) (_ : if b then B else C) =>	                     Empty_rect (fun _ : Empty => if j1 then B else C) u	                 end g1 x0) =	              (if b as b0 return ((if b0 then B else C) -> pushout f g)	               then fun x1 : B => push (inl x1)	               else fun x1 : C => push (inr x1)) x0)	         with	         | inl _ =>	             fun g1 : Empty =>	             match	               g1 as e	               return	                 (forall x0 : if b then B else C,	                  push (inr (g (Empty_rect (fun _ : Empty => A) e))) =	                  (if b as b0 return ((if b0 then B else C) -> pushout f g)	                   then fun x1 : B => push (inl x1)	                   else fun x1 : C => push (inr x1)) x0)	             with	             end	         | inr b0 =>	             fun g1 : Empty =>	             match	               g1 as e	               return	                 (forall x0 : if b then B else C,	                  (if b0 as b1 return ((if b1 then B else C) -> pushout f g)	                   then fun x1 : B => push (inl x1)	                   else fun x1 : C => push (inr x1))	                    (Empty_rect (fun _ : Empty => if b0 then B else C) e) =	                  (if b as b1 return ((if b1 then B else C) -> pushout f g)	                   then fun x1 : B => push (inl x1)	                   else fun x1 : C => push (inr x1)) x0)	             with	             end	         end	     end j g0 x) @	  (fun i0 : Unit + Bool =>	   match	     i0 as s	     return	       ((fun	           x0 : match s with	                | inl _ => A	                | inr true => B	                | inr false => C	                end =>	         pushout_rec Y (Co (inr true)) (Co (inr false))	           (popp' {| q := Co; qq := Co' |})	           (match	              s as s0	              return	                (match s0 with	                 | inl _ => A	                 | inr true => B	                 | inr false => C	                 end -> pushout f g)	            with	            | inl _ => fun x1 : A => push (inr (g x1))	            | inr b =>	                if b as b0 return ((if b0 then B else C) -> pushout f g)	                then fun x1 : B => push (inl x1)	                else fun x1 : C => push (inr x1)	            end x0)) == Co s)	   with	   | inl u =>	       match	         u as u0	         return	           ((fun x0 : A =>	             pushout_rec Y (Co (inr true)) (Co (inr false))	               (popp' {| q := Co; qq := Co' |}) (push (inr (g x0)))) ==	            Co (inl u0))	       with	       | tt => fun x0 : A => Co' (inl tt) (inr false) tt x0	       end	   | inr b =>	       if b as b0	        return	          ((fun x0 : if b0 then B else C =>	            pushout_rec Y (Co (inr true)) (Co (inr false))	              (popp' {| q := Co; qq := Co' |})	              ((if b0 as b1 return ((if b1 then B else C) -> pushout f g)	                then fun x1 : B => push (inl x1)	                else fun x1 : C => push (inr x1)) x0)) == 	           Co (inr b0))	       then fun x0 : B => 1	       else fun x0 : C => 1	   end) i x =	  (fun i0 : Unit + Bool =>	   match	     i0 as s	     return	       ((fun	           x0 : match s with	                | inl _ => A	                | inr true => B	                | inr false => C	                end =>	         pushout_rec Y (Co (inr true)) (Co (inr false))	           (popp' {| q := Co; qq := Co' |})	           (match	              s as s0	              return	                (match s0 with	                 | inl _ => A	                 | inr true => B	                 | inr false => C	                 end -> pushout f g)	            with	            | inl _ => fun x1 : A => push (inr (g x1))	            | inr b =>	                if b as b0 return ((if b0 then B else C) -> pushout f g)	                then fun x1 : B => push (inl x1)	                else fun x1 : C => push (inr x1)	            end x0)) == Co s)	   with	   | inl u =>	       match	         u as u0	         return	           ((fun x0 : A =>	             pushout_rec Y (Co (inr true)) (Co (inr false))	               (popp' {| q := Co; qq := Co' |}) (push (inr (g x0)))) ==	            Co (inl u0))	       with	       | tt => fun x0 : A => Co' (inl tt) (inr false) tt x0	       end	   | inr b =>	       if b as b0	        return	          ((fun x0 : if b0 then B else C =>	            pushout_rec Y (Co (inr true)) (Co (inr false))	              (popp' {| q := Co; qq := Co' |})	              ((if b0 as b1 return ((if b1 then B else C) -> pushout f g)	                then fun x1 : B => push (inl x1)	                else fun x1 : C => push (inr x1)) x0)) == 	           Co (inr b0))	       then fun x0 : B => 1	       else fun x0 : C => 1	   end) j	    (match	       i as s	       return	         (forall j0 : Unit + Bool,	          match s with	          | inl _ =>	              fun X : Unit + Bool =>	              match X with	              | inl _ => Empty	              | inr _ => Unit	              end	          | inr _ =>	              fun X : Unit + Bool => match X with	                                     | inl _ | _ => Empty	                                     end	          end j0 ->	          match s with	          | inl _ => A	          | inr true => B	          | inr false => C	          end ->	          match j0 with	          | inl _ => A	          | inr true => B	          | inr false => C	          end)	     with	     | inl _ =>	         fun j0 : Unit + Bool =>	         match	           j0 as s	           return	             (match s with	              | inl _ => Empty	              | inr _ => Unit	              end ->	              A ->	              match s with	              | inl _ => A	              | inr true => B	              | inr false => C	              end)	         with	         | inl _ =>	             fun (u : Empty) (_ : A) => Empty_rect (fun _ : Empty => A) u	         | inr j1 =>	             fun u : Unit =>	             (if j1 as b return (Unit -> A -> if b then B else C)	              then unit_name f	              else unit_name g) u	         end	     | inr i0 =>	         fun j0 : Unit + Bool =>	         match	           j0 as s	           return	             (match s with	              | inl _ | _ => Empty	              end ->	              (if i0 then B else C) ->	              match s with	              | inl _ => A	              | inr true => B	              | inr false => C	              end)	         with	         | inl _ =>	             fun (u : Empty) (_ : if i0 then B else C) =>	             Empty_rect (fun _ : Empty => A) u	         | inr j1 =>	             fun (u : Empty) (_ : if i0 then B else C) =>	             Empty_rect (fun _ : Empty => if j1 then B else C) u	         end	     end j g0 x) @ Co' i j g0 x	";
            responses[i]=data;
          

            i = 190;
            data = "2 subgoals (ID 314)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : PO_graph, span f g i -> Y	  Co' : forall (i j : PO_graph) (g0 : PO_graph i j) 	        (x : span f g i), Co j (((span f g) _f g0) x) = Co i x	  x : A	  ============================	  ap	    (pushout_rec Y (Co (inr true)) (Co (inr false))	       (popp' {| q := Co; qq := Co' |})) (pp x) @	  Co' (inl tt) (inr false) tt x = 1 @ Co' (inl tt) (inr true) tt x		subgoal 2 (ID 316) is:	 1 @ Co' (inl tt) (inr false) tt x = 1 @ Co' (inl tt) (inr false) tt x	1 subgoal (ID 314)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : PO_graph, span f g i -> Y	  Co' : forall (i j : PO_graph) (g0 : PO_graph i j) 	        (x : span f g i), Co j (((span f g) _f g0) x) = Co i x	  x : A	  ============================	  ap	    (pushout_rec Y (Co (inr true)) (Co (inr false))	       (popp' {| q := Co; qq := Co' |})) (pp x) @	  Co' (inl tt) (inr false) tt x = 1 @ Co' (inl tt) (inr true) tt x	";
            responses[i]=data;
          

            i = 191;
            data = "1 subgoal (ID 333)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : PO_graph, span f g i -> Y	  Co' : forall (i j : PO_graph) (g0 : PO_graph i j) 	        (x : span f g i), Co j (((span f g) _f g0) x) = Co i x	  x : A	  ============================	  ap	    (pushout_rec Y (Co (inr true)) (Co (inr false))	       (popp' {| q := Co; qq := Co' |})) (pp x) @	  Co' (inl tt) (inr false) tt x = Co' (inl tt) (inr true) tt x	";
            responses[i]=data;
          

            i = 192;
            data = "1 subgoal (ID 339)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : PO_graph, span f g i -> Y	  Co' : forall (i j : PO_graph) (g0 : PO_graph i j) 	        (x : span f g i), Co j (((span f g) _f g0) x) = Co i x	  x : A	  ============================	  popp' {| q := Co; qq := Co' |} x @ Co' (inl tt) (inr false) tt x =	  Co' (inl tt) (inr true) tt x	";
            responses[i]=data;
          

            i = 193;
            data = "1 subgoal (ID 346)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : PO_graph, span f g i -> Y	  Co' : forall (i j : PO_graph) (g0 : PO_graph i j) 	        (x : span f g i), Co j (((span f g) _f g0) x) = Co i x	  x : A	  ============================	  (qq {| q := Co; qq := Co' |} (inl tt) (inr true) tt x @	   (qq {| q := Co; qq := Co' |} (inl tt) (inr false) tt x)^) @	  Co' (inl tt) (inr false) tt x = Co' (inl tt) (inr true) tt x	";
            responses[i]=data;
          

            i = 194;
            data = "1 subgoal (ID 348)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  Co : forall i : PO_graph, span f g i -> Y	  Co' : forall (i j : PO_graph) (g0 : PO_graph i j) 	        (x : span f g i), Co j (((span f g) _f g0) x) = Co i x	  x : A	  ============================	  (Co' (inl tt) (inr true) tt x @ (Co' (inl tt) (inr false) tt x)^) @	  Co' (inl tt) (inr false) tt x = Co' (inl tt) (inr true) tt x	";
            responses[i]=data;
          

            i = 195;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 subgoal (ID 116)		subgoal 1 (ID 116) is:	 Sect	   (postcompose_cocone	      (Build_span_cocone (fun x : B => push (inl x))	         (fun x : C => push (inr x)) pp))	   (fun Co : cocone (span f g) Y =>	    pushout_rec Y (pol' Co) (por' Co) (popp' Co))	";
            responses[i]=data;
          

            i = 196;
            data = "1 subgoal (ID 116)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  ============================	  Sect	    (postcompose_cocone	       (Build_span_cocone (fun x : B => push (inl x))	          (fun x : C => push (inr x)) pp))	    (fun Co : cocone (span f g) Y =>	     pushout_rec Y (pol' Co) (por' Co) (popp' Co))	1 subgoal (ID 471)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : pushout f g -> Y	  ============================	  pushout_rec Y	    (pol'	       (postcompose_cocone	          (Build_span_cocone (fun x : B => push (inl x))	             (fun x : C => push (inr x)) pp) h))	    (por'	       (postcompose_cocone	          (Build_span_cocone (fun x : B => push (inl x))	             (fun x : C => push (inr x)) pp) h))	    (popp'	       (postcompose_cocone	          (Build_span_cocone (fun x : B => push (inl x))	             (fun x : C => push (inr x)) pp) h)) = h	";
            responses[i]=data;
          

            i = 197;
            data = "1 subgoal (ID 475)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : pushout f g -> Y	  ============================	  pushout_rec Y	    (pol'	       (postcompose_cocone	          (Build_span_cocone (fun x : B => push (inl x))	             (fun x : C => push (inr x)) pp) h))	    (por'	       (postcompose_cocone	          (Build_span_cocone (fun x : B => push (inl x))	             (fun x : C => push (inr x)) pp) h))	    (popp'	       (postcompose_cocone	          (Build_span_cocone (fun x : B => push (inl x))	             (fun x : C => push (inr x)) pp) h)) == h	";
            responses[i]=data;
          

            i = 198;
            data = "3 subgoals (ID 540)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : pushout f g -> Y	  ============================	  forall b : B,	  pushout_rec Y (fun x : B => h (push (inl x)))	    (fun x : C => h (push (inr x)))	    (popp'	       (postcompose_cocone	          (Build_span_cocone (fun x : B => push (inl x))	             (fun x : C => push (inr x)) pp) h)) (pushl b) = 	  h (pushl b)		subgoal 2 (ID 542) is:	 forall c : C,	 pushout_rec Y (fun x : B => h (push (inl x)))	   (fun x : C => h (push (inr x)))	   (popp'	      (postcompose_cocone	         (Build_span_cocone (fun x : B => push (inl x))	            (fun x : C => push (inr x)) pp) h)) (pushr c) = 	 h (pushr c)	subgoal 3 (ID 544) is:	 forall a : A,	 transport	   (fun w : pushout f g =>	    pushout_rec Y (fun x : B => h (push (inl x)))	      (fun x : C => h (push (inr x)))	      (popp'	         (postcompose_cocone	            (Build_span_cocone (fun x : B => push (inl x))	               (fun x : C => push (inr x)) pp) h)) w = 	    h w) (pp a) (?Goal (f a)) = ?Goal0 (g a)	";
            responses[i]=data;
          

            i = 199;
            data = "1 subgoal (ID 540)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : pushout f g -> Y	  ============================	  forall b : B,	  pushout_rec Y (fun x : B => h (push (inl x)))	    (fun x : C => h (push (inr x)))	    (popp'	       (postcompose_cocone	          (Build_span_cocone (fun x : B => push (inl x))	             (fun x : C => push (inr x)) pp) h)) (pushl b) = 	  h (pushl b)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	2 subgoals (ID 542)		subgoal 1 (ID 542) is:	 forall c : C,	 pushout_rec Y (fun x : B => h (push (inl x)))	   (fun x : C => h (push (inr x)))	   (popp'	      (postcompose_cocone	         (Build_span_cocone (fun x : B => push (inl x))	            (fun x : C => push (inr x)) pp) h)) (pushr c) = 	 h (pushr c)	subgoal 2 (ID 544) is:	 forall a : A,	 transport	   (fun w : pushout f g =>	    pushout_rec Y (fun x : B => h (push (inl x)))	      (fun x : C => h (push (inr x)))	      (popp'	         (postcompose_cocone	            (Build_span_cocone (fun x : B => push (inl x))	               (fun x : C => push (inr x)) pp) h)) w = 	    h w) (pp a) ((fun b : B => 1) (f a)) = ?Goal (g a)	";
            responses[i]=data;
          

            i = 200;
            data = "1 subgoal (ID 542)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : pushout f g -> Y	  ============================	  forall c : C,	  pushout_rec Y (fun x : B => h (push (inl x)))	    (fun x : C => h (push (inr x)))	    (popp'	       (postcompose_cocone	          (Build_span_cocone (fun x : B => push (inl x))	             (fun x : C => push (inr x)) pp) h)) (pushr c) = 	  h (pushr c)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	1 subgoal (ID 544)		subgoal 1 (ID 544) is:	 forall a : A,	 transport	   (fun w : pushout f g =>	    pushout_rec Y (fun x : B => h (push (inl x)))	      (fun x : C => h (push (inr x)))	      (popp'	         (postcompose_cocone	            (Build_span_cocone (fun x : B => push (inl x))	               (fun x : C => push (inr x)) pp) h)) w = 	    h w) (pp a) ((fun b : B => 1) (f a)) = (fun c : C => 1) (g a)	";
            responses[i]=data;
          

            i = 201;
            data = "1 subgoal (ID 544)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : pushout f g -> Y	  ============================	  forall a : A,	  transport	    (fun w : pushout f g =>	     pushout_rec Y (fun x : B => h (push (inl x)))	       (fun x : C => h (push (inr x)))	       (popp'	          (postcompose_cocone	             (Build_span_cocone (fun x : B => push (inl x))	                (fun x : C => push (inr x)) pp) h)) w = 	     h w) (pp a) ((fun b : B => 1) (f a)) = (fun c : C => 1) (g a)	1 subgoal (ID 551)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : pushout f g -> Y	  a : A	  ============================	  transport	    (fun w : pushout f g =>	     pushout_rec Y (fun x : B => h (push (inl x)))	       (fun x : C => h (push (inr x)))	       (popp'	          (postcompose_cocone	             (Build_span_cocone (fun x : B => push (inl x))	                (fun x : C => push (inr x)) pp) h)) w = 	     h w) (pp a) 1 = 1	";
            responses[i]=data;
          

            i = 202;
            data = "1 subgoal (ID 558)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : pushout f g -> Y	  a : A	  ============================	  ((ap	      (pushout_rec Y (fun x : B => h (push (inl x)))	         (fun x : C => h (push (inr x)))	         (popp'	            (postcompose_cocone	               (Build_span_cocone (fun x : B => push (inl x))	                  (fun x : C => push (inr x)) pp) h))) 	      (pp a))^ @ 1) @ ap h (pp a) = 1	";
            responses[i]=data;
          

            i = 203;
            data = "1 subgoal (ID 568)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : pushout f g -> Y	  a : A	  ============================	  (ap	     (pushout_rec Y (fun x : B => h (push (inl x)))	        (fun x : C => h (push (inr x)))	        (popp'	           (postcompose_cocone	              (Build_span_cocone (fun x : B => push (inl x))	                 (fun x : C => push (inr x)) pp) h))) 	     (pp a))^ @ ap h (pp a) = 1	";
            responses[i]=data;
          

            i = 204;
            data = "1 subgoal (ID 577)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : pushout f g -> Y	  a : A	  ============================	  (popp'	     (postcompose_cocone	        (Build_span_cocone (fun x : B => push (inl x))	           (fun x : C => push (inr x)) pp) h) a)^ @ 	  ap h (pp a) = 1	";
            responses[i]=data;
          

            i = 205;
            data = "1 subgoal (ID 587)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : pushout f g -> Y	  a : A	  ============================	  ap h (pp a) =	  popp'	    (postcompose_cocone	       (Build_span_cocone (fun x : B => push (inl x))	          (fun x : C => push (inr x)) pp) h) a @ 1	";
            responses[i]=data;
          

            i = 206;
            data = "1 subgoal (ID 589)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : pushout f g -> Y	  a : A	  ============================	  ap h (pp a) =	  (qq	     (postcompose_cocone	        (Build_span_cocone (fun x : B => push (inl x))	           (fun x : C => push (inr x)) pp) h) (inl tt) 	     (inr true) tt a @	   (qq	      (postcompose_cocone	         (Build_span_cocone (fun x : B => push (inl x))	            (fun x : C => push (inr x)) pp) h) (inl tt) 	      (inr false) tt a)^) @ 1	";
            responses[i]=data;
          

            i = 207;
            data = "1 subgoal (ID 591)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  Y : Type	  h : pushout f g -> Y	  a : A	  ============================	  ap h (pp a) = (ap h (pp a) @ 1) @ 1	";
            responses[i]=data;
          

            i = 208;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 209;
            data = "<infomsg>is_PO_pushout is defined</infomsg>	";
            responses[i]=data;
          

            i = 210;
            data = "1 subgoal (ID 15)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  pushout f g <~> PO f g	";
            responses[i]=data;
          

            i = 211;
            data = "";
            responses[i]=data;
          

            i = 212;
            data = "4 subgoals (ID 29)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  graph		subgoal 2 (ID 30) is:	 diagram ?G	subgoal 3 (ID 34) is:	 is_colimit ?D (pushout f g)	subgoal 4 (ID 36) is:	 is_colimit ?D (PO f g)	";
            responses[i]=data;
          

            i = 213;
            data = "1 subgoal (ID 36)	  	  H : Funext	  A : Type	  B : Type	  C : Type	  f : A -> B	  g : A -> C	  ============================	  is_colimit (span f g) (PO f g)	";
            responses[i]=data;
          

            i = 214;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 215;
            data = "<infomsg>equiv_pushout_PO is defined</infomsg>	";
            responses[i]=data;
          

            i = 216;
            data = "";
            responses[i]=data;
          

            i = 217;
            data = "";
            responses[i]=data;
          

            i = 218;
            data = "";
            responses[i]=data;
          

            i = 219;
            data = "";
            responses[i]=data;
          

            i = 220;
            data = "";
            responses[i]=data;
          

            i = 221;
            data = "";
            responses[i]=data;
          

            i = 222;
            data = "";
            responses[i]=data;
          

            i = 223;
            data = "";
            responses[i]=data;
          

            i = 224;
            data = "";
            responses[i]=data;
          

            i = 225;
            data = "";
            responses[i]=data;
          

            i = 226;
            data = "";
            responses[i]=data;
          

            i = 227;
            data = "";
            responses[i]=data;
          
        };
        
        function get_response(id) {
          return responses[id];
        };

        function set_response(response, scene) {
          goalId = "goal"+scene;
          elById = document.getElementById(goalId);
          if(elById){ 
            goalSpan = elById.getElementsByTagName("span")[0];
            goalSpan.innerHTML = response.replace(/	/g , '\n');
          }
        };
      </script>
</head>
<body onload="set_array()"><div id="page" scenenumber="0" class="doc">
<div id="header" scenenumber="1" class="doc">
</div>
<div id="main" scenenumber="3" class="doc">
<h1 class="libtitle">Library HoTT.HIT.Colimits.Pushout</h1>
<div scenenumber="3" class="code">
<span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(6, '0_3_3');
      ">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Basics.html#"><span class="id" title="library">HoTT.Basics</span></a> <a class="idref" href="HoTT.Types.html#"><span class="id" title="library">HoTT.Types</span></a> <a class="idref" href="HoTT.HIT.Pushout.html#"><span class="id" title="library">HIT.Pushout</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(7, '0_3_3');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.HIT.Colimits.Diagram.html#"><span class="id" title="library">Colimits.Diagram</span></a> <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#"><span class="id" title="library">Colimits.Colimit</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(8, '0_3_3');
      "><br>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">path_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(9, '0_3_3');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_3"><pre><span></span></pre></div>
<div class="doc" scenenumber="5">
<a name="lab521"></a><h1 class="section">Pushout as a colimit</h1>
<div class="doc" scenenumber="4"> </div>

 In this file, we define <span class="inlinecode"><a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO"><span class="id" title="definition">PO</span></a></span> the pushout of two maps as the colimit of a particuliar diagram, and then show that it is equivalent to <span class="inlinecode"><a class="idref" href="HoTT.HIT.Pushout.html#pushout"><span class="id" title="definition">pushout</span></a></span> the primitive pushout defined as an HIT. 
<div class="doc" scenenumber="10"> </div>
<a name="lab522"></a><h2 class="section"><span class="inlinecode"><a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO"><span class="id" title="definition">PO</span></a></span></h2>
<div class="doc" scenenumber="15"> </div>

 The shape of a pushout diagram. 
</div>
<div scenenumber="7" class="code">
<span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(29, '0_3_7');
      ">
<br>
<span class="id" title="keyword">Definition</span> <a name="PO_graph"><span class="id" title="definition">PO_graph</span></a> : <a class="idref" href="HoTT.HIT.Colimits.Diagram.html#graph"><span class="id" title="record">graph</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(30, '0_3_7');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(31, '0_3_7');
      "><br>
  <span class="id" title="tactic">simple</span> <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.Colimits.Diagram.html#Build_graph"><span class="id" title="constructor">Build_graph</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(32, '0_3_7');
      "><br>
  - <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#Unit"><span class="id" title="inductive">Unit</span></a> <a class="idref" href="Coq.Init.Datatypes.html#e03f39daf98516fa530d3f6f5a1b4d92"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Types.Bool.html#Bool"><span class="id" title="inductive">Bool</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(33, '0_3_7');
      "><br>
  - <span class="id" title="tactic">intros</span> [<span class="id" title="var">i</span>|<span class="id" title="var">i</span>] [<span class="id" title="var">j</span>|<span class="id" title="var">j</span>].</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(34, '0_3_7');
      "><br>
    2: <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Basics.Overture.html#Unit"><span class="id" title="inductive">Unit</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(35, '0_3_7');
      "><br>
    <span class="id" title="var">all</span>: <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Basics.Overture.html#Empty"><span class="id" title="inductive">Empty</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(36, '0_3_7');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(37, '0_3_7');
      "><br>
<br>
<span class="id" title="keyword">Section</span> <a name="PO"><span class="id" title="section">PO</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(38, '0_3_7');
      "><br>
  <span class="id" title="keyword">Context</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="keyword">Type</span>}.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(39, '0_3_7');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_7"><pre><span></span></pre></div>
<div class="doc" scenenumber="9">
The pushout diagram of two maps is called a span. 
</div>
<div scenenumber="11" class="code">
<span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(43, '0_3_11');
      ">
<br>
  <span class="id" title="keyword">Definition</span> <a name="span"><span class="id" title="definition">span</span></a> (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">g</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.C"><span class="id" title="variable">C</span></a>) : <a class="idref" href="HoTT.HIT.Colimits.Diagram.html#diagram"><span class="id" title="record">diagram</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO_graph"><span class="id" title="definition">PO_graph</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(44, '0_3_11');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(45, '0_3_11');
      "><br>
    <span class="id" title="tactic">simple</span> <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.Colimits.Diagram.html#Build_diagram"><span class="id" title="constructor">Build_diagram</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(46, '0_3_11');
      "><br>
    - <span class="id" title="tactic">intros</span> [<span class="id" title="var">i</span>|<span class="id" title="var">i</span>].</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(47, '0_3_11');
      "><br>
      + <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(48, '0_3_11');
      "><br>
      + <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">if</span> <span class="id" title="var">i</span> <span class="id" title="keyword">then</span> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.B"><span class="id" title="variable">B</span></a> <span class="id" title="keyword">else</span> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.C"><span class="id" title="variable">C</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(49, '0_3_11');
      "><br>
    - <span class="id" title="tactic">intros</span> [<span class="id" title="var">i</span>|<span class="id" title="var">i</span>] [<span class="id" title="var">j</span>|<span class="id" title="var">j</span>] <span class="id" title="var">u</span>; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">try</span> <span class="id" title="var">contradiction</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(50, '0_3_11');
      "><br>
      <span class="id" title="tactic">destruct</span> <span class="id" title="var">j</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(51, '0_3_11');
      "><br>
      + <span class="id" title="tactic">exact</span> <span class="id" title="var">f</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(52, '0_3_11');
      "><br>
      + <span class="id" title="tactic">exact</span> <span class="id" title="var">g</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(53, '0_3_11');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(54, '0_3_11');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="Build_span_cocone"><span class="id" title="definition">Build_span_cocone</span></a> {<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.B"><span class="id" title="variable">B</span></a>} {<span class="id" title="var">g</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.C"><span class="id" title="variable">C</span></a>} {<span class="id" title="var">Z</span> : <span class="id" title="keyword">Type</span>}<br>
             (<span class="id" title="var">inl'</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Z"><span class="id" title="variable">Z</span></a>) (<span class="id" title="var">inr'</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.C"><span class="id" title="variable">C</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Z"><span class="id" title="variable">Z</span></a>)<br>
             (<span class="id" title="var">pp'</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#inl'"><span class="id" title="variable">inl'</span></a> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#inr'"><span class="id" title="variable">inr'</span></a> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#g"><span class="id" title="variable">g</span></a>)<br>
    : <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#cocone"><span class="id" title="record">cocone</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#g"><span class="id" title="variable">g</span></a>) <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Z"><span class="id" title="variable">Z</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(55, '0_3_11');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(56, '0_3_11');
      "><br>
    <span class="id" title="var">unshelve</span> <span class="id" title="tactic">econstructor</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(57, '0_3_11');
      "><br>
    - <span class="id" title="tactic">intros</span> [|[]]; [ <span class="id" title="tactic">exact</span> (<span class="id" title="var">inr'</span> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <span class="id" title="var">g</span>) | <span class="id" title="tactic">exact</span> <span class="id" title="var">inl'</span> | <span class="id" title="tactic">exact</span> <span class="id" title="var">inr'</span> ].</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(58, '0_3_11');
      "><br>
    - <span class="id" title="tactic">intros</span> [] [] []; <span class="id" title="var">cbn</span>. </span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(59, '0_3_11');
      "><span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(60, '0_3_11');
      "><br>
      + <span class="id" title="tactic">exact</span> <span class="id" title="var">pp'</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(61, '0_3_11');
      "><br>
      + <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(62, '0_3_11');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(63, '0_3_11');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="pol'"><span class="id" title="definition">pol'</span></a> {<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.B"><span class="id" title="variable">B</span></a>} {<span class="id" title="var">g</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.C"><span class="id" title="variable">C</span></a>} {<span class="id" title="var">Z</span>} (<span class="id" title="var">Co</span> : <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#cocone"><span class="id" title="record">cocone</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#g"><span class="id" title="variable">g</span></a>) <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Z"><span class="id" title="variable">Z</span></a>)<br>
    : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Z"><span class="id" title="variable">Z</span></a><br>
    := <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#q"><span class="id" title="projection">q</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Co"><span class="id" title="variable">Co</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(64, '0_3_11');
      "><br>
  <span class="id" title="keyword">Definition</span> <a name="por'"><span class="id" title="definition">por'</span></a> {<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.B"><span class="id" title="variable">B</span></a>} {<span class="id" title="var">g</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.C"><span class="id" title="variable">C</span></a>} {<span class="id" title="var">Z</span>} (<span class="id" title="var">Co</span> : <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#cocone"><span class="id" title="record">cocone</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#g"><span class="id" title="variable">g</span></a>) <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Z"><span class="id" title="variable">Z</span></a>)<br>
    : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.C"><span class="id" title="variable">C</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Z"><span class="id" title="variable">Z</span></a><br>
    := <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#q"><span class="id" title="projection">q</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Co"><span class="id" title="variable">Co</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(65, '0_3_11');
      "><br>
  <span class="id" title="keyword">Definition</span> <a name="popp'"><span class="id" title="definition">popp'</span></a> {<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.B"><span class="id" title="variable">B</span></a>} {<span class="id" title="var">g</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.C"><span class="id" title="variable">C</span></a>} {<span class="id" title="var">Z</span>} (<span class="id" title="var">Co</span> : <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#cocone"><span class="id" title="record">cocone</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#g"><span class="id" title="variable">g</span></a>) <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Z"><span class="id" title="variable">Z</span></a>)<br>
    : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#pol'"><span class="id" title="definition">pol'</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Co"><span class="id" title="variable">Co</span></a> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#por'"><span class="id" title="definition">por'</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Co"><span class="id" title="variable">Co</span></a> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#g"><span class="id" title="variable">g</span></a><br>
    := <span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#qq"><span class="id" title="projection">qq</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Co"><span class="id" title="variable">Co</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#x"><span class="id" title="variable">x</span></a><br>
                <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.Colimits.Colimit.html#qq"><span class="id" title="projection">qq</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Co"><span class="id" title="variable">Co</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(66, '0_3_11');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="is_PO"><span class="id" title="definition">is_PO</span></a> (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">g</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.C"><span class="id" title="variable">C</span></a>) := <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#is_colimit"><span class="id" title="record">is_colimit</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#g"><span class="id" title="variable">g</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(67, '0_3_11');
      "><br>
  <span class="id" title="keyword">Definition</span> <a name="PO"><span class="id" title="definition">PO</span></a> (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">g</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.C"><span class="id" title="variable">C</span></a>) := <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#ColimitHIT.colimit"><span class="id" title="inductive">colimit</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#g"><span class="id" title="variable">g</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(68, '0_3_11');
      "><br>
<br>
  <span class="id" title="keyword">Context</span> {<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.B"><span class="id" title="variable">B</span></a>} {<span class="id" title="var">g</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.C"><span class="id" title="variable">C</span></a>}.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(69, '0_3_11');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="pol"><span class="id" title="definition">pol</span></a> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO"><span class="id" title="definition">PO</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a> := <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#ColimitHIT.colim"><span class="id" title="constructor">colim</span></a> (<span class="id" title="var">D</span>:=<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(70, '0_3_11');
      "><br>
  <span class="id" title="keyword">Definition</span> <a name="por"><span class="id" title="definition">por</span></a> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.C"><span class="id" title="variable">C</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO"><span class="id" title="definition">PO</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a> := <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#ColimitHIT.colim"><span class="id" title="constructor">colim</span></a> (<span class="id" title="var">D</span>:=<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(71, '0_3_11');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="popp"><span class="id" title="definition">popp</span></a> (<span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.A"><span class="id" title="variable">A</span></a>) : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#pol"><span class="id" title="definition">pol</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#a"><span class="id" title="variable">a</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#por"><span class="id" title="definition">por</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#a"><span class="id" title="variable">a</span></a>)<br>
    := <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#ColimitHIT.colimp"><span class="id" title="axiom">colimp</span></a> (<span class="id" title="var">D</span>:=<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#a"><span class="id" title="variable">a</span></a><br>
          <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.Colimits.Colimit.html#ColimitHIT.colimp"><span class="id" title="axiom">colimp</span></a> (<span class="id" title="var">D</span>:=<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(72, '0_3_11');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_11"><pre><span></span></pre></div>
<div class="doc" scenenumber="13">
The eliminators <span class="inlinecode"><a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO_ind"><span class="id" title="definition">PO_ind</span></a></span>, <span class="inlinecode"><a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO_rec"><span class="id" title="definition">PO_rec</span></a></span>, ... can be proven. 
</div>
<div scenenumber="15" class="code">
<span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(80, '0_3_15');
      ">
  <span class="id" title="keyword">Definition</span> <a name="PO_ind"><span class="id" title="definition">PO_ind</span></a> (<span class="id" title="var">P</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO"><span class="id" title="definition">PO</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l'</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">b</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#pol"><span class="id" title="definition">pol</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#b"><span class="id" title="variable">b</span></a>))<br>
             (<span class="id" title="var">r'</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">c</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#por"><span class="id" title="definition">por</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#c"><span class="id" title="variable">c</span></a>))<br>
             (<span class="id" title="var">pp'</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#popp"><span class="id" title="definition">popp</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#l'"><span class="id" title="variable">l'</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#a"><span class="id" title="variable">a</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#r'"><span class="id" title="variable">r'</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#a"><span class="id" title="variable">a</span></a>))<br>
    : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">w</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#w"><span class="id" title="variable">w</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(81, '0_3_15');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(82, '0_3_15');
      "><br>
    <span class="id" title="tactic">simple</span> <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.Colimits.Colimit.html#ColimitHIT.colimit_ind"><span class="id" title="definition">colimit_ind</span></a> <span class="id" title="var">P</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(83, '0_3_15');
      "><br>
    - <span class="id" title="tactic">intros</span> [[]|[]] <span class="id" title="var">x</span>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(84, '0_3_15');
      "><br>
      + <span class="id" title="tactic">exact</span> (@<a class="idref" href="HoTT.HIT.Colimits.Colimit.html#ColimitHIT.colimp"><span class="id" title="axiom">colimp</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <span class="id" title="var">l'</span> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <span class="id" title="var">x</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(85, '0_3_15');
      "><br>
      + <span class="id" title="tactic">exact</span> (<span class="id" title="var">l'</span> <span class="id" title="var">x</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(86, '0_3_15');
      "><br>
      + <span class="id" title="tactic">exact</span> (<span class="id" title="var">r'</span> <span class="id" title="var">x</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(87, '0_3_15');
      "><br>
    - <span class="id" title="tactic">intros</span> [] [] []; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(88, '0_3_15');
      "><br>
      <span class="id" title="tactic">destruct</span> <span class="id" title="var">u</span>, <span class="id" title="var">b</span>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(89, '0_3_15');
      "><br>
      + <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(90, '0_3_15');
      "><br>
      + <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#popp"><span class="id" title="definition">popp</span></a> <span class="id" title="tactic">in</span> <span class="id" title="var">pp'</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(91, '0_3_15');
      "><br>
        <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(92, '0_3_15');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#moveR_transport_p"><span class="id" title="definition">moveR_transport_p</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(93, '0_3_15');
      "><br>
        <span class="id" title="var">etransitivity</span>; [|<span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_pp"><span class="id" title="definition">transport_pp</span></a>].</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(94, '0_3_15');
      "><br>
        <span class="id" title="tactic">symmetry</span>; <span class="id" title="tactic">apply</span> <span class="id" title="var">pp'</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(95, '0_3_15');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(96, '0_3_15');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="PO_ind_beta_pp"><span class="id" title="definition">PO_ind_beta_pp</span></a> (<span class="id" title="var">P</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO"><span class="id" title="definition">PO</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l'</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">b</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#pol"><span class="id" title="definition">pol</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#b"><span class="id" title="variable">b</span></a>))<br>
             (<span class="id" title="var">r'</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">c</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#por"><span class="id" title="definition">por</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#c"><span class="id" title="variable">c</span></a>))<br>
             (<span class="id" title="var">pp'</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#popp"><span class="id" title="definition">popp</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#l'"><span class="id" title="variable">l'</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#a"><span class="id" title="variable">a</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#r'"><span class="id" title="variable">r'</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#a"><span class="id" title="variable">a</span></a>))<br>
    : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO_ind"><span class="id" title="definition">PO_ind</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#l'"><span class="id" title="variable">l'</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#r'"><span class="id" title="variable">r'</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#pp'"><span class="id" title="variable">pp'</span></a>) (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#popp"><span class="id" title="definition">popp</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#x"><span class="id" title="variable">x</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#pp'"><span class="id" title="variable">pp'</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#x"><span class="id" title="variable">x</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(97, '0_3_15');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(98, '0_3_15');
      "><br>
    <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>. </span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(99, '0_3_15');
      "><span class="id" title="var">etransitivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(100, '0_3_15');
      "><br>
    - <span class="id" title="tactic">eapply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#apD_pp"><span class="id" title="definition">apD_pp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(101, '0_3_15');
      "><br>
    - <span class="id" title="tactic">assert</span> (<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO_ind"><span class="id" title="definition">PO_ind</span></a> <span class="id" title="var">P</span> <span class="id" title="var">l'</span> <span class="id" title="var">r'</span> <span class="id" title="var">pp'</span>)<br>
                  (@<a class="idref" href="HoTT.HIT.Colimits.Colimit.html#ColimitHIT.colimp"><span class="id" title="axiom">colimp</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#span"><span class="id" title="definition">span</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <span class="id" title="var">x</span>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> 1). {</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(102, '0_3_15');
      "><br>
        <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO_ind"><span class="id" title="definition">PO_ind</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(103, '0_3_15');
      "><br>
        <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br>
        | |- <a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Colimit.html#ColimitHIT.colimit_ind"><span class="id" title="definition">colimit_ind</span></a> <span class="id" title="var">P</span> ?<span class="id" title="var">qq1</span> ?<span class="id" title="var">qq2</span>) <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="var">_</span> ⇒<br>
          <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.HIT.Colimits.Colimit.html#ColimitHIT.colimit_ind_beta_colimp"><span class="id" title="axiom">colimit_ind_beta_colimp</span></a> <span class="id" title="var">P</span> <span class="id" title="var">qq1</span> <span class="id" title="var">qq2</span> (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <span class="id" title="var">x</span>)<br>
        <span class="id" title="keyword">end</span>. }<br>
      <span class="id" title="tactic">rewrite</span> <span class="id" title="var">X</span>. </span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(104, '0_3_15');
      "><span class="id" title="tactic">clear</span> <span class="id" title="var">X</span>. </span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(105, '0_3_15');
      "><span class="id" title="var">cbn</span>. </span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(106, '0_3_15');
      "><span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(107, '0_3_15');
      "><br>
      <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#apD_V"><span class="id" title="definition">apD_V</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(108, '0_3_15');
      "><span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO_ind"><span class="id" title="definition">PO_ind</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(109, '0_3_15');
      "><br>
      <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br>
      | |- <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.PathGroupoids.html#moveR_transport_V"><span class="id" title="definition">moveR_transport_V</span></a><br>
            <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Colimit.html#ColimitHIT.colimit_ind"><span class="id" title="definition">colimit_ind</span></a> <span class="id" title="var">P</span> ?<span class="id" title="var">qq1</span> ?<span class="id" title="var">qq2</span>) <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="var">_</span> ⇒<br>
        <span class="id" title="tactic">rewrite</span> (<a class="idref" href="HoTT.HIT.Colimits.Colimit.html#ColimitHIT.colimit_ind_beta_colimp"><span class="id" title="axiom">colimit_ind_beta_colimp</span></a> <span class="id" title="var">P</span> <span class="id" title="var">qq1</span> <span class="id" title="var">qq2</span> (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <span class="id" title="var">x</span>); <span class="id" title="var">cbn</span><br>
      <span class="id" title="keyword">end</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(110, '0_3_15');
      "><br>
      <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br>
      | |- ?<span class="id" title="var">pp</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.PathGroupoids.html#moveR_transport_V"><span class="id" title="definition">moveR_transport_V</span></a> <span class="id" title="var">P</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.PathGroupoids.html#moveR_transport_p"><span class="id" title="definition">moveR_transport_p</span></a> <span class="id" title="var">P</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ?<span class="id" title="var">qq</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="var">_</span><br>
        ⇒ <span class="id" title="tactic">set</span> (<span class="id" title="var">q</span> := <span class="id" title="var">qq</span>); <span class="id" title="tactic">set</span> (<span class="id" title="var">p</span> := <span class="id" title="var">pp</span>) <span class="id" title="tactic">in</span> ×<br>
      <span class="id" title="keyword">end</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(111, '0_3_15');
      "><br>
      <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#moveR_transport_p_V"><span class="id" title="definition">moveR_transport_p_V</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(112, '0_3_15');
      "><span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Types.Paths.html#moveR_moveL_transport_p"><span class="id" title="definition">moveR_moveL_transport_p</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(113, '0_3_15');
      "><br>
      <span class="id" title="tactic">subst</span> <span class="id" title="var">q</span>. </span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(114, '0_3_15');
      "><span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#inv_pp"><span class="id" title="definition">inv_pp</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(115, '0_3_15');
      "><span class="id" title="var">hott_simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(116, '0_3_15');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(117, '0_3_15');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="PO_rec"><span class="id" title="definition">PO_rec</span></a> (<span class="id" title="var">P</span>: <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l'</span>: <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#P"><span class="id" title="variable">P</span></a>) (<span class="id" title="var">r'</span>: <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.C"><span class="id" title="variable">C</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#P"><span class="id" title="variable">P</span></a>)<br>
             (<span class="id" title="var">pp'</span>: <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#l'"><span class="id" title="variable">l'</span></a> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#r'"><span class="id" title="variable">r'</span></a> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a>)<br>
    : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO"><span class="id" title="definition">PO</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#P"><span class="id" title="variable">P</span></a><br>
    := <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#ColimitHIT.colimit_rec"><span class="id" title="definition">colimit_rec</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Build_span_cocone"><span class="id" title="definition">Build_span_cocone</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#l'"><span class="id" title="variable">l'</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#r'"><span class="id" title="variable">r'</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#pp'"><span class="id" title="variable">pp'</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(118, '0_3_15');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="PO_rec_beta_pp"><span class="id" title="definition">PO_rec_beta_pp</span></a> (<span class="id" title="var">P</span>: <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l'</span>: <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#P"><span class="id" title="variable">P</span></a>) (<span class="id" title="var">r'</span>: <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.C"><span class="id" title="variable">C</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#P"><span class="id" title="variable">P</span></a>)<br>
             (<span class="id" title="var">pp'</span>: <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#l'"><span class="id" title="variable">l'</span></a> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#r'"><span class="id" title="variable">r'</span></a> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a>)<br>
    : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO_rec"><span class="id" title="definition">PO_rec</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#l'"><span class="id" title="variable">l'</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#r'"><span class="id" title="variable">r'</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#pp'"><span class="id" title="variable">pp'</span></a>) (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#popp"><span class="id" title="definition">popp</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#x"><span class="id" title="variable">x</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#pp'"><span class="id" title="variable">pp'</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#x"><span class="id" title="variable">x</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(119, '0_3_15');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(120, '0_3_15');
      "><br>
    <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(121, '0_3_15');
      "><br>
    <span class="id" title="tactic">pose</span> <span class="id" title="var">proof</span> (<a class="idref" href="HoTT.HIT.Colimits.Colimit.html#ColimitHIT.colimit_rec_beta_colimp"><span class="id" title="definition">colimit_rec_beta_colimp</span></a> <span class="id" title="var">P</span> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Build_span_cocone"><span class="id" title="definition">Build_span_cocone</span></a> <span class="id" title="var">l'</span> <span class="id" title="var">r'</span> <span class="id" title="var">pp'</span>)<br>
                                    (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <span class="id" title="var">x</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(122, '0_3_15');
      "><br>
    <span class="id" title="tactic">pose</span> <span class="id" title="var">proof</span> (<a class="idref" href="HoTT.HIT.Colimits.Colimit.html#ColimitHIT.colimit_rec_beta_colimp"><span class="id" title="definition">colimit_rec_beta_colimp</span></a> <span class="id" title="var">P</span> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Build_span_cocone"><span class="id" title="definition">Build_span_cocone</span></a> <span class="id" title="var">l'</span> <span class="id" title="var">r'</span> <span class="id" title="var">pp'</span>)<br>
                                    (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <span class="id" title="var">x</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(123, '0_3_15');
      "><br>
    <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#popp"><span class="id" title="definition">popp</span></a>; <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> ×.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(124, '0_3_15');
      "><br>
    <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_pp"><span class="id" title="definition">ap_pp</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>). </span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(125, '0_3_15');
      "><span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(126, '0_3_15');
      "><br>
    <span class="id" title="tactic">refine</span> (<span class="id" title="var">X</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#3b607a272444a2e3acbecfa52b796d2a"><span class="id" title="notation">@@</span></a> <span class="id" title="var">_</span>). </span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(127, '0_3_15');
      "><span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.PathGroupoids.html#inverse2"><span class="id" title="definition">inverse2</span></a> <span class="id" title="var">X0</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(128, '0_3_15');
      "><br>
    <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_V"><span class="id" title="definition">ap_V</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(129, '0_3_15');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(130, '0_3_15');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_15"><pre><span></span></pre></div>
<div class="doc" scenenumber="17">
A nice property: the pushout of an equivalence is an equivalence. 
</div>
<div scenenumber="19" class="code">
<span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(134, '0_3_19');
      ">
  <span class="id" title="keyword">Definition</span> <a name="PO_of_equiv"><span class="id" title="definition">PO_of_equiv</span></a> (<span class="id" title="var">Hf</span> : <a class="idref" href="HoTT.Basics.Overture.html#IsEquiv"><span class="id" title="class">IsEquiv</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a>)<br>
    : <a class="idref" href="HoTT.Basics.Overture.html#IsEquiv"><span class="id" title="class">IsEquiv</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#por"><span class="id" title="definition">por</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(135, '0_3_19');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(136, '0_3_19');
      "><br>
    <span class="id" title="var">serapply</span> <a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_adjointify"><span class="id" title="definition">isequiv_adjointify</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(137, '0_3_19');
      "><br>
    - <span class="id" title="var">serapply</span> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO_rec"><span class="id" title="definition">PO_rec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(138, '0_3_19');
      "><br>
      + <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a><a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">^-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(139, '0_3_19');
      "><br>
      + <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(140, '0_3_19');
      "><br>
      + <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>. </span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(141, '0_3_19');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(142, '0_3_19');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#eissect"><span class="id" title="projection">eissect</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(143, '0_3_19');
      "><br>
    - <span class="id" title="var">serapply</span> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO_ind"><span class="id" title="definition">PO_ind</span></a>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(144, '0_3_19');
      "><br>
      + <span class="id" title="tactic">intro</span>. </span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(145, '0_3_19');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.Colimits.Pushout.html#popp"><span class="id" title="definition">popp</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>). </span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(146, '0_3_19');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(147, '0_3_19');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#eisretr"><span class="id" title="projection">eisretr</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(148, '0_3_19');
      "><br>
      + <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(149, '0_3_19');
      "><br>
      + <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>; <span class="id" title="var">cbn</span>. </span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(150, '0_3_19');
      "><span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Types.Paths.html#transport_paths_FlFr"><span class="id" title="definition">transport_paths_FlFr</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_idmap"><span class="id" title="definition">ap_idmap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(151, '0_3_19');
      "><br>
        <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_compose"><span class="id" title="definition">ap_compose</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(152, '0_3_19');
      "><span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO_rec_beta_pp"><span class="id" title="definition">PO_rec_beta_pp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(153, '0_3_19');
      "><br>
        <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.Overture.html#eisadj"><span class="id" title="projection">eisadj</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(154, '0_3_19');
      "><span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.Basics.Overture.html#eissect"><span class="id" title="projection">eissect</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO.f"><span class="id" title="variable">f</span></a> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(155, '0_3_19');
      "><span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(156, '0_3_19');
      "><br>
        <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_1p"><span class="id" title="definition">concat_1p</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(157, '0_3_19');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_Vp"><span class="id" title="definition">concat_Vp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(158, '0_3_19');
      "><br>
    - <span class="id" title="tactic">intro</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(159, '0_3_19');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(160, '0_3_19');
      "><br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO"><span class="id" title="section">PO</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(161, '0_3_19');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_19"><pre><span></span></pre></div>
<div class="doc" scenenumber="21">
<a name="lab523"></a><h2 class="section">Equivalence with <span class="inlinecode"><a class="idref" href="HoTT.HIT.Pushout.html#pushout"><span class="id" title="definition">pushout</span></a></span>
</h2>
</div>
<div scenenumber="23" class="code">
<span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(168, '0_3_23');
      ">
<br>
<span class="id" title="keyword">Section</span> <a name="is_PO_pushout"><span class="id" title="section">is_PO_pushout</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(169, '0_3_23');
      "><br>
  <span class="id" title="keyword">Import</span> <span class="id" title="var">HIT.Pushout</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(170, '0_3_23');
      "><br>
  <span class="id" title="keyword">Context</span> `{<a class="idref" href="HoTT.Basics.Overture.html#Funext"><span class="id" title="class">Funext</span></a>} {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#B"><span class="id" title="variable">B</span></a>} {<span class="id" title="var">g</span> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#C"><span class="id" title="variable">C</span></a>}.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(171, '0_3_23');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="is_PO_pushout"><span class="id" title="definition">is_PO_pushout</span></a> : <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#is_PO"><span class="id" title="definition">is_PO</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#is_PO_pushout.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#is_PO_pushout.g"><span class="id" title="variable">g</span></a> (<a class="idref" href="HoTT.HIT.Pushout.html#pushout"><span class="id" title="definition">pushout</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#is_PO_pushout.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#is_PO_pushout.g"><span class="id" title="variable">g</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(172, '0_3_23');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(173, '0_3_23');
      "><br>
    <span class="id" title="var">unshelve</span> <span class="id" title="tactic">econstructor</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(174, '0_3_23');
      "><br>
    - <span class="id" title="var">serapply</span> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#Build_span_cocone"><span class="id" title="definition">Build_span_cocone</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(175, '0_3_23');
      "><br>
      + <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.HIT.Pushout.html#push"><span class="id" title="definition">push</span></a> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(176, '0_3_23');
      "><br>
      + <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.HIT.Pushout.html#push"><span class="id" title="definition">push</span></a> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(177, '0_3_23');
      "><br>
      + <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.HIT.Pushout.html#pp"><span class="id" title="definition">pp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(178, '0_3_23');
      "><br>
    - <span class="id" title="tactic">intro</span> <span class="id" title="var">Y</span>; <span class="id" title="var">serapply</span> <a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_adjointify"><span class="id" title="definition">isequiv_adjointify</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(179, '0_3_23');
      "><br>
      + <span class="id" title="tactic">intro</span> <span class="id" title="var">Co</span>. </span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(180, '0_3_23');
      "><span class="id" title="var">serapply</span> <a class="idref" href="HoTT.HIT.Pushout.html#pushout_rec"><span class="id" title="definition">pushout_rec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(181, '0_3_23');
      "><br>
        × <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#pol'"><span class="id" title="definition">pol'</span></a> <span class="id" title="var">Co</span>).</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(182, '0_3_23');
      "><br>
        × <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#por'"><span class="id" title="definition">por'</span></a> <span class="id" title="var">Co</span>).</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(183, '0_3_23');
      "><br>
        × <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.HIT.Colimits.Pushout.html#popp'"><span class="id" title="definition">popp'</span></a> <span class="id" title="var">Co</span>).</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(184, '0_3_23');
      "><br>
      + <span class="id" title="tactic">intros</span> [<span class="id" title="var">Co</span> <span class="id" title="var">Co'</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(185, '0_3_23');
      "><span class="id" title="var">serapply</span> <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#path_cocone"><span class="id" title="definition">path_cocone</span></a>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(186, '0_3_23');
      "><br>
        × <span class="id" title="tactic">intros</span> [[]|[]] <span class="id" title="var">x</span>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(187, '0_3_23');
      "><br>
          { <span class="id" title="tactic">apply</span> (<span class="id" title="var">Co'</span> (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>) (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>). }</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(188, '0_3_23');
      "><br>
          <span class="id" title="var">all</span>: <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(189, '0_3_23');
      "><br>
        × <span class="id" title="tactic">intros</span> [[]|[]] [[]|[]] [] <span class="id" title="var">x</span>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(190, '0_3_23');
      "><br>
          2: <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(191, '0_3_23');
      "><br>
          <span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_1p"><span class="id" title="definition">concat_1p</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(192, '0_3_23');
      "><br>
          <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.HIT.Pushout.html#pushout_rec_beta_pp"><span class="id" title="definition">pushout_rec_beta_pp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(193, '0_3_23');
      "><br>
          <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#popp'"><span class="id" title="definition">popp'</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(194, '0_3_23');
      "><span class="id" title="var">cbn</span>. </span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(195, '0_3_23');
      "><span class="id" title="var">hott_simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(196, '0_3_23');
      "><br>
      + <span class="id" title="tactic">intro</span> <span class="id" title="var">h</span>. </span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(197, '0_3_23');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#path_forall"><span class="id" title="definition">path_forall</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(198, '0_3_23');
      "><br>
        <span class="id" title="var">serapply</span> <a class="idref" href="HoTT.HIT.Pushout.html#pushout_ind"><span class="id" title="definition">pushout_ind</span></a>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(199, '0_3_23');
      "><br>
        × <span class="id" title="tactic">intros</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(200, '0_3_23');
      "><br>
        × <span class="id" title="tactic">intros</span> <span class="id" title="var">c</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(201, '0_3_23');
      "><br>
        × <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(202, '0_3_23');
      "><br>
          <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Types.Paths.html#transport_paths_FlFr"><span class="id" title="definition">transport_paths_FlFr</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(203, '0_3_23');
      "><span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(204, '0_3_23');
      "><br>
          <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.HIT.Pushout.html#pushout_rec_beta_pp"><span class="id" title="definition">pushout_rec_beta_pp</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(205, '0_3_23');
      "><span class="id" title="tactic">eapply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#moveR_Vp"><span class="id" title="definition">moveR_Vp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(206, '0_3_23');
      "><br>
          <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#popp'"><span class="id" title="definition">popp'</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(207, '0_3_23');
      "><span class="id" title="var">cbn</span>. </span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(208, '0_3_23');
      "><span class="id" title="tactic">by</span> <span class="id" title="tactic">rewrite</span> !<a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(209, '0_3_23');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(210, '0_3_23');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a name="equiv_pushout_PO"><span class="id" title="definition">equiv_pushout_PO</span></a><br>
    : <a class="idref" href="HoTT.HIT.Pushout.html#pushout"><span class="id" title="definition">pushout</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#is_PO_pushout.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#is_PO_pushout.g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#PO"><span class="id" title="definition">PO</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#is_PO_pushout.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#is_PO_pushout.g"><span class="id" title="variable">g</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(211, '0_3_23');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(212, '0_3_23');
      "><br>
    <span class="id" title="var">serapply</span> <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#colimit_unicity"><span class="id" title="lemma">colimit_unicity</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(213, '0_3_23');
      "><br>
    3: <span class="id" title="tactic">eapply</span> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#is_PO_pushout"><span class="id" title="definition">is_PO_pushout</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(214, '0_3_23');
      "><br>
    <span class="id" title="tactic">eapply</span> <a class="idref" href="HoTT.HIT.Colimits.Colimit.html#is_colimit_colimit"><span class="id" title="definition">is_colimit_colimit</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(215, '0_3_23');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(216, '0_3_23');
      "><br>
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.HIT.Colimits.Pushout.html#is_PO_pushout"><span class="id" title="section">is_PO_pushout</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(217, '0_3_23');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_23"><pre><span></span></pre></div>
</div>
<div id="footer" scenenumber="5" class="doc">
<hr>
<a href="index.html">Index</a><hr>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>
</div></body>
</html>
