<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="coqdoc.css" type="text/css" rel="stylesheet">
<link href="proviola.css" type="text/css" rel="stylesheet">
<script type="text/javascript">
        var responses = new Array();

        function mouseover(id, scene) {
          set_response(get_response(id), scene);
        };

        function mouseout(scene) {
          set_response("", scene);
        };

        function set_array() {
          

            i = 0;
            data = "";
            responses[i]=data;
          

            i = 1;
            data = "";
            responses[i]=data;
          

            i = 2;
            data = "";
            responses[i]=data;
          

            i = 3;
            data = "";
            responses[i]=data;
          

            i = 4;
            data = "";
            responses[i]=data;
          

            i = 5;
            data = "";
            responses[i]=data;
          

            i = 6;
            data = "";
            responses[i]=data;
          

            i = 7;
            data = "";
            responses[i]=data;
          

            i = 8;
            data = "";
            responses[i]=data;
          

            i = 9;
            data = "";
            responses[i]=data;
          

            i = 10;
            data = "";
            responses[i]=data;
          

            i = 11;
            data = "";
            responses[i]=data;
          

            i = 12;
            data = "";
            responses[i]=data;
          

            i = 13;
            data = "";
            responses[i]=data;
          

            i = 14;
            data = "";
            responses[i]=data;
          

            i = 15;
            data = "";
            responses[i]=data;
          

            i = 16;
            data = "";
            responses[i]=data;
          

            i = 17;
            data = "";
            responses[i]=data;
          

            i = 18;
            data = "";
            responses[i]=data;
          

            i = 19;
            data = "";
            responses[i]=data;
          

            i = 20;
            data = "";
            responses[i]=data;
          

            i = 21;
            data = "";
            responses[i]=data;
          

            i = 22;
            data = "";
            responses[i]=data;
          

            i = 23;
            data = "<infomsg>bitotal is defined</infomsg>	";
            responses[i]=data;
          

            i = 24;
            data = "";
            responses[i]=data;
          

            i = 25;
            data = "";
            responses[i]=data;
          

            i = 26;
            data = "";
            responses[i]=data;
          

            i = 27;
            data = "";
            responses[i]=data;
          

            i = 28;
            data = "";
            responses[i]=data;
          

            i = 29;
            data = "";
            responses[i]=data;
          

            i = 30;
            data = "";
            responses[i]=data;
          

            i = 31;
            data = "<infomsg>Interactive Module CumulativeHierarchy started</infomsg>	";
            responses[i]=data;
          

            i = 32;
            data = "<infomsg>V is defined</infomsg>	";
            responses[i]=data;
          

            i = 33;
            data = "<infomsg>setext is declared</infomsg>	";
            responses[i]=data;
          

            i = 34;
            data = "<infomsg>is0trunc_V is declared</infomsg>	";
            responses[i]=data;
          

            i = 35;
            data = "";
            responses[i]=data;
          

            i = 36;
            data = "<infomsg>V_ind is defined</infomsg>	<infomsg>V_ind is recursively defined (decreasing on 5th argument)</infomsg>	";
            responses[i]=data;
          

            i = 37;
            data = "";
            responses[i]=data;
          

            i = 38;
            data = "";
            responses[i]=data;
          

            i = 39;
            data = "";
            responses[i]=data;
          

            i = 40;
            data = "";
            responses[i]=data;
          

            i = 41;
            data = "<infomsg>Module CumulativeHierarchy is defined</infomsg>	";
            responses[i]=data;
          

            i = 42;
            data = "1 subgoal (ID 75)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext : forall (A B : Type) (R : A -> B -> hProp) 	             (bitot_R : bitotal R)	             (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	             (H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0),	                    P (h x)),	             transport P (setext R bitot_R h)	               (H_set A (h o spushl (fun (x : A) (x0 : B) => R x x0))	                  (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	             H_set B (h o spushr (fun (x : A) (x0 : B) => R x x0))	               (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  ============================	  apD (V_ind P H_0trunc H_set H_setext) (setext R bitot_R h) =	  H_setext A B R bitot_R h (V_ind P H_0trunc H_set H_setext oD h)	";
            responses[i]=data;
          

            i = 43;
            data = "";
            responses[i]=data;
          

            i = 44;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 45;
            data = "";
            responses[i]=data;
          

            i = 46;
            data = "";
            responses[i]=data;
          

            i = 47;
            data = "";
            responses[i]=data;
          

            i = 48;
            data = "";
            responses[i]=data;
          

            i = 49;
            data = "";
            responses[i]=data;
          

            i = 50;
            data = "1 subgoal (ID 132)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext : forall (A B : Type) (R : A -> B -> hProp),	             bitotal R ->	             forall (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	             (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P),	             H_set A (h o spushl (fun (x : A) (x0 : B) => R x x0))	               (H_h o spushl (fun (x : A) (x0 : B) => R x x0)) =	             H_set B (h o spushr (fun (x : A) (x0 : B) => R x x0))	               (H_h o spushr (fun (x : A) (x0 : B) => R x x0))	  ============================	  V -> P	";
            responses[i]=data;
          

            i = 51;
            data = "";
            responses[i]=data;
          

            i = 52;
            data = "1 subgoal (ID 152)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext : forall (A B : Type) (R : A -> B -> hProp),	             bitotal R ->	             forall (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	             (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P),	             H_set A (h o spushl (fun (x : A) (x0 : B) => R x x0))	               (H_h o spushl (fun (x : A) (x0 : B) => R x x0)) =	             H_set B (h o spushr (fun (x : A) (x0 : B) => R x x0))	               (H_h o spushr (fun (x : A) (x0 : B) => R x x0))	  ============================	  forall (A B : Type) (R : A -> B -> hProp) (bitot_R : bitotal R)	  (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	  (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P),	  transport (fun _ : V => P) (setext R bitot_R h)	    (H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	       (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	  H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	";
            responses[i]=data;
          

            i = 53;
            data = "1 subgoal (ID 158)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext : forall (A B : Type) (R : A -> B -> hProp),	             bitotal R ->	             forall (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	             (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P),	             H_set A (h o spushl (fun (x : A) (x0 : B) => R x x0))	               (H_h o spushl (fun (x : A) (x0 : B) => R x x0)) =	             H_set B (h o spushr (fun (x : A) (x0 : B) => R x x0))	               (H_h o spushr (fun (x : A) (x0 : B) => R x x0))	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  ============================	  transport (fun _ : V => P) (setext R bitot_R h)	    (H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	       (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	  H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	";
            responses[i]=data;
          

            i = 54;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 55;
            data = "";
            responses[i]=data;
          

            i = 56;
            data = "1 subgoal (ID 215)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext : forall (A B : Type) (R : A -> B -> hProp),	             bitotal R ->	             forall (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	             (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P),	             H_set A (h o spushl (fun (x : A) (x0 : B) => R x x0))	               (H_h o spushl (fun (x : A) (x0 : B) => R x x0)) =	             H_set B (h o spushr (fun (x : A) (x0 : B) => R x x0))	               (H_h o spushr (fun (x : A) (x0 : B) => R x x0))	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  ============================	  ap (V_rec P H_0trunc H_set H_setext) (setext R bitot_R h) =	  H_setext A B R bitot_R h (V_rec P H_0trunc H_set H_setext o h)	";
            responses[i]=data;
          

            i = 57;
            data = "";
            responses[i]=data;
          

            i = 58;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 59;
            data = "";
            responses[i]=data;
          

            i = 60;
            data = "";
            responses[i]=data;
          

            i = 61;
            data = "";
            responses[i]=data;
          

            i = 62;
            data = "";
            responses[i]=data;
          

            i = 63;
            data = "";
            responses[i]=data;
          

            i = 64;
            data = "";
            responses[i]=data;
          

            i = 65;
            data = "";
            responses[i]=data;
          

            i = 66;
            data = "";
            responses[i]=data;
          

            i = 67;
            data = "<infomsg>equal_img is defined</infomsg>	";
            responses[i]=data;
          

            i = 68;
            data = "1 subgoal (ID 234)	  	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	  set f = set g	";
            responses[i]=data;
          

            i = 69;
            data = "";
            responses[i]=data;
          

            i = 70;
            data = "1 subgoal (ID 260)	  	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  R := fun (a : A) (b : B) => BuildhProp (f a = g b) : A -> B -> hProp	  ============================	  set f = set g	";
            responses[i]=data;
          

            i = 71;
            data = "1 subgoal (ID 266)	  	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  R := fun (a : A) (b : B) => BuildhProp (f a = g b) : A -> B -> hProp	  h := SPushout_rec (fun (a : A) (b : B) => R a b) V f g	         (fun (x : A) (y : B) => idmap)	   : SPushout (fun (a : A) (b : B) => R a b) -> V	  ============================	  set f = set g	";
            responses[i]=data;
          

            i = 72;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 73;
            data = "";
            responses[i]=data;
          

            i = 74;
            data = "1 subgoal (ID 247)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  ============================	  V -> P	";
            responses[i]=data;
          

            i = 75;
            data = "";
            responses[i]=data;
          

            i = 76;
            data = "1 subgoal (ID 255)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  ============================	  forall (A B : Type) (R : A -> B -> hProp),	  bitotal R ->	  forall (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	  (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P),	  H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (fun x : A => H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) =	  H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (fun x : B => H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	";
            responses[i]=data;
          

            i = 77;
            data = "1 subgoal (ID 261)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  ============================	  H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (fun x : A => H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) =	  H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (fun x : B => H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	";
            responses[i]=data;
          

            i = 78;
            data = "2 subgoals (ID 262)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  ============================	  equal_img (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))		subgoal 2 (ID 263) is:	 equal_img (fun x : A => H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	   (fun x : B => H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	";
            responses[i]=data;
          

            i = 79;
            data = "1 subgoal (ID 262)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  ============================	  equal_img (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	2 subgoals (ID 265)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  ============================	  forall a : A,	  hexists	    (fun b : B =>	     h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	     h (spushr (fun (x : A) (x0 : B) => R x x0) b))		subgoal 2 (ID 266) is:	 forall b : B,	 hexists	   (fun a : A =>	    h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	    h (spushr (fun (x : A) (x0 : B) => R x x0) b))	";
            responses[i]=data;
          

            i = 80;
            data = "1 subgoal (ID 265)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  ============================	  forall a : A,	  hexists	    (fun b : B =>	     h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	     h (spushr (fun (x : A) (x0 : B) => R x x0) b))	1 subgoal (ID 267)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  a : A	  ============================	  hexists	    (fun b : B =>	     h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	     h (spushr (fun (x : A) (x0 : B) => R x x0) b))	";
            responses[i]=data;
          

            i = 81;
            data = "1 subgoal (ID 270)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  a : A	  ============================	  hexists (fun b : B => R a b) ->	  hexists	    (fun b : B =>	     h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	     h (spushr (fun (x : A) (x0 : B) => R x x0) b))	";
            responses[i]=data;
          

            i = 82;
            data = "1 subgoal (ID 273)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  a : A	  ============================	  {b : B & R a b} ->	  {b : B &	  h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	  h (spushr (fun (x : A) (x0 : B) => R x x0) b)}	";
            responses[i]=data;
          

            i = 83;
            data = "1 subgoal (ID 278)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  a : A	  b : B	  r : R a b	  ============================	  {b0 : B &	  h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	  h (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	";
            responses[i]=data;
          

            i = 84;
            data = "1 subgoal (ID 280)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  a : A	  b : B	  r : R a b	  ============================	  h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	  h (spushr (fun (x : A) (x0 : B) => R x x0) b)	";
            responses[i]=data;
          

            i = 85;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 subgoals (ID 266)		subgoal 1 (ID 266) is:	 forall b : B,	 hexists	   (fun a : A =>	    h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	    h (spushr (fun (x : A) (x0 : B) => R x x0) b))	subgoal 2 (ID 263) is:	 equal_img (fun x : A => H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	   (fun x : B => H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	";
            responses[i]=data;
          

            i = 86;
            data = "1 subgoal (ID 266)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  ============================	  forall b : B,	  hexists	    (fun a : A =>	     h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	     h (spushr (fun (x : A) (x0 : B) => R x x0) b))	1 subgoal (ID 291)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  b : B	  ============================	  hexists	    (fun a : A =>	     h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	     h (spushr (fun (x : A) (x0 : B) => R x x0) b))	";
            responses[i]=data;
          

            i = 87;
            data = "1 subgoal (ID 294)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  b : B	  ============================	  hexists (fun a : A => R a b) ->	  hexists	    (fun a : A =>	     h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	     h (spushr (fun (x : A) (x0 : B) => R x x0) b))	";
            responses[i]=data;
          

            i = 88;
            data = "1 subgoal (ID 297)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  b : B	  ============================	  {a : A & R a b} ->	  {a : A &	  h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	  h (spushr (fun (x : A) (x0 : B) => R x x0) b)}	";
            responses[i]=data;
          

            i = 89;
            data = "1 subgoal (ID 302)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  b : B	  a : A	  r : R a b	  ============================	  {a0 : A &	  h (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	  h (spushr (fun (x : A) (x0 : B) => R x x0) b)}	";
            responses[i]=data;
          

            i = 90;
            data = "1 subgoal (ID 304)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  b : B	  a : A	  r : R a b	  ============================	  h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	  h (spushr (fun (x : A) (x0 : B) => R x x0) b)	";
            responses[i]=data;
          

            i = 91;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 263)		subgoal 1 (ID 263) is:	 equal_img (fun x : A => H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	   (fun x : B => H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	";
            responses[i]=data;
          

            i = 92;
            data = "1 subgoal (ID 263)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  ============================	  equal_img (fun x : A => H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (fun x : B => H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	2 subgoals (ID 316)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  ============================	  forall a : A,	  hexists	    (fun b : B =>	     H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	     H_h (spushr (fun (x : A) (x0 : B) => R x x0) b))		subgoal 2 (ID 317) is:	 forall b : B,	 hexists	   (fun a : A =>	    H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	    H_h (spushr (fun (x : A) (x0 : B) => R x x0) b))	";
            responses[i]=data;
          

            i = 93;
            data = "1 subgoal (ID 316)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  ============================	  forall a : A,	  hexists	    (fun b : B =>	     H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	     H_h (spushr (fun (x : A) (x0 : B) => R x x0) b))	1 subgoal (ID 318)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  a : A	  ============================	  hexists	    (fun b : B =>	     H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	     H_h (spushr (fun (x : A) (x0 : B) => R x x0) b))	";
            responses[i]=data;
          

            i = 94;
            data = "1 subgoal (ID 321)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  a : A	  ============================	  hexists (fun b : B => R a b) ->	  hexists	    (fun b : B =>	     H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	     H_h (spushr (fun (x : A) (x0 : B) => R x x0) b))	";
            responses[i]=data;
          

            i = 95;
            data = "1 subgoal (ID 324)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  a : A	  ============================	  {b : B & R a b} ->	  {b : B &	  H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	  H_h (spushr (fun (x : A) (x0 : B) => R x x0) b)}	";
            responses[i]=data;
          

            i = 96;
            data = "1 subgoal (ID 329)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  a : A	  b : B	  r : R a b	  ============================	  {b0 : B &	  H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	  H_h (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	";
            responses[i]=data;
          

            i = 97;
            data = "1 subgoal (ID 331)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  a : A	  b : B	  r : R a b	  ============================	  H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	  H_h (spushr (fun (x : A) (x0 : B) => R x x0) b)	";
            responses[i]=data;
          

            i = 98;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 subgoal (ID 317)		subgoal 1 (ID 317) is:	 forall b : B,	 hexists	   (fun a : A =>	    H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	    H_h (spushr (fun (x : A) (x0 : B) => R x x0) b))	";
            responses[i]=data;
          

            i = 99;
            data = "1 subgoal (ID 317)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  ============================	  forall b : B,	  hexists	    (fun a : A =>	     H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	     H_h (spushr (fun (x : A) (x0 : B) => R x x0) b))	1 subgoal (ID 342)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  b : B	  ============================	  hexists	    (fun a : A =>	     H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	     H_h (spushr (fun (x : A) (x0 : B) => R x x0) b))	";
            responses[i]=data;
          

            i = 100;
            data = "1 subgoal (ID 345)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  b : B	  ============================	  hexists (fun a : A => R a b) ->	  hexists	    (fun a : A =>	     H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	     H_h (spushr (fun (x : A) (x0 : B) => R x x0) b))	";
            responses[i]=data;
          

            i = 101;
            data = "1 subgoal (ID 348)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  b : B	  ============================	  {a : A & R a b} ->	  {a : A &	  H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	  H_h (spushr (fun (x : A) (x0 : B) => R x x0) b)}	";
            responses[i]=data;
          

            i = 102;
            data = "1 subgoal (ID 353)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  b : B	  a : A	  r : R a b	  ============================	  {a0 : A &	  H_h (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	  H_h (spushr (fun (x : A) (x0 : B) => R x x0) b)}	";
            responses[i]=data;
          

            i = 103;
            data = "1 subgoal (ID 355)	  	  P : Type	  H_0trunc : IsHSet P	  H_set : forall A : Type, (A -> V) -> (A -> P) -> P	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V),	              equal_img f g ->	              forall (H_f : A -> P) (H_g : B -> P),	              equal_img H_f H_g -> H_set A f H_f = H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> P	  b : B	  a : A	  r : R a b	  ============================	  H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	  H_h (spushr (fun (x : A) (x0 : B) => R x x0) b)	";
            responses[i]=data;
          

            i = 104;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 105;
            data = "";
            responses[i]=data;
          

            i = 106;
            data = "";
            responses[i]=data;
          

            i = 107;
            data = "";
            responses[i]=data;
          

            i = 108;
            data = "";
            responses[i]=data;
          

            i = 109;
            data = "";
            responses[i]=data;
          

            i = 110;
            data = "1 subgoal (ID 287)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  ============================	  forall v : V, P v	";
            responses[i]=data;
          

            i = 111;
            data = "";
            responses[i]=data;
          

            i = 112;
            data = "1 subgoal (ID 290)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  ============================	  forall (A B : Type) (R : A -> B -> hProp) (bitot_R : bitotal R)	  (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	  (H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)),	  transport P (setext R bitot_R h)	    (H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	       (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	  H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	";
            responses[i]=data;
          

            i = 113;
            data = "1 subgoal (ID 296)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  ============================	  transport P (setext R bitot_R h)	    (H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	       (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	  H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	";
            responses[i]=data;
          

            i = 114;
            data = "1 subgoal (ID 308)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  ============================	  transport P (setext R bitot_R h)	    (H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	       (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	  H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	";
            responses[i]=data;
          

            i = 115;
            data = "1 subgoal (ID 320)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  ============================	  transport P (setext R bitot_R h)	    (H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	       (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	  H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	";
            responses[i]=data;
          

            i = 116;
            data = "1 subgoal (ID 326)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  ============================	  transport P (setext R bitot_R h)	    (H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	       (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	  H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	";
            responses[i]=data;
          

            i = 117;
            data = "1 subgoal (ID 332)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  ============================	  transport P (setext R bitot_R h)	    (H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	       (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	  H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	";
            responses[i]=data;
          

            i = 118;
            data = "2 subgoals (ID 336)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  ============================	  equal_img f g		subgoal 2 (ID 338) is:	 transport P (setext R bitot_R h)	   (H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	      (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	 H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	   (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	";
            responses[i]=data;
          

            i = 119;
            data = "1 subgoal (ID 336)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  ============================	  equal_img f g	2 subgoals (ID 340)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  ============================	  forall a : A, hexists (fun b : B => f a = g b)		subgoal 2 (ID 341) is:	 forall b : B, hexists (fun a : A => f a = g b)	";
            responses[i]=data;
          

            i = 120;
            data = "1 subgoal (ID 340)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  ============================	  forall a : A, hexists (fun b : B => f a = g b)	1 subgoal (ID 342)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  a : A	  ============================	  hexists (fun b : B => f a = g b)	";
            responses[i]=data;
          

            i = 121;
            data = "1 subgoal (ID 345)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  a : A	  ============================	  hexists (fun b : B => R a b) -> hexists (fun b : B => f a = g b)	";
            responses[i]=data;
          

            i = 122;
            data = "1 subgoal (ID 348)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  a : A	  ============================	  {b : B & R a b} -> {b : B & f a = g b}	";
            responses[i]=data;
          

            i = 123;
            data = "1 subgoal (ID 353)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  a : A	  b : B	  r : R a b	  ============================	  {b0 : B & f a = g b0}	";
            responses[i]=data;
          

            i = 124;
            data = "1 subgoal (ID 355)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  a : A	  b : B	  r : R a b	  ============================	  f a = g b	";
            responses[i]=data;
          

            i = 125;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	2 subgoals (ID 341)		subgoal 1 (ID 341) is:	 forall b : B, hexists (fun a : A => f a = g b)	subgoal 2 (ID 338) is:	 transport P (setext R bitot_R h)	   (H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	      (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	 H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	   (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	";
            responses[i]=data;
          

            i = 126;
            data = "1 subgoal (ID 341)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  ============================	  forall b : B, hexists (fun a : A => f a = g b)	1 subgoal (ID 366)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  b : B	  ============================	  hexists (fun a : A => f a = g b)	";
            responses[i]=data;
          

            i = 127;
            data = "1 subgoal (ID 369)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  b : B	  ============================	  hexists (fun a : A => R a b) -> hexists (fun a : A => f a = g b)	";
            responses[i]=data;
          

            i = 128;
            data = "1 subgoal (ID 372)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  b : B	  ============================	  {a : A & R a b} -> {a : A & f a = g b}	";
            responses[i]=data;
          

            i = 129;
            data = "1 subgoal (ID 377)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  b : B	  a : A	  r : R a b	  ============================	  {a0 : A & f a0 = g b}	";
            responses[i]=data;
          

            i = 130;
            data = "1 subgoal (ID 379)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  b : B	  a : A	  r : R a b	  ============================	  f a = g b	";
            responses[i]=data;
          

            i = 131;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 subgoal (ID 338)		subgoal 1 (ID 338) is:	 transport P (setext R bitot_R h)	   (H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	      (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	 H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	   (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	";
            responses[i]=data;
          

            i = 132;
            data = "1 subgoal (ID 338)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	  transport P (setext R bitot_R h)	    (H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	       (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	  H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	";
            responses[i]=data;
          

            i = 133;
            data = "2 subgoals (ID 448)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	  transport P (setext R bitot_R h)	    (H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	       (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	  transport P	    (setext' (h o spushl (fun (x : A) (x0 : B) => R x x0))	       (h o spushr (fun (x : A) (x0 : B) => R x x0)) eq_img)	    (H_set A (h o spushl (fun (x : A) (x0 : B) => R x x0))	       (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)))		subgoal 2 (ID 450) is:	 transport P	   (setext' (h o spushl (fun (x : A) (x0 : B) => R x x0))	      (h o spushr (fun (x : A) (x0 : B) => R x x0)) eq_img)	   (H_set A (h o spushl (fun (x : A) (x0 : B) => R x x0))	      (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	 H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	   (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	1 subgoal (ID 448)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	  transport P (setext R bitot_R h)	    (H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	       (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	  transport P	    (setext' (h o spushl (fun (x : A) (x0 : B) => R x x0))	       (h o spushr (fun (x : A) (x0 : B) => R x x0)) eq_img)	    (H_set A (h o spushl (fun (x : A) (x0 : B) => R x x0))	       (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)))	1 subgoal (ID 477)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	  setext R bitot_R h =	  setext' (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) eq_img	";
            responses[i]=data;
          

            i = 134;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 subgoal (ID 450)		subgoal 1 (ID 450) is:	 transport P	   (setext' (h o spushl (fun (x : A) (x0 : B) => R x x0))	      (h o spushr (fun (x : A) (x0 : B) => R x x0)) eq_img)	   (H_set A (h o spushl (fun (x : A) (x0 : B) => R x x0))	      (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	 H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	   (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	1 subgoal (ID 450)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	  transport P	    (setext' (h o spushl (fun (x : A) (x0 : B) => R x x0))	       (h o spushr (fun (x : A) (x0 : B) => R x x0)) eq_img)	    (H_set A (h o spushl (fun (x : A) (x0 : B) => R x x0))	       (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	  H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	1 subgoal (ID 500)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	  (forall a : A,	   hexists	     (fun b : B =>	      hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	  (forall b : B,	   hexists	     (fun a : A =>	      hexists (fun p : f a = g b => transport P p (H_f a) = H_g b)))	";
            responses[i]=data;
          

            i = 135;
            data = "2 subgoals (ID 502)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	  forall a : A,	  hexists	    (fun b : B =>	     hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))		subgoal 2 (ID 503) is:	 forall b : B,	 hexists	   (fun a : A => hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))	";
            responses[i]=data;
          

            i = 136;
            data = "1 subgoal (ID 502)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	  forall a : A,	  hexists	    (fun b : B =>	     hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))	1 subgoal (ID 504)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  ============================	  hexists	    (fun b : B =>	     hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))	";
            responses[i]=data;
          

            i = 137;
            data = "1 subgoal (ID 508)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  ============================	  hexists	    (fun b : B =>	     hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))	";
            responses[i]=data;
          

            i = 138;
            data = "1 subgoal (ID 509)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  ============================	  hexists (fun b : B => R a b) ->	  hexists	    (fun b : B =>	     hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))	";
            responses[i]=data;
          

            i = 139;
            data = "1 subgoal (ID 512)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  ============================	  {b : B & R a b} ->	  {b : B & hexists (fun p : f a = g b => transport P p (H_f a) = H_g b)}	";
            responses[i]=data;
          

            i = 140;
            data = "1 subgoal (ID 517)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  b : B	  Rab : R a b	  ============================	  {b0 : B & hexists (fun p : f a = g b0 => transport P p (H_f a) = H_g b0)}	";
            responses[i]=data;
          

            i = 141;
            data = "1 subgoal (ID 519)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  b : B	  Rab : R a b	  ============================	  hexists (fun p : f a = g b => transport P p (H_f a) = H_g b)	";
            responses[i]=data;
          

            i = 142;
            data = "1 subgoal (ID 522)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  b : B	  Rab : R a b	  ============================	  {p : f a = g b & transport P p (H_f a) = H_g b}	";
            responses[i]=data;
          

            i = 143;
            data = "1 subgoal (ID 534)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  b : B	  Rab : R a b	  ============================	  transport P (ap h (spglue (fun (x : A) (x0 : B) => R x x0) Rab)) (H_f a) =	  H_g b	";
            responses[i]=data;
          

            i = 144;
            data = "1 subgoal (ID 557)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  b : B	  Rab : R a b	  ============================	  transport P (ap h (spglue (fun (x : A) (x0 : B) => R x x0) Rab)) (H_f a) =	  transport (fun x : SPushout (fun (x : A) (x0 : B) => R x x0) => P (h x))	    (spglue (fun (x : A) (x0 : B) => R x x0) Rab)	    (H_h (spushl (fun (x : A) (x0 : B) => R x x0) a))	";
            responses[i]=data;
          

            i = 145;
            data = "1 subgoal (ID 561)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  b : B	  Rab : R a b	  ============================	  transport (fun x : SPushout (fun (x : A) (x0 : B) => R x x0) => P (h x))	    (spglue (fun (x : A) (x0 : B) => R x x0) Rab)	    (H_h (spushl (fun (x : A) (x0 : B) => R x x0) a)) =	  transport P (ap h (spglue (fun (x : A) (x0 : B) => R x x0) Rab)) (H_f a)	";
            responses[i]=data;
          

            i = 146;
            data = "1 subgoal (ID 563)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  a : A	  truncb := fst bitot_R a : hexists (fun b : B => R a b)	  b : B	  Rab : R a b	  ============================	  transport (fun x : SPushout (fun (x : A) (x0 : B) => R x x0) => P (h x))	    (spglue (fun (x : A) (x0 : B) => R x x0) Rab)	    (H_h (spushl (fun (x : A) (x0 : B) => R x x0) a)) =	  transport P (ap h (spglue (fun (x : A) (x0 : B) => R x x0) Rab)) (H_f a)	";
            responses[i]=data;
          

            i = 147;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 503)		subgoal 1 (ID 503) is:	 forall b : B,	 hexists	   (fun a : A => hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))	";
            responses[i]=data;
          

            i = 148;
            data = "1 subgoal (ID 503)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  ============================	  forall b : B,	  hexists	    (fun a : A =>	     hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))	1 subgoal (ID 568)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  ============================	  hexists	    (fun a : A =>	     hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))	";
            responses[i]=data;
          

            i = 149;
            data = "1 subgoal (ID 572)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  ============================	  hexists	    (fun a : A =>	     hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))	";
            responses[i]=data;
          

            i = 150;
            data = "1 subgoal (ID 573)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  ============================	  hexists (fun a : A => R a b) ->	  hexists	    (fun a : A =>	     hexists (fun p : f a = g b => transport P p (H_f a) = H_g b))	";
            responses[i]=data;
          

            i = 151;
            data = "1 subgoal (ID 576)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  ============================	  {a : A & R a b} ->	  {a : A & hexists (fun p : f a = g b => transport P p (H_f a) = H_g b)}	";
            responses[i]=data;
          

            i = 152;
            data = "1 subgoal (ID 581)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	  {a0 : A & hexists (fun p : f a0 = g b => transport P p (H_f a0) = H_g b)}	";
            responses[i]=data;
          

            i = 153;
            data = "1 subgoal (ID 583)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	  hexists (fun p : f a = g b => transport P p (H_f a) = H_g b)	";
            responses[i]=data;
          

            i = 154;
            data = "1 subgoal (ID 586)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	  {p : f a = g b & transport P p (H_f a) = H_g b}	";
            responses[i]=data;
          

            i = 155;
            data = "1 subgoal (ID 598)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	  transport P (ap h (spglue (fun (x : A) (x0 : B) => R x x0) Rab)) (H_f a) =	  H_g b	";
            responses[i]=data;
          

            i = 156;
            data = "1 subgoal (ID 621)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	  transport P (ap h (spglue (fun (x : A) (x0 : B) => R x x0) Rab)) (H_f a) =	  transport (fun x : SPushout (fun (x : A) (x0 : B) => R x x0) => P (h x))	    (spglue (fun (x : A) (x0 : B) => R x x0) Rab)	    (H_h (spushl (fun (x : A) (x0 : B) => R x x0) a))	";
            responses[i]=data;
          

            i = 157;
            data = "1 subgoal (ID 625)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	  transport (fun x : SPushout (fun (x : A) (x0 : B) => R x x0) => P (h x))	    (spglue (fun (x : A) (x0 : B) => R x x0) Rab)	    (H_h (spushl (fun (x : A) (x0 : B) => R x x0) a)) =	  transport P (ap h (spglue (fun (x : A) (x0 : B) => R x x0) Rab)) (H_f a)	";
            responses[i]=data;
          

            i = 158;
            data = "1 subgoal (ID 627)	  	  P : V -> Type	  H_0trunc : forall v : V, IsHSet (P v)	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  H_setext' : forall (A B : Type) (f : A -> V) (g : B -> V)	              (eq_img : equal_img f g) (H_f : forall a : A, P (f a))	              (H_g : forall b : B, P (g b)),	              (forall a : A,	               hexists	                 (fun b : B =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) *	              (forall b : B,	               hexists	                 (fun a : A =>	                  hexists	                    (fun p : f a = g b => transport P p (H_f a) = H_g b))) ->	              transport P (setext' f g eq_img) (H_set A f H_f) =	              H_set B g H_g	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  f := (h o spushl (fun (x : A) (x0 : B) => R x x0) : A -> V) : A -> V	  g := (h o spushr (fun (x : A) (x0 : B) => R x x0) : B -> V) : B -> V	  H_f := (H_h oD spushl (fun (x : A) (x0 : B) => R x x0)	          :	          forall a : A, P (f a)) : forall a : A, P (f a)	  H_g := (H_h oD spushr (fun (x : A) (x0 : B) => R x x0)	          :	          forall b : B, P (g b)) : forall b : B, P (g b)	  eq_img : equal_img f g	  b : B	  trunca := snd bitot_R b : hexists (fun a : A => R a b)	  a : A	  Rab : R a b	  ============================	  transport (fun x : SPushout (fun (x : A) (x0 : B) => R x x0) => P (h x))	    (spglue (fun (x : A) (x0 : B) => R x x0) Rab)	    (H_h (spushl (fun (x : A) (x0 : B) => R x x0) a)) =	  transport P (ap h (spglue (fun (x : A) (x0 : B) => R x x0) Rab)) (H_f a)	";
            responses[i]=data;
          

            i = 159;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 160;
            data = "";
            responses[i]=data;
          

            i = 161;
            data = "";
            responses[i]=data;
          

            i = 162;
            data = "";
            responses[i]=data;
          

            i = 163;
            data = "";
            responses[i]=data;
          

            i = 164;
            data = "";
            responses[i]=data;
          

            i = 165;
            data = "1 subgoal (ID 292)	  	  P : V -> Type	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  isHProp_P : forall v : V, IsHProp (P v)	  ============================	  forall v : V, P v	";
            responses[i]=data;
          

            i = 166;
            data = "";
            responses[i]=data;
          

            i = 167;
            data = "1 subgoal (ID 316)	  	  P : V -> Type	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  isHProp_P : forall v : V, IsHProp (P v)	  ============================	  forall (A B : Type) (R : A -> B -> hProp) (bitot_R : bitotal R)	  (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	  (H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)),	  transport P (setext R bitot_R h)	    (H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	       (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	  H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	";
            responses[i]=data;
          

            i = 168;
            data = "1 subgoal (ID 322)	  	  P : V -> Type	  H_set : forall (A : Type) (f : A -> V),	          (forall a : A, P (f a)) -> P (set f)	  isHProp_P : forall v : V, IsHProp (P v)	  A : Type	  B : Type	  R : A -> B -> hProp	  bitot_R : bitotal R	  h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V	  H_h : forall x : SPushout (fun (x : A) (x0 : B) => R x x0), P (h x)	  ============================	  transport P (setext R bitot_R h)	    (H_set A (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	       (H_h oD spushl (fun (x : A) (x0 : B) => R x x0))) =	  H_set B (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	    (H_h oD spushr (fun (x : A) (x0 : B) => R x x0))	";
            responses[i]=data;
          

            i = 169;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 170;
            data = "";
            responses[i]=data;
          

            i = 171;
            data = "";
            responses[i]=data;
          

            i = 172;
            data = "<infomsg>ua is declared</infomsg>	";
            responses[i]=data;
          

            i = 173;
            data = "";
            responses[i]=data;
          

            i = 174;
            data = "";
            responses[i]=data;
          

            i = 175;
            data = "";
            responses[i]=data;
          

            i = 176;
            data = "";
            responses[i]=data;
          

            i = 177;
            data = "";
            responses[i]=data;
          

            i = 178;
            data = "";
            responses[i]=data;
          

            i = 179;
            data = "";
            responses[i]=data;
          

            i = 180;
            data = "1 subgoal (ID 294)	  	  ua : Univalence	  x : V	  ============================	  V -> hProp	";
            responses[i]=data;
          

            i = 181;
            data = "";
            responses[i]=data;
          

            i = 182;
            data = "2 subgoals (ID 300)	  	  ua : Univalence	  x : V	  ============================	  forall A : Type, (A -> V) -> (A -> hProp) -> hProp		subgoal 2 (ID 302) is:	 forall (A B : Type) (f : A -> V) (g : B -> V),	 equal_img f g ->	 forall (H_f : A -> hProp) (H_g : B -> hProp),	 equal_img H_f H_g -> ?H_set A f H_f = ?H_set B g H_g	";
            responses[i]=data;
          

            i = 183;
            data = "1 subgoal (ID 300)	  	  ua : Univalence	  x : V	  ============================	  forall A : Type, (A -> V) -> (A -> hProp) -> hProp	1 subgoal (ID 307)	  	  ua : Univalence	  x : V	  A : Type	  f : A -> V	  ============================	  hProp	";
            responses[i]=data;
          

            i = 184;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 302)		subgoal 1 (ID 302) is:	 forall (A B : Type) (f : A -> V) (g : B -> V),	 equal_img f g ->	 forall (H_f : A -> hProp) (H_g : B -> hProp),	 equal_img H_f H_g ->	 (fun (A0 : Type) (f0 : A0 -> V) (_ : A0 -> hProp) =>	  hexists (fun a : A0 => f0 a = x)) A f H_f =	 (fun (A0 : Type) (f0 : A0 -> V) (_ : A0 -> hProp) =>	  hexists (fun a : A0 => f0 a = x)) B g H_g	";
            responses[i]=data;
          

            i = 185;
            data = "1 subgoal (ID 302)	  	  ua : Univalence	  x : V	  ============================	  forall (A B : Type) (f : A -> V) (g : B -> V),	  equal_img f g ->	  forall (H_f : A -> hProp) (H_g : B -> hProp),	  equal_img H_f H_g ->	  (fun (A0 : Type) (f0 : A0 -> V) (_ : A0 -> hProp) =>	   hexists (fun a : A0 => f0 a = x)) A f H_f =	  (fun (A0 : Type) (f0 : A0 -> V) (_ : A0 -> hProp) =>	   hexists (fun a : A0 => f0 a = x)) B g H_g	1 subgoal (ID 312)	  	  ua : Univalence	  x : V	  ============================	  forall (A B : Type) (f : A -> V) (g : B -> V),	  equal_img f g ->	  forall (H_f : A -> hProp) (H_g : B -> hProp),	  equal_img H_f H_g ->	  hexists (fun a : A => f a = x) = hexists (fun a : B => g a = x)	";
            responses[i]=data;
          

            i = 186;
            data = "1 subgoal (ID 323)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  ============================	  hexists (fun a : A => f a = x) = hexists (fun a : B => g a = x)	";
            responses[i]=data;
          

            i = 187;
            data = "2 subgoals (ID 330)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  ============================	  Trunc (-1) {a : A & f a = x} -> Trunc (-1) {a : B & g a = x}		subgoal 2 (ID 332) is:	 Trunc (-1) {a : B & g a = x} -> Trunc (-1) {a : A & f a = x}	";
            responses[i]=data;
          

            i = 188;
            data = "1 subgoal (ID 330)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  ============================	  Trunc (-1) {a : A & f a = x} -> Trunc (-1) {a : B & g a = x}	1 subgoal (ID 333)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : A & f a = x}	  ============================	  Trunc (-1) {a : B & g a = x}	";
            responses[i]=data;
          

            i = 189;
            data = "1 subgoal (ID 340)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : A & f a = x}	  ============================	  {a : A & f a = x} -> Trunc (-1) {a : B & g a = x}	";
            responses[i]=data;
          

            i = 190;
            data = "1 subgoal (ID 345)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : A & f a = x}	  a : A	  p : f a = x	  ============================	  Trunc (-1) {a0 : B & g a0 = x}	";
            responses[i]=data;
          

            i = 191;
            data = "1 subgoal (ID 348)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : A & f a = x}	  a : A	  p : f a = x	  ============================	  hexists (fun b : B => f a = g b) -> Trunc (-1) {a0 : B & g a0 = x}	";
            responses[i]=data;
          

            i = 192;
            data = "1 subgoal (ID 351)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : A & f a = x}	  a : A	  p : f a = x	  ============================	  {b : B & f a = g b} -> {a0 : B & g a0 = x}	";
            responses[i]=data;
          

            i = 193;
            data = "1 subgoal (ID 356)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : A & f a = x}	  a : A	  p : f a = x	  b : B	  p' : f a = g b	  ============================	  {a0 : B & g a0 = x}	";
            responses[i]=data;
          

            i = 194;
            data = "1 subgoal (ID 358)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : A & f a = x}	  a : A	  p : f a = x	  b : B	  p' : f a = g b	  ============================	  g b = x	";
            responses[i]=data;
          

            i = 195;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 subgoal (ID 332)		subgoal 1 (ID 332) is:	 Trunc (-1) {a : B & g a = x} -> Trunc (-1) {a : A & f a = x}	";
            responses[i]=data;
          

            i = 196;
            data = "1 subgoal (ID 332)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  ============================	  Trunc (-1) {a : B & g a = x} -> Trunc (-1) {a : A & f a = x}	1 subgoal (ID 378)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : B & g a = x}	  ============================	  Trunc (-1) {a : A & f a = x}	";
            responses[i]=data;
          

            i = 197;
            data = "1 subgoal (ID 385)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : B & g a = x}	  ============================	  {a : B & g a = x} -> Trunc (-1) {a : A & f a = x}	";
            responses[i]=data;
          

            i = 198;
            data = "1 subgoal (ID 390)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : B & g a = x}	  b : B	  p : g b = x	  ============================	  Trunc (-1) {a : A & f a = x}	";
            responses[i]=data;
          

            i = 199;
            data = "1 subgoal (ID 393)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : B & g a = x}	  b : B	  p : g b = x	  ============================	  hexists (fun a : A => f a = g b) -> Trunc (-1) {a : A & f a = x}	";
            responses[i]=data;
          

            i = 200;
            data = "1 subgoal (ID 396)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : B & g a = x}	  b : B	  p : g b = x	  ============================	  {a : A & f a = g b} -> {a : A & f a = x}	";
            responses[i]=data;
          

            i = 201;
            data = "1 subgoal (ID 401)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : B & g a = x}	  b : B	  p : g b = x	  a : A	  p' : f a = g b	  ============================	  {a0 : A & f a0 = x}	";
            responses[i]=data;
          

            i = 202;
            data = "1 subgoal (ID 403)	  	  ua : Univalence	  x : V	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eqimg : equal_img f g	  H : Trunc (-1) {a : B & g a = x}	  b : B	  p : g b = x	  a : A	  p' : f a = g b	  ============================	  f a = x	";
            responses[i]=data;
          

            i = 203;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 204;
            data = "";
            responses[i]=data;
          

            i = 205;
            data = "";
            responses[i]=data;
          

            i = 206;
            data = "";
            responses[i]=data;
          

            i = 207;
            data = "";
            responses[i]=data;
          

            i = 208;
            data = "";
            responses[i]=data;
          

            i = 209;
            data = "";
            responses[i]=data;
          

            i = 210;
            data = "";
            responses[i]=data;
          

            i = 211;
            data = "";
            responses[i]=data;
          

            i = 212;
            data = "";
            responses[i]=data;
          

            i = 213;
            data = "";
            responses[i]=data;
          

            i = 214;
            data = "";
            responses[i]=data;
          

            i = 215;
            data = "<infomsg>subset is defined</infomsg>	";
            responses[i]=data;
          

            i = 216;
            data = "";
            responses[i]=data;
          

            i = 217;
            data = "";
            responses[i]=data;
          

            i = 218;
            data = "";
            responses[i]=data;
          

            i = 219;
            data = "";
            responses[i]=data;
          

            i = 220;
            data = "";
            responses[i]=data;
          

            i = 221;
            data = "";
            responses[i]=data;
          

            i = 222;
            data = "";
            responses[i]=data;
          

            i = 223;
            data = "";
            responses[i]=data;
          

            i = 224;
            data = "1 subgoal (ID 363)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  ============================	  V -> hProp	";
            responses[i]=data;
          

            i = 225;
            data = "";
            responses[i]=data;
          

            i = 226;
            data = "2 subgoals (ID 469)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  ============================	  IsHSet hProp		subgoal 2 (ID 470) is:	 forall (A0 B : Type) (f0 : A0 -> V) (g : B -> V),	 equal_img f0 g ->	 forall (H_f0 : A0 -> hProp) (H_g : B -> hProp),	 equal_img H_f0 H_g ->	 BuildhProp	   ((forall a : A, hexists (fun b : A0 => H_f a (f0 b))) *	    (forall b : A0, hexists (fun a : A => H_f a (f0 b)))) =	 BuildhProp	   ((forall a : A, hexists (fun b : B => H_f a (g b))) *	    (forall b : B, hexists (fun a : A => H_f a (g b))))	";
            responses[i]=data;
          

            i = 227;
            data = "1 subgoal (ID 469)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  ============================	  IsHSet hProp	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 470)		subgoal 1 (ID 470) is:	 forall (A0 B : Type) (f0 : A0 -> V) (g : B -> V),	 equal_img f0 g ->	 forall (H_f0 : A0 -> hProp) (H_g : B -> hProp),	 equal_img H_f0 H_g ->	 BuildhProp	   ((forall a : A, hexists (fun b : A0 => H_f a (f0 b))) *	    (forall b : A0, hexists (fun a : A => H_f a (f0 b)))) =	 BuildhProp	   ((forall a : A, hexists (fun b : B => H_f a (g b))) *	    (forall b : B, hexists (fun a : A => H_f a (g b))))	";
            responses[i]=data;
          

            i = 228;
            data = "1 subgoal (ID 470)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  ============================	  forall (A0 B : Type) (f0 : A0 -> V) (g : B -> V),	  equal_img f0 g ->	  forall (H_f0 : A0 -> hProp) (H_g : B -> hProp),	  equal_img H_f0 H_g ->	  BuildhProp	    ((forall a : A, hexists (fun b : A0 => H_f a (f0 b))) *	     (forall b : A0, hexists (fun a : A => H_f a (f0 b)))) =	  BuildhProp	    ((forall a : A, hexists (fun b : B => H_f a (g b))) *	     (forall b : B, hexists (fun a : A => H_f a (g b))))	1 subgoal (ID 526)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  ============================	  BuildhProp	    ((forall a : A, Trunc (-1) {b : B & H_f a (g b)}) *	     (forall b : B, Trunc (-1) {a : A & H_f a (g b)})) =	  BuildhProp	    ((forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}) *	     (forall b : B', Trunc (-1) {a : A & H_f a (g' b)}))	";
            responses[i]=data;
          

            i = 229;
            data = "2 subgoals (ID 533)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  ============================	  (forall a : A, Trunc (-1) {b : B & H_f a (g b)}) *	  (forall b : B, Trunc (-1) {a : A & H_f a (g b)}) ->	  (forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}) *	  (forall b : B', Trunc (-1) {a : A & H_f a (g' b)})		subgoal 2 (ID 535) is:	 (forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}) *	 (forall b : B', Trunc (-1) {a : A & H_f a (g' b)}) ->	 (forall a : A, Trunc (-1) {b : B & H_f a (g b)}) *	 (forall b : B, Trunc (-1) {a : A & H_f a (g b)})	";
            responses[i]=data;
          

            i = 230;
            data = "1 subgoal (ID 533)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  ============================	  (forall a : A, Trunc (-1) {b : B & H_f a (g b)}) *	  (forall b : B, Trunc (-1) {a : A & H_f a (g b)}) ->	  (forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}) *	  (forall b : B', Trunc (-1) {a : A & H_f a (g' b)})	2 subgoals (ID 542)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  ============================	  forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}		subgoal 2 (ID 543) is:	 forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	";
            responses[i]=data;
          

            i = 231;
            data = "1 subgoal (ID 542)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  ============================	  forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	1 subgoal (ID 544)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  a : A	  ============================	  Trunc (-1) {b : B' & H_f a (g' b)}	";
            responses[i]=data;
          

            i = 232;
            data = "1 subgoal (ID 551)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  a : A	  ============================	  {b : B & H_f a (g b)} -> Trunc (-1) {b : B' & H_f a (g' b)}	";
            responses[i]=data;
          

            i = 233;
            data = "1 subgoal (ID 556)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  a : A	  b : B	  H3 : H_f a (g b)	  ============================	  Trunc (-1) {b0 : B' & H_f a (g' b0)}	";
            responses[i]=data;
          

            i = 234;
            data = "1 subgoal (ID 559)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  a : A	  b : B	  H3 : H_f a (g b)	  ============================	  hexists (fun b0 : B' => g b = g' b0) ->	  Trunc (-1) {b0 : B' & H_f a (g' b0)}	";
            responses[i]=data;
          

            i = 235;
            data = "1 subgoal (ID 561)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  a : A	  b : B	  H3 : H_f a (g b)	  ============================	  merely {b0 : B' & g b = g' b0} -> Trunc (-1) {b0 : B' & H_f a (g' b0)}	";
            responses[i]=data;
          

            i = 236;
            data = "1 subgoal (ID 569)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  a : A	  b : B	  H3 : H_f a (g b)	  ============================	  {b0 : B' & g b = g' b0} -> {b0 : B' & H_f a (g' b0)}	";
            responses[i]=data;
          

            i = 237;
            data = "1 subgoal (ID 574)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  a : A	  b : B	  H3 : H_f a (g b)	  b' : B'	  p : g b = g' b'	  ============================	  {b0 : B' & H_f a (g' b0)}	";
            responses[i]=data;
          

            i = 238;
            data = "1 subgoal (ID 576)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  a : A	  b : B	  H3 : H_f a (g b)	  b' : B'	  p : g b = g' b'	  ============================	  H_f a (g' b')	";
            responses[i]=data;
          

            i = 239;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	2 subgoals (ID 543)		subgoal 1 (ID 543) is:	 forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	subgoal 2 (ID 535) is:	 (forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}) *	 (forall b : B', Trunc (-1) {a : A & H_f a (g' b)}) ->	 (forall a : A, Trunc (-1) {b : B & H_f a (g b)}) *	 (forall b : B, Trunc (-1) {a : A & H_f a (g b)})	";
            responses[i]=data;
          

            i = 240;
            data = "1 subgoal (ID 543)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  ============================	  forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	1 subgoal (ID 581)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  b' : B'	  ============================	  Trunc (-1) {a : A & H_f a (g' b')}	";
            responses[i]=data;
          

            i = 241;
            data = "1 subgoal (ID 592)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  b' : B'	  ============================	  {a : B & g a = g' b'} -> Trunc (-1) {a : A & H_f a (g' b')}	";
            responses[i]=data;
          

            i = 242;
            data = "1 subgoal (ID 597)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  b' : B'	  b : B	  p : g b = g' b'	  ============================	  Trunc (-1) {a : A & H_f a (g' b')}	";
            responses[i]=data;
          

            i = 243;
            data = "1 subgoal (ID 598)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  b' : B'	  b : B	  p : g b = g' b'	  ============================	  Trunc (-1) {a : A & H_f a (g b)} -> Trunc (-1) {a : A & H_f a (g' b')}	";
            responses[i]=data;
          

            i = 244;
            data = "1 subgoal (ID 601)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  b' : B'	  b : B	  p : g b = g' b'	  ============================	  {a : A & H_f a (g b)} -> {a : A & H_f a (g' b')}	";
            responses[i]=data;
          

            i = 245;
            data = "1 subgoal (ID 606)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  b' : B'	  b : B	  p : g b = g' b'	  a : A	  H3 : H_f a (g b)	  ============================	  {a0 : A & H_f a0 (g' b')}	";
            responses[i]=data;
          

            i = 246;
            data = "1 subgoal (ID 608)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B & H_f a (g b)}	  H2 : forall b : B, Trunc (-1) {a : A & H_f a (g b)}	  b' : B'	  b : B	  p : g b = g' b'	  a : A	  H3 : H_f a (g b)	  ============================	  H_f a (g' b')	";
            responses[i]=data;
          

            i = 247;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 subgoal (ID 535)		subgoal 1 (ID 535) is:	 (forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}) *	 (forall b : B', Trunc (-1) {a : A & H_f a (g' b)}) ->	 (forall a : A, Trunc (-1) {b : B & H_f a (g b)}) *	 (forall b : B, Trunc (-1) {a : A & H_f a (g b)})	";
            responses[i]=data;
          

            i = 248;
            data = "1 subgoal (ID 535)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  ============================	  (forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}) *	  (forall b : B', Trunc (-1) {a : A & H_f a (g' b)}) ->	  (forall a : A, Trunc (-1) {b : B & H_f a (g b)}) *	  (forall b : B, Trunc (-1) {a : A & H_f a (g b)})	2 subgoals (ID 619)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  ============================	  forall a : A, Trunc (-1) {b : B & H_f a (g b)}		subgoal 2 (ID 620) is:	 forall b : B, Trunc (-1) {a : A & H_f a (g b)}	";
            responses[i]=data;
          

            i = 249;
            data = "1 subgoal (ID 619)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  ============================	  forall a : A, Trunc (-1) {b : B & H_f a (g b)}	1 subgoal (ID 621)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  a : A	  ============================	  Trunc (-1) {b : B & H_f a (g b)}	";
            responses[i]=data;
          

            i = 250;
            data = "1 subgoal (ID 628)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  a : A	  ============================	  {b : B' & H_f a (g' b)} -> Trunc (-1) {b : B & H_f a (g b)}	";
            responses[i]=data;
          

            i = 251;
            data = "1 subgoal (ID 633)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  a : A	  b' : B'	  H3 : H_f a (g' b')	  ============================	  Trunc (-1) {b : B & H_f a (g b)}	";
            responses[i]=data;
          

            i = 252;
            data = "1 subgoal (ID 636)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  a : A	  b' : B'	  H3 : H_f a (g' b')	  ============================	  hexists (fun a0 : B => g a0 = g' b') -> Trunc (-1) {b : B & H_f a (g b)}	";
            responses[i]=data;
          

            i = 253;
            data = "1 subgoal (ID 639)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  a : A	  b' : B'	  H3 : H_f a (g' b')	  ============================	  {a0 : B & g a0 = g' b'} -> {b : B & H_f a (g b)}	";
            responses[i]=data;
          

            i = 254;
            data = "1 subgoal (ID 644)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  a : A	  b' : B'	  H3 : H_f a (g' b')	  b : B	  p : g b = g' b'	  ============================	  {b0 : B & H_f a (g b0)}	";
            responses[i]=data;
          

            i = 255;
            data = "1 subgoal (ID 646)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  a : A	  b' : B'	  H3 : H_f a (g' b')	  b : B	  p : g b = g' b'	  ============================	  H_f a (g b)	";
            responses[i]=data;
          

            i = 256;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	1 subgoal (ID 620)		subgoal 1 (ID 620) is:	 forall b : B, Trunc (-1) {a : A & H_f a (g b)}	";
            responses[i]=data;
          

            i = 257;
            data = "1 subgoal (ID 620)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  ============================	  forall b : B, Trunc (-1) {a : A & H_f a (g b)}	1 subgoal (ID 654)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  b : B	  ============================	  Trunc (-1) {a : A & H_f a (g b)}	";
            responses[i]=data;
          

            i = 258;
            data = "1 subgoal (ID 665)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  b : B	  ============================	  {b0 : B' & g b = g' b0} -> Trunc (-1) {a : A & H_f a (g b)}	";
            responses[i]=data;
          

            i = 259;
            data = "1 subgoal (ID 670)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  b : B	  b' : B'	  p : g b = g' b'	  ============================	  Trunc (-1) {a : A & H_f a (g b)}	";
            responses[i]=data;
          

            i = 260;
            data = "1 subgoal (ID 671)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  b : B	  b' : B'	  p : g b = g' b'	  ============================	  Trunc (-1) {a : A & H_f a (g' b')} -> Trunc (-1) {a : A & H_f a (g b)}	";
            responses[i]=data;
          

            i = 261;
            data = "1 subgoal (ID 674)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  b : B	  b' : B'	  p : g b = g' b'	  ============================	  {a : A & H_f a (g' b')} -> {a : A & H_f a (g b)}	";
            responses[i]=data;
          

            i = 262;
            data = "1 subgoal (ID 679)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  b : B	  b' : B'	  p : g b = g' b'	  a : A	  H3 : H_f a (g' b')	  ============================	  {a0 : A & H_f a0 (g b)}	";
            responses[i]=data;
          

            i = 263;
            data = "1 subgoal (ID 681)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : A -> V -> hProp	  B : Type	  B' : Type	  g : B -> V	  g' : B' -> V	  eq_img : equal_img g g'	  H_g : B -> hProp	  H_g' : B' -> hProp	  H_img : equal_img H_g H_g'	  H1 : forall a : A, Trunc (-1) {b : B' & H_f a (g' b)}	  H2 : forall b : B', Trunc (-1) {a : A & H_f a (g' b)}	  b : B	  b' : B'	  p : g b = g' b'	  a : A	  H3 : H_f a (g' b')	  ============================	  H_f a (g b)	";
            responses[i]=data;
          

            i = 264;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 265;
            data = "";
            responses[i]=data;
          

            i = 266;
            data = "1 subgoal (ID 364)	  	  ua : Univalence	  ============================	  V -> V -> hProp	";
            responses[i]=data;
          

            i = 267;
            data = "";
            responses[i]=data;
          

            i = 268;
            data = "1 subgoal (ID 416)	  	  ua : Univalence	  ============================	  forall (A B : Type) (f : A -> V) (g : B -> V),	  equal_img f g ->	  forall (H_f : A -> V -> hProp) (H_g : B -> V -> hProp),	  equal_img H_f H_g -> bisim_aux A f H_f = bisim_aux B g H_g	";
            responses[i]=data;
          

            i = 269;
            data = "1 subgoal (ID 424)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  ============================	  bisim_aux A f H_f = bisim_aux B g H_g	";
            responses[i]=data;
          

            i = 270;
            data = "1 subgoal (ID 431)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  ============================	  bisim_aux A f H_f == bisim_aux B g H_g	";
            responses[i]=data;
          

            i = 271;
            data = "1 subgoal (ID 471)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  ============================	  forall (A0 : Type) (f0 : A0 -> V),	  (forall a : A0, bisim_aux A f H_f (f0 a) = bisim_aux B g H_g (f0 a)) ->	  bisim_aux A f H_f (set f0) = bisim_aux B g H_g (set f0)	";
            responses[i]=data;
          

            i = 272;
            data = "1 subgoal (ID 477)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  ============================	  bisim_aux A f H_f (set h) = bisim_aux B g H_g (set h)	";
            responses[i]=data;
          

            i = 273;
            data = "2 subgoals (ID 486)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  ============================	  (forall a : A, Trunc (-1) {b : C & H_f a (h b)}) *	  (forall b : C, Trunc (-1) {a : A & H_f a (h b)}) ->	  (forall a : B, Trunc (-1) {b : C & H_g a (h b)}) *	  (forall b : C, Trunc (-1) {a : B & H_g a (h b)})		subgoal 2 (ID 490) is:	 (forall a : B, Trunc (-1) {b : C & H_g a (h b)}) *	 (forall b : C, Trunc (-1) {a : B & H_g a (h b)}) ->	 (forall a : A, Trunc (-1) {b : C & H_f a (h b)}) *	 (forall b : C, Trunc (-1) {a : A & H_f a (h b)})	";
            responses[i]=data;
          

            i = 274;
            data = "1 subgoal (ID 486)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  ============================	  (forall a : A, Trunc (-1) {b : C & H_f a (h b)}) *	  (forall b : C, Trunc (-1) {a : A & H_f a (h b)}) ->	  (forall a : B, Trunc (-1) {b : C & H_g a (h b)}) *	  (forall b : C, Trunc (-1) {a : B & H_g a (h b)})	2 subgoals (ID 497)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  ============================	  forall a : B, Trunc (-1) {b : C & H_g a (h b)}		subgoal 2 (ID 498) is:	 forall b : C, Trunc (-1) {a : B & H_g a (h b)}	";
            responses[i]=data;
          

            i = 275;
            data = "1 subgoal (ID 497)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  ============================	  forall a : B, Trunc (-1) {b : C & H_g a (h b)}	1 subgoal (ID 499)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  b : B	  ============================	  Trunc (-1) {b0 : C & H_g b (h b0)}	";
            responses[i]=data;
          

            i = 276;
            data = "1 subgoal (ID 510)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  b : B	  ============================	  {a : A & H_f a = H_g b} -> Trunc (-1) {b0 : C & H_g b (h b0)}	";
            responses[i]=data;
          

            i = 277;
            data = "1 subgoal (ID 515)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  b : B	  a : A	  p : H_f a = H_g b	  ============================	  Trunc (-1) {b0 : C & H_g b (h b0)}	";
            responses[i]=data;
          

            i = 278;
            data = "1 subgoal (ID 516)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  b : B	  a : A	  p : H_f a = H_g b	  ============================	  Trunc (-1) {b0 : C & H_f a (h b0)} -> Trunc (-1) {b0 : C & H_g b (h b0)}	";
            responses[i]=data;
          

            i = 279;
            data = "1 subgoal (ID 519)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  b : B	  a : A	  p : H_f a = H_g b	  ============================	  {b0 : C & H_f a (h b0)} -> {b0 : C & H_g b (h b0)}	";
            responses[i]=data;
          

            i = 280;
            data = "1 subgoal (ID 524)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  b : B	  a : A	  p : H_f a = H_g b	  c : C	  H3 : H_f a (h c)	  ============================	  {b0 : C & H_g b (h b0)}	";
            responses[i]=data;
          

            i = 281;
            data = "1 subgoal (ID 526)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  b : B	  a : A	  p : H_f a = H_g b	  c : C	  H3 : H_f a (h c)	  ============================	  H_g b (h c)	";
            responses[i]=data;
          

            i = 282;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 subgoals (ID 498)		subgoal 1 (ID 498) is:	 forall b : C, Trunc (-1) {a : B & H_g a (h b)}	subgoal 2 (ID 490) is:	 (forall a : B, Trunc (-1) {b : C & H_g a (h b)}) *	 (forall b : C, Trunc (-1) {a : B & H_g a (h b)}) ->	 (forall a : A, Trunc (-1) {b : C & H_f a (h b)}) *	 (forall b : C, Trunc (-1) {a : A & H_f a (h b)})	";
            responses[i]=data;
          

            i = 283;
            data = "1 subgoal (ID 498)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  ============================	  forall b : C, Trunc (-1) {a : B & H_g a (h b)}	1 subgoal (ID 536)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  c : C	  ============================	  Trunc (-1) {a : B & H_g a (h c)}	";
            responses[i]=data;
          

            i = 284;
            data = "1 subgoal (ID 543)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  c : C	  ============================	  {a : A & H_f a (h c)} -> Trunc (-1) {a : B & H_g a (h c)}	";
            responses[i]=data;
          

            i = 285;
            data = "1 subgoal (ID 548)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  c : C	  a : A	  H3 : H_f a (h c)	  ============================	  Trunc (-1) {a0 : B & H_g a0 (h c)}	";
            responses[i]=data;
          

            i = 286;
            data = "1 subgoal (ID 551)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  c : C	  a : A	  H3 : H_f a (h c)	  ============================	  hexists (fun b : B => H_f a = H_g b) -> Trunc (-1) {a0 : B & H_g a0 (h c)}	";
            responses[i]=data;
          

            i = 287;
            data = "1 subgoal (ID 554)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  c : C	  a : A	  H3 : H_f a (h c)	  ============================	  {b : B & H_f a = H_g b} -> {a0 : B & H_g a0 (h c)}	";
            responses[i]=data;
          

            i = 288;
            data = "1 subgoal (ID 559)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  c : C	  a : A	  H3 : H_f a (h c)	  b : B	  p : H_f a = H_g b	  ============================	  {a0 : B & H_g a0 (h c)}	";
            responses[i]=data;
          

            i = 289;
            data = "1 subgoal (ID 561)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : A, Trunc (-1) {b : C & H_f a (h b)}	  H2 : forall b : C, Trunc (-1) {a : A & H_f a (h b)}	  c : C	  a : A	  H3 : H_f a (h c)	  b : B	  p : H_f a = H_g b	  ============================	  H_g b (h c)	";
            responses[i]=data;
          

            i = 290;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 490)		subgoal 1 (ID 490) is:	 (forall a : B, Trunc (-1) {b : C & H_g a (h b)}) *	 (forall b : C, Trunc (-1) {a : B & H_g a (h b)}) ->	 (forall a : A, Trunc (-1) {b : C & H_f a (h b)}) *	 (forall b : C, Trunc (-1) {a : A & H_f a (h b)})	";
            responses[i]=data;
          

            i = 291;
            data = "1 subgoal (ID 490)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  ============================	  (forall a : B, Trunc (-1) {b : C & H_g a (h b)}) *	  (forall b : C, Trunc (-1) {a : B & H_g a (h b)}) ->	  (forall a : A, Trunc (-1) {b : C & H_f a (h b)}) *	  (forall b : C, Trunc (-1) {a : A & H_f a (h b)})	2 subgoals (ID 577)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  ============================	  forall a : A, Trunc (-1) {b : C & H_f a (h b)}		subgoal 2 (ID 578) is:	 forall b : C, Trunc (-1) {a : A & H_f a (h b)}	";
            responses[i]=data;
          

            i = 292;
            data = "1 subgoal (ID 577)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  ============================	  forall a : A, Trunc (-1) {b : C & H_f a (h b)}	1 subgoal (ID 579)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  a : A	  ============================	  Trunc (-1) {b : C & H_f a (h b)}	";
            responses[i]=data;
          

            i = 293;
            data = "1 subgoal (ID 590)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  a : A	  ============================	  {b : B & H_f a = H_g b} -> Trunc (-1) {b : C & H_f a (h b)}	";
            responses[i]=data;
          

            i = 294;
            data = "1 subgoal (ID 595)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  a : A	  b : B	  p : H_f a = H_g b	  ============================	  Trunc (-1) {b0 : C & H_f a (h b0)}	";
            responses[i]=data;
          

            i = 295;
            data = "1 subgoal (ID 596)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  a : A	  b : B	  p : H_f a = H_g b	  ============================	  Trunc (-1) {b0 : C & H_g b (h b0)} -> Trunc (-1) {b0 : C & H_f a (h b0)}	";
            responses[i]=data;
          

            i = 296;
            data = "1 subgoal (ID 599)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  a : A	  b : B	  p : H_f a = H_g b	  ============================	  {b0 : C & H_g b (h b0)} -> {b0 : C & H_f a (h b0)}	";
            responses[i]=data;
          

            i = 297;
            data = "1 subgoal (ID 604)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  a : A	  b : B	  p : H_f a = H_g b	  c : C	  H3 : H_g b (h c)	  ============================	  {b0 : C & H_f a (h b0)}	";
            responses[i]=data;
          

            i = 298;
            data = "1 subgoal (ID 606)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  a : A	  b : B	  p : H_f a = H_g b	  c : C	  H3 : H_g b (h c)	  ============================	  H_f a (h c)	";
            responses[i]=data;
          

            i = 299;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 subgoal (ID 578)		subgoal 1 (ID 578) is:	 forall b : C, Trunc (-1) {a : A & H_f a (h b)}	";
            responses[i]=data;
          

            i = 300;
            data = "1 subgoal (ID 578)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  ============================	  forall b : C, Trunc (-1) {a : A & H_f a (h b)}	1 subgoal (ID 619)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  c : C	  ============================	  Trunc (-1) {a : A & H_f a (h c)}	";
            responses[i]=data;
          

            i = 301;
            data = "1 subgoal (ID 626)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  c : C	  ============================	  {a : B & H_g a (h c)} -> Trunc (-1) {a : A & H_f a (h c)}	";
            responses[i]=data;
          

            i = 302;
            data = "1 subgoal (ID 631)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  c : C	  b : B	  H3 : H_g b (h c)	  ============================	  Trunc (-1) {a : A & H_f a (h c)}	";
            responses[i]=data;
          

            i = 303;
            data = "1 subgoal (ID 634)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  c : C	  b : B	  H3 : H_g b (h c)	  ============================	  hexists (fun a : A => H_f a = H_g b) -> Trunc (-1) {a : A & H_f a (h c)}	";
            responses[i]=data;
          

            i = 304;
            data = "1 subgoal (ID 637)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  c : C	  b : B	  H3 : H_g b (h c)	  ============================	  {a : A & H_f a = H_g b} -> {a : A & H_f a (h c)}	";
            responses[i]=data;
          

            i = 305;
            data = "1 subgoal (ID 642)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  c : C	  b : B	  H3 : H_g b (h c)	  a : A	  p : H_f a = H_g b	  ============================	  {a0 : A & H_f a0 (h c)}	";
            responses[i]=data;
          

            i = 306;
            data = "1 subgoal (ID 644)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  H_f : A -> V -> hProp	  H_g : B -> V -> hProp	  H_img : equal_img H_f H_g	  C : Type	  h : C -> V	  H1 : forall a : B, Trunc (-1) {b : C & H_g a (h b)}	  H2 : forall b : C, Trunc (-1) {a : B & H_g a (h b)}	  c : C	  b : B	  H3 : H_g b (h c)	  a : A	  p : H_f a = H_g b	  ============================	  H_f a (h c)	";
            responses[i]=data;
          

            i = 307;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 308;
            data = "";
            responses[i]=data;
          

            i = 309;
            data = "";
            responses[i]=data;
          

            i = 310;
            data = "1 subgoal (ID 366)	  	  ua : Univalence	  ============================	  Reflexive (fun x x0 : V => x ~~ x0)	";
            responses[i]=data;
          

            i = 311;
            data = "";
            responses[i]=data;
          

            i = 312;
            data = "1 subgoal (ID 385)	  	  ua : Univalence	  ============================	  forall (A : Type) (f : A -> V),	  (forall a : A, f a ~~ f a) -> set f ~~ set f	";
            responses[i]=data;
          

            i = 313;
            data = "1 subgoal (ID 396)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : forall a : A, f a ~~ f a	  ============================	  (forall a : A,	   Trunc (-1)	     {b : A &	     V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	       (fun (A0 B : Type) (R : A0 -> B -> hProp) (bitot_R : bitotal R)	          (h : SPushout (fun (x : A0) (x0 : B) => R x x0) -> V)	          (H_h : SPushout (fun (x : A0) (x0 : B) => R x x0) -> V -> hProp) =>	        transport_const (setext R bitot_R h)	          (bisim_aux A0	             (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	             (fun x : A0 =>	              H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))) @	        path_forall	          (bisim_aux A0	             (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	             (fun x : A0 =>	              H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)))	          (bisim_aux B	             (fun x : B => h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	             (fun x : B => H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)))	          (V_ind_hprop	             (fun v : V =>	              bisim_aux A0	                (fun x : A0 =>	                 h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                (fun x : A0 =>	                 H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v =	              bisim_aux B	                (fun x : B =>	                 h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                (fun x : B =>	                 H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v)	             (fun (C : Type) (h0 : C -> V)	                (_ : forall a0 : C,	                     bisim_aux A0	                       (fun x : A0 =>	                        h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                       (fun x : A0 =>	                        H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                       (h0 a0) =	                     bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                       (h0 a0)) =>	              path_iff_hprop	                (fun	                   X : (forall a0 : A0,	                        Trunc (-1)	                          {b0 : C &	                          H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                            (h0 b0)}) *	                       (forall b0 : C,	                        Trunc (-1)	                          {a0 : A0 &	                          H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                            (h0 b0)}) =>	                 (fun b0 : B =>	                  Trunc_rec	                    (fun	                       X0 : {a0 : A0 &	                            H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                            H_h (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                     =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b1 : C &	                               H_h	                                 (spushl (fun (x : A0) (x0 : B) => R x x0)	                                    X0.1) (h0 b1)} =>	                        (X1.1;	                        transport trunctype_type (ap10 X0.2 (h0 X1.1)) X1.2))	                       (fst X X0.1))	                    (Trunc_functor (-1)	                       (fun X0 : {a0 : A0 & R a0 b0} =>	                        (X0.1;	                        ap H_h	                          (spglue (fun (x : A0) (x0 : B) => R x x0) X0.2)))	                       (snd bitot_R b0)),	                 fun c : C =>	                 Trunc_rec	                   (fun	                      X0 : {a0 : A0 &	                           H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                             (h0 c)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b0 : B &	                              H_h	                                (spushl (fun (x : A0) (x0 : B) => R x x0)	                                   X0.1) =	                              H_h	                                (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                       =>	                       (X1.1;	                       transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                      (Trunc_functor (-1)	                         (fun X1 : {b0 : B & R X0.1 b0} =>	                          (X1.1;	                          ap H_h	                            (spglue (fun (x : A0) (x0 : B) => R x x0) X1.2)))	                         (fst bitot_R X0.1))) (snd X c)))	                (fun	                   X : (forall a0 : B,	                        Trunc (-1)	                          {b0 : C &	                          H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                            (h0 b0)}) *	                       (forall b0 : C,	                        Trunc (-1)	                          {a0 : B &	                          H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                            (h0 b0)}) =>	                 (fun a0 : A0 =>	                  Trunc_rec	                    (fun	                       X0 : {b0 : B &	                            H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                            H_h (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                     =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b0 : C &	                               H_h	                                 (spushr (fun (x : A0) (x0 : B) => R x x0)	                                    X0.1) (h0 b0)} =>	                        (X1.1;	                        transport trunctype_type (ap10 (X0.2)^ (h0 X1.1))	                          X1.2)) (fst X X0.1))	                    (Trunc_functor (-1)	                       (fun X0 : {b0 : B & R a0 b0} =>	                        (X0.1;	                        ap H_h	                          (spglue (fun (x : A0) (x0 : B) => R x x0) X0.2)))	                       (fst bitot_R a0)),	                 fun c : C =>	                 Trunc_rec	                   (fun	                      X0 : {a0 : B &	                           H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                             (h0 c)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {a0 : A0 &	                              H_h	                                (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                              H_h	                                (spushr (fun (x : A0) (x0 : B) => R x x0)	                                   X0.1)} =>	                       (X1.1;	                       transport trunctype_type (ap10 (X1.2)^ (h0 c)) X0.2))	                      (Trunc_functor (-1)	                         (fun X1 : {a0 : A0 & R a0 X0.1} =>	                          (X1.1;	                          ap H_h	                            (spglue (fun (x : A0) (x0 : B) => R x x0) X1.2)))	                         (snd bitot_R X0.1))) (snd X c))))	             (fun v : V =>	              istrunc_paths hProp (-1)	                (bisim_aux A0	                   (fun x : A0 =>	                    h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                   (fun x : A0 =>	                    H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v)	                (bisim_aux B	                   (fun x : B =>	                    h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                   (fun x : B =>	                    H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v))))	       (f a) (f b)}) *	  (forall b : A,	   Trunc (-1)	     {a : A &	     V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	       (fun (A0 B : Type) (R : A0 -> B -> hProp) (bitot_R : bitotal R)	          (h : SPushout (fun (x : A0) (x0 : B) => R x x0) -> V)	          (H_h : SPushout (fun (x : A0) (x0 : B) => R x x0) -> V -> hProp) =>	        transport_const (setext R bitot_R h)	          (bisim_aux A0	             (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	             (fun x : A0 =>	              H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))) @	        path_forall	          (bisim_aux A0	             (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	             (fun x : A0 =>	              H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)))	          (bisim_aux B	             (fun x : B => h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	             (fun x : B => H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)))	          (V_ind_hprop	             (fun v : V =>	              bisim_aux A0	                (fun x : A0 =>	                 h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                (fun x : A0 =>	                 H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v =	              bisim_aux B	                (fun x : B =>	                 h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                (fun x : B =>	                 H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v)	             (fun (C : Type) (h0 : C -> V)	                (_ : forall a0 : C,	                     bisim_aux A0	                       (fun x : A0 =>	                        h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                       (fun x : A0 =>	                        H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                       (h0 a0) =	                     bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                       (h0 a0)) =>	              path_iff_hprop	                (fun	                   X : (forall a0 : A0,	                        Trunc (-1)	                          {b0 : C &	                          H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                            (h0 b0)}) *	                       (forall b0 : C,	                        Trunc (-1)	                          {a0 : A0 &	                          H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                            (h0 b0)}) =>	                 (fun b0 : B =>	                  Trunc_rec	                    (fun	                       X0 : {a0 : A0 &	                            H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                            H_h (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                     =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b1 : C &	                               H_h	                                 (spushl (fun (x : A0) (x0 : B) => R x x0)	                                    X0.1) (h0 b1)} =>	                        (X1.1;	                        transport trunctype_type (ap10 X0.2 (h0 X1.1)) X1.2))	                       (fst X X0.1))	                    (Trunc_functor (-1)	                       (fun X0 : {a0 : A0 & R a0 b0} =>	                        (X0.1;	                        ap H_h	                          (spglue (fun (x : A0) (x0 : B) => R x x0) X0.2)))	                       (snd bitot_R b0)),	                 fun c : C =>	                 Trunc_rec	                   (fun	                      X0 : {a0 : A0 &	                           H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                             (h0 c)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b0 : B &	                              H_h	                                (spushl (fun (x : A0) (x0 : B) => R x x0)	                                   X0.1) =	                              H_h	                                (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                       =>	                       (X1.1;	                       transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                      (Trunc_functor (-1)	                         (fun X1 : {b0 : B & R X0.1 b0} =>	                          (X1.1;	                          ap H_h	                            (spglue (fun (x : A0) (x0 : B) => R x x0) X1.2)))	                         (fst bitot_R X0.1))) (snd X c)))	                (fun	                   X : (forall a0 : B,	                        Trunc (-1)	                          {b0 : C &	                          H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                            (h0 b0)}) *	                       (forall b0 : C,	                        Trunc (-1)	                          {a0 : B &	                          H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                            (h0 b0)}) =>	                 (fun a0 : A0 =>	                  Trunc_rec	                    (fun	                       X0 : {b0 : B &	                            H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                            H_h (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                     =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b0 : C &	                               H_h	                                 (spushr (fun (x : A0) (x0 : B) => R x x0)	                                    X0.1) (h0 b0)} =>	                        (X1.1;	                        transport trunctype_type (ap10 (X0.2)^ (h0 X1.1))	                          X1.2)) (fst X X0.1))	                    (Trunc_functor (-1)	                       (fun X0 : {b0 : B & R a0 b0} =>	                        (X0.1;	                        ap H_h	                          (spglue (fun (x : A0) (x0 : B) => R x x0) X0.2)))	                       (fst bitot_R a0)),	                 fun c : C =>	                 Trunc_rec	                   (fun	                      X0 : {a0 : B &	                           H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                             (h0 c)} =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {a0 : A0 &	                              H_h	                                (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                              H_h	                                (spushr (fun (x : A0) (x0 : B) => R x x0)	                                   X0.1)} =>	                       (X1.1;	                       transport trunctype_type (ap10 (X1.2)^ (h0 c)) X0.2))	                      (Trunc_functor (-1)	                         (fun X1 : {a0 : A0 & R a0 X0.1} =>	                          (X1.1;	                          ap H_h	                            (spglue (fun (x : A0) (x0 : B) => R x x0) X1.2)))	                         (snd bitot_R X0.1))) (snd X c))))	             (fun v : V =>	              istrunc_paths hProp (-1)	                (bisim_aux A0	                   (fun x : A0 =>	                    h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                   (fun x : A0 =>	                    H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v)	                (bisim_aux B	                   (fun x : B =>	                    h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                   (fun x : B =>	                    H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v))))	       (f a) (f b)})	";
            responses[i]=data;
          

            i = 314;
            data = "2 subgoals (ID 398)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : forall a : A, f a ~~ f a	  ============================	  forall a : A,	  Trunc (-1)	    {b : A &	    V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	      (fun (A0 B : Type) (R : A0 -> B -> hProp) (bitot_R : bitotal R)	         (h : SPushout (fun (x : A0) (x0 : B) => R x x0) -> V)	         (H_h : SPushout (fun (x : A0) (x0 : B) => R x x0) -> V -> hProp) =>	       transport_const (setext R bitot_R h)	         (bisim_aux A0	            (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	            (fun x : A0 => H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))) @	       path_forall	         (bisim_aux A0	            (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	            (fun x : A0 => H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)))	         (bisim_aux B	            (fun x : B => h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	            (fun x : B => H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)))	         (V_ind_hprop	            (fun v : V =>	             bisim_aux A0	               (fun x : A0 =>	                h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	               (fun x : A0 =>	                H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v =	             bisim_aux B	               (fun x : B => h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	               (fun x : B =>	                H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v)	            (fun (C : Type) (h0 : C -> V)	               (_ : forall a0 : C,	                    bisim_aux A0	                      (fun x : A0 =>	                       h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                      (fun x : A0 =>	                       H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                      (h0 a0) =	                    bisim_aux B	                      (fun x : B =>	                       h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                      (fun x : B =>	                       H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                      (h0 a0)) =>	             path_iff_hprop	               (fun	                  X : (forall a0 : A0,	                       Trunc (-1)	                         {b0 : C &	                         H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                           (h0 b0)}) *	                      (forall b0 : C,	                       Trunc (-1)	                         {a0 : A0 &	                         H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                           (h0 b0)}) =>	                (fun b0 : B =>	                 Trunc_rec	                   (fun	                      X0 : {a0 : A0 &	                           H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                           H_h (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                    =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b1 : C &	                              H_h	                                (spushl (fun (x : A0) (x0 : B) => R x x0)	                                   X0.1) (h0 b1)} =>	                       (X1.1;	                       transport trunctype_type (ap10 X0.2 (h0 X1.1)) X1.2))	                      (fst X X0.1))	                   (Trunc_functor (-1)	                      (fun X0 : {a0 : A0 & R a0 b0} =>	                       (X0.1;	                       ap H_h (spglue (fun (x : A0) (x0 : B) => R x x0) X0.2)))	                      (snd bitot_R b0)),	                fun c : C =>	                Trunc_rec	                  (fun	                     X0 : {a0 : A0 &	                          H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                            (h0 c)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b0 : B &	                             H_h	                               (spushl (fun (x : A0) (x0 : B) => R x x0) X0.1) =	                             H_h	                               (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                      =>	                      (X1.1;	                      transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                     (Trunc_functor (-1)	                        (fun X1 : {b0 : B & R X0.1 b0} =>	                         (X1.1;	                         ap H_h	                           (spglue (fun (x : A0) (x0 : B) => R x x0) X1.2)))	                        (fst bitot_R X0.1))) (snd X c)))	               (fun	                  X : (forall a0 : B,	                       Trunc (-1)	                         {b0 : C &	                         H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                           (h0 b0)}) *	                      (forall b0 : C,	                       Trunc (-1)	                         {a0 : B &	                         H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                           (h0 b0)}) =>	                (fun a0 : A0 =>	                 Trunc_rec	                   (fun	                      X0 : {b0 : B &	                           H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                           H_h (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                    =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b0 : C &	                              H_h	                                (spushr (fun (x : A0) (x0 : B) => R x x0)	                                   X0.1) (h0 b0)} =>	                       (X1.1;	                       transport trunctype_type (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                      (fst X X0.1))	                   (Trunc_functor (-1)	                      (fun X0 : {b0 : B & R a0 b0} =>	                       (X0.1;	                       ap H_h (spglue (fun (x : A0) (x0 : B) => R x x0) X0.2)))	                      (fst bitot_R a0)),	                fun c : C =>	                Trunc_rec	                  (fun	                     X0 : {a0 : B &	                          H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                            (h0 c)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {a0 : A0 &	                             H_h	                               (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                             H_h	                               (spushr (fun (x : A0) (x0 : B) => R x x0) X0.1)}	                      =>	                      (X1.1;	                      transport trunctype_type (ap10 (X1.2)^ (h0 c)) X0.2))	                     (Trunc_functor (-1)	                        (fun X1 : {a0 : A0 & R a0 X0.1} =>	                         (X1.1;	                         ap H_h	                           (spglue (fun (x : A0) (x0 : B) => R x x0) X1.2)))	                        (snd bitot_R X0.1))) (snd X c))))	            (fun v : V =>	             istrunc_paths hProp (-1)	               (bisim_aux A0	                  (fun x : A0 =>	                   h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                  (fun x : A0 =>	                   H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v)	               (bisim_aux B	                  (fun x : B =>	                   h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                  (fun x : B =>	                   H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v))))	      (f a) (f b)}		subgoal 2 (ID 399) is:	 forall b : A,	 Trunc (-1)	   {a : A &	   V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	     (fun (A0 B : Type) (R : A0 -> B -> hProp) (bitot_R : bitotal R)	        (h : SPushout (fun (x : A0) (x0 : B) => R x x0) -> V)	        (H_h : SPushout (fun (x : A0) (x0 : B) => R x x0) -> V -> hProp) =>	      transport_const (setext R bitot_R h)	        (bisim_aux A0	           (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	           (fun x : A0 => H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))) @	      path_forall	        (bisim_aux A0	           (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	           (fun x : A0 => H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)))	        (bisim_aux B	           (fun x : B => h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	           (fun x : B => H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)))	        (V_ind_hprop	           (fun v : V =>	            bisim_aux A0	              (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	              (fun x : A0 =>	               H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v =	            bisim_aux B	              (fun x : B => h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	              (fun x : B =>	               H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v)	           (fun (C : Type) (h0 : C -> V)	              (_ : forall a0 : C,	                   bisim_aux A0	                     (fun x : A0 =>	                      h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                     (fun x : A0 =>	                      H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                     (h0 a0) =	                   bisim_aux B	                     (fun x : B =>	                      h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                     (fun x : B =>	                      H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                     (h0 a0)) =>	            path_iff_hprop	              (fun	                 X : (forall a0 : A0,	                      Trunc (-1)	                        {b0 : C &	                        H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                          (h0 b0)}) *	                     (forall b0 : C,	                      Trunc (-1)	                        {a0 : A0 &	                        H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                          (h0 b0)}) =>	               (fun b0 : B =>	                Trunc_rec	                  (fun	                     X0 : {a0 : A0 &	                          H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                          H_h (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                   =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b1 : C &	                             H_h	                               (spushl (fun (x : A0) (x0 : B) => R x x0) X0.1)	                               (h0 b1)} =>	                      (X1.1;	                      transport trunctype_type (ap10 X0.2 (h0 X1.1)) X1.2))	                     (fst X X0.1))	                  (Trunc_functor (-1)	                     (fun X0 : {a0 : A0 & R a0 b0} =>	                      (X0.1;	                      ap H_h (spglue (fun (x : A0) (x0 : B) => R x x0) X0.2)))	                     (snd bitot_R b0)),	               fun c : C =>	               Trunc_rec	                 (fun	                    X0 : {a0 : A0 &	                         H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                           (h0 c)} =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {b0 : B &	                            H_h	                              (spushl (fun (x : A0) (x0 : B) => R x x0) X0.1) =	                            H_h (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                     =>	                     (X1.1; transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                    (Trunc_functor (-1)	                       (fun X1 : {b0 : B & R X0.1 b0} =>	                        (X1.1;	                        ap H_h	                          (spglue (fun (x : A0) (x0 : B) => R x x0) X1.2)))	                       (fst bitot_R X0.1))) (snd X c)))	              (fun	                 X : (forall a0 : B,	                      Trunc (-1)	                        {b0 : C &	                        H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                          (h0 b0)}) *	                     (forall b0 : C,	                      Trunc (-1)	                        {a0 : B &	                        H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                          (h0 b0)}) =>	               (fun a0 : A0 =>	                Trunc_rec	                  (fun	                     X0 : {b0 : B &	                          H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                          H_h (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                   =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b0 : C &	                             H_h	                               (spushr (fun (x : A0) (x0 : B) => R x x0) X0.1)	                               (h0 b0)} =>	                      (X1.1;	                      transport trunctype_type (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                     (fst X X0.1))	                  (Trunc_functor (-1)	                     (fun X0 : {b0 : B & R a0 b0} =>	                      (X0.1;	                      ap H_h (spglue (fun (x : A0) (x0 : B) => R x x0) X0.2)))	                     (fst bitot_R a0)),	               fun c : C =>	               Trunc_rec	                 (fun	                    X0 : {a0 : B &	                         H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                           (h0 c)} =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {a0 : A0 &	                            H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                            H_h	                              (spushr (fun (x : A0) (x0 : B) => R x x0) X0.1)}	                     =>	                     (X1.1;	                     transport trunctype_type (ap10 (X1.2)^ (h0 c)) X0.2))	                    (Trunc_functor (-1)	                       (fun X1 : {a0 : A0 & R a0 X0.1} =>	                        (X1.1;	                        ap H_h	                          (spglue (fun (x : A0) (x0 : B) => R x x0) X1.2)))	                       (snd bitot_R X0.1))) (snd X c))))	           (fun v : V =>	            istrunc_paths hProp (-1)	              (bisim_aux A0	                 (fun x : A0 =>	                  h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                 (fun x : A0 =>	                  H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v)	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v))))	     (f a) (f b)}	";
            responses[i]=data;
          

            i = 315;
            data = "1 subgoal (ID 398)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : forall a : A, f a ~~ f a	  ============================	  forall a : A,	  Trunc (-1)	    {b : A &	    V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	      (fun (A0 B : Type) (R : A0 -> B -> hProp) (bitot_R : bitotal R)	         (h : SPushout (fun (x : A0) (x0 : B) => R x x0) -> V)	         (H_h : SPushout (fun (x : A0) (x0 : B) => R x x0) -> V -> hProp) =>	       transport_const (setext R bitot_R h)	         (bisim_aux A0	            (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	            (fun x : A0 => H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))) @	       path_forall	         (bisim_aux A0	            (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	            (fun x : A0 => H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)))	         (bisim_aux B	            (fun x : B => h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	            (fun x : B => H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)))	         (V_ind_hprop	            (fun v : V =>	             bisim_aux A0	               (fun x : A0 =>	                h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	               (fun x : A0 =>	                H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v =	             bisim_aux B	               (fun x : B => h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	               (fun x : B =>	                H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v)	            (fun (C : Type) (h0 : C -> V)	               (_ : forall a0 : C,	                    bisim_aux A0	                      (fun x : A0 =>	                       h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                      (fun x : A0 =>	                       H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                      (h0 a0) =	                    bisim_aux B	                      (fun x : B =>	                       h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                      (fun x : B =>	                       H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                      (h0 a0)) =>	             path_iff_hprop	               (fun	                  X : (forall a0 : A0,	                       Trunc (-1)	                         {b0 : C &	                         H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                           (h0 b0)}) *	                      (forall b0 : C,	                       Trunc (-1)	                         {a0 : A0 &	                         H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                           (h0 b0)}) =>	                (fun b0 : B =>	                 Trunc_rec	                   (fun	                      X0 : {a0 : A0 &	                           H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                           H_h (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                    =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b1 : C &	                              H_h	                                (spushl (fun (x : A0) (x0 : B) => R x x0)	                                   X0.1) (h0 b1)} =>	                       (X1.1;	                       transport trunctype_type (ap10 X0.2 (h0 X1.1)) X1.2))	                      (fst X X0.1))	                   (Trunc_functor (-1)	                      (fun X0 : {a0 : A0 & R a0 b0} =>	                       (X0.1;	                       ap H_h (spglue (fun (x : A0) (x0 : B) => R x x0) X0.2)))	                      (snd bitot_R b0)),	                fun c : C =>	                Trunc_rec	                  (fun	                     X0 : {a0 : A0 &	                          H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                            (h0 c)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b0 : B &	                             H_h	                               (spushl (fun (x : A0) (x0 : B) => R x x0) X0.1) =	                             H_h	                               (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                      =>	                      (X1.1;	                      transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                     (Trunc_functor (-1)	                        (fun X1 : {b0 : B & R X0.1 b0} =>	                         (X1.1;	                         ap H_h	                           (spglue (fun (x : A0) (x0 : B) => R x x0) X1.2)))	                        (fst bitot_R X0.1))) (snd X c)))	               (fun	                  X : (forall a0 : B,	                       Trunc (-1)	                         {b0 : C &	                         H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                           (h0 b0)}) *	                      (forall b0 : C,	                       Trunc (-1)	                         {a0 : B &	                         H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                           (h0 b0)}) =>	                (fun a0 : A0 =>	                 Trunc_rec	                   (fun	                      X0 : {b0 : B &	                           H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                           H_h (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                    =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b0 : C &	                              H_h	                                (spushr (fun (x : A0) (x0 : B) => R x x0)	                                   X0.1) (h0 b0)} =>	                       (X1.1;	                       transport trunctype_type (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                      (fst X X0.1))	                   (Trunc_functor (-1)	                      (fun X0 : {b0 : B & R a0 b0} =>	                       (X0.1;	                       ap H_h (spglue (fun (x : A0) (x0 : B) => R x x0) X0.2)))	                      (fst bitot_R a0)),	                fun c : C =>	                Trunc_rec	                  (fun	                     X0 : {a0 : B &	                          H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                            (h0 c)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {a0 : A0 &	                             H_h	                               (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                             H_h	                               (spushr (fun (x : A0) (x0 : B) => R x x0) X0.1)}	                      =>	                      (X1.1;	                      transport trunctype_type (ap10 (X1.2)^ (h0 c)) X0.2))	                     (Trunc_functor (-1)	                        (fun X1 : {a0 : A0 & R a0 X0.1} =>	                         (X1.1;	                         ap H_h	                           (spglue (fun (x : A0) (x0 : B) => R x x0) X1.2)))	                        (snd bitot_R X0.1))) (snd X c))))	            (fun v : V =>	             istrunc_paths hProp (-1)	               (bisim_aux A0	                  (fun x : A0 =>	                   h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                  (fun x : A0 =>	                   H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v)	               (bisim_aux B	                  (fun x : B =>	                   h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                  (fun x : B =>	                   H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v))))	      (f a) (f b)}	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	";
            responses[i]=data;
          

            i = 316;
            data = "1 subgoal (ID 399)		subgoal 1 (ID 399) is:	 forall b : A,	 Trunc (-1)	   {a : A &	   V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	     (fun (A0 B : Type) (R : A0 -> B -> hProp) (bitot_R : bitotal R)	        (h : SPushout (fun (x : A0) (x0 : B) => R x x0) -> V)	        (H_h : SPushout (fun (x : A0) (x0 : B) => R x x0) -> V -> hProp) =>	      transport_const (setext R bitot_R h)	        (bisim_aux A0	           (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	           (fun x : A0 => H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))) @	      path_forall	        (bisim_aux A0	           (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	           (fun x : A0 => H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)))	        (bisim_aux B	           (fun x : B => h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	           (fun x : B => H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)))	        (V_ind_hprop	           (fun v : V =>	            bisim_aux A0	              (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	              (fun x : A0 =>	               H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v =	            bisim_aux B	              (fun x : B => h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	              (fun x : B =>	               H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v)	           (fun (C : Type) (h0 : C -> V)	              (_ : forall a0 : C,	                   bisim_aux A0	                     (fun x : A0 =>	                      h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                     (fun x : A0 =>	                      H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                     (h0 a0) =	                   bisim_aux B	                     (fun x : B =>	                      h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                     (fun x : B =>	                      H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                     (h0 a0)) =>	            path_iff_hprop	              (fun	                 X : (forall a0 : A0,	                      Trunc (-1)	                        {b0 : C &	                        H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                          (h0 b0)}) *	                     (forall b0 : C,	                      Trunc (-1)	                        {a0 : A0 &	                        H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                          (h0 b0)}) =>	               (fun b0 : B =>	                Trunc_rec	                  (fun	                     X0 : {a0 : A0 &	                          H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                          H_h (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                   =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b1 : C &	                             H_h	                               (spushl (fun (x : A0) (x0 : B) => R x x0) X0.1)	                               (h0 b1)} =>	                      (X1.1;	                      transport trunctype_type (ap10 X0.2 (h0 X1.1)) X1.2))	                     (fst X X0.1))	                  (Trunc_functor (-1)	                     (fun X0 : {a0 : A0 & R a0 b0} =>	                      (X0.1;	                      ap H_h (spglue (fun (x : A0) (x0 : B) => R x x0) X0.2)))	                     (snd bitot_R b0)),	               fun c : C =>	               Trunc_rec	                 (fun	                    X0 : {a0 : A0 &	                         H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                           (h0 c)} =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {b0 : B &	                            H_h	                              (spushl (fun (x : A0) (x0 : B) => R x x0) X0.1) =	                            H_h (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                     =>	                     (X1.1; transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                    (Trunc_functor (-1)	                       (fun X1 : {b0 : B & R X0.1 b0} =>	                        (X1.1;	                        ap H_h	                          (spglue (fun (x : A0) (x0 : B) => R x x0) X1.2)))	                       (fst bitot_R X0.1))) (snd X c)))	              (fun	                 X : (forall a0 : B,	                      Trunc (-1)	                        {b0 : C &	                        H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                          (h0 b0)}) *	                     (forall b0 : C,	                      Trunc (-1)	                        {a0 : B &	                        H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                          (h0 b0)}) =>	               (fun a0 : A0 =>	                Trunc_rec	                  (fun	                     X0 : {b0 : B &	                          H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                          H_h (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                   =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b0 : C &	                             H_h	                               (spushr (fun (x : A0) (x0 : B) => R x x0) X0.1)	                               (h0 b0)} =>	                      (X1.1;	                      transport trunctype_type (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                     (fst X X0.1))	                  (Trunc_functor (-1)	                     (fun X0 : {b0 : B & R a0 b0} =>	                      (X0.1;	                      ap H_h (spglue (fun (x : A0) (x0 : B) => R x x0) X0.2)))	                     (fst bitot_R a0)),	               fun c : C =>	               Trunc_rec	                 (fun	                    X0 : {a0 : B &	                         H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                           (h0 c)} =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {a0 : A0 &	                            H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                            H_h	                              (spushr (fun (x : A0) (x0 : B) => R x x0) X0.1)}	                     =>	                     (X1.1;	                     transport trunctype_type (ap10 (X1.2)^ (h0 c)) X0.2))	                    (Trunc_functor (-1)	                       (fun X1 : {a0 : A0 & R a0 X0.1} =>	                        (X1.1;	                        ap H_h	                          (spglue (fun (x : A0) (x0 : B) => R x x0) X1.2)))	                       (snd bitot_R X0.1))) (snd X c))))	           (fun v : V =>	            istrunc_paths hProp (-1)	              (bisim_aux A0	                 (fun x : A0 =>	                  h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                 (fun x : A0 =>	                  H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v)	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v))))	     (f a) (f b)}	1 subgoal (ID 399)	  	  ua : Univalence	  A : Type	  f : A -> V	  H_f : forall a : A, f a ~~ f a	  ============================	  forall b : A,	  Trunc (-1)	    {a : A &	    V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	      (fun (A0 B : Type) (R : A0 -> B -> hProp) (bitot_R : bitotal R)	         (h : SPushout (fun (x : A0) (x0 : B) => R x x0) -> V)	         (H_h : SPushout (fun (x : A0) (x0 : B) => R x x0) -> V -> hProp) =>	       transport_const (setext R bitot_R h)	         (bisim_aux A0	            (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	            (fun x : A0 => H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))) @	       path_forall	         (bisim_aux A0	            (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	            (fun x : A0 => H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)))	         (bisim_aux B	            (fun x : B => h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	            (fun x : B => H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)))	         (V_ind_hprop	            (fun v : V =>	             bisim_aux A0	               (fun x : A0 =>	                h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	               (fun x : A0 =>	                H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v =	             bisim_aux B	               (fun x : B => h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	               (fun x : B =>	                H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v)	            (fun (C : Type) (h0 : C -> V)	               (_ : forall a0 : C,	                    bisim_aux A0	                      (fun x : A0 =>	                       h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                      (fun x : A0 =>	                       H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                      (h0 a0) =	                    bisim_aux B	                      (fun x : B =>	                       h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                      (fun x : B =>	                       H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                      (h0 a0)) =>	             path_iff_hprop	               (fun	                  X : (forall a0 : A0,	                       Trunc (-1)	                         {b0 : C &	                         H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                           (h0 b0)}) *	                      (forall b0 : C,	                       Trunc (-1)	                         {a0 : A0 &	                         H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                           (h0 b0)}) =>	                (fun b0 : B =>	                 Trunc_rec	                   (fun	                      X0 : {a0 : A0 &	                           H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                           H_h (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                    =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b1 : C &	                              H_h	                                (spushl (fun (x : A0) (x0 : B) => R x x0)	                                   X0.1) (h0 b1)} =>	                       (X1.1;	                       transport trunctype_type (ap10 X0.2 (h0 X1.1)) X1.2))	                      (fst X X0.1))	                   (Trunc_functor (-1)	                      (fun X0 : {a0 : A0 & R a0 b0} =>	                       (X0.1;	                       ap H_h (spglue (fun (x : A0) (x0 : B) => R x x0) X0.2)))	                      (snd bitot_R b0)),	                fun c : C =>	                Trunc_rec	                  (fun	                     X0 : {a0 : A0 &	                          H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0)	                            (h0 c)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b0 : B &	                             H_h	                               (spushl (fun (x : A0) (x0 : B) => R x x0) X0.1) =	                             H_h	                               (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                      =>	                      (X1.1;	                      transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                     (Trunc_functor (-1)	                        (fun X1 : {b0 : B & R X0.1 b0} =>	                         (X1.1;	                         ap H_h	                           (spglue (fun (x : A0) (x0 : B) => R x x0) X1.2)))	                        (fst bitot_R X0.1))) (snd X c)))	               (fun	                  X : (forall a0 : B,	                       Trunc (-1)	                         {b0 : C &	                         H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                           (h0 b0)}) *	                      (forall b0 : C,	                       Trunc (-1)	                         {a0 : B &	                         H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                           (h0 b0)}) =>	                (fun a0 : A0 =>	                 Trunc_rec	                   (fun	                      X0 : {b0 : B &	                           H_h (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                           H_h (spushr (fun (x : A0) (x0 : B) => R x x0) b0)}	                    =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b0 : C &	                              H_h	                                (spushr (fun (x : A0) (x0 : B) => R x x0)	                                   X0.1) (h0 b0)} =>	                       (X1.1;	                       transport trunctype_type (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                      (fst X X0.1))	                   (Trunc_functor (-1)	                      (fun X0 : {b0 : B & R a0 b0} =>	                       (X0.1;	                       ap H_h (spglue (fun (x : A0) (x0 : B) => R x x0) X0.2)))	                      (fst bitot_R a0)),	                fun c : C =>	                Trunc_rec	                  (fun	                     X0 : {a0 : B &	                          H_h (spushr (fun (x : A0) (x0 : B) => R x x0) a0)	                            (h0 c)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {a0 : A0 &	                             H_h	                               (spushl (fun (x : A0) (x0 : B) => R x x0) a0) =	                             H_h	                               (spushr (fun (x : A0) (x0 : B) => R x x0) X0.1)}	                      =>	                      (X1.1;	                      transport trunctype_type (ap10 (X1.2)^ (h0 c)) X0.2))	                     (Trunc_functor (-1)	                        (fun X1 : {a0 : A0 & R a0 X0.1} =>	                         (X1.1;	                         ap H_h	                           (spglue (fun (x : A0) (x0 : B) => R x x0) X1.2)))	                        (snd bitot_R X0.1))) (snd X c))))	            (fun v : V =>	             istrunc_paths hProp (-1)	               (bisim_aux A0	                  (fun x : A0 =>	                   h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                  (fun x : A0 =>	                   H_h (spushl (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v)	               (bisim_aux B	                  (fun x : B =>	                   h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x))	                  (fun x : B =>	                   H_h (spushr (fun (x0 : A0) (x1 : B) => R x0 x1) x)) v))))	      (f a) (f b)}	No more subgoals.	";
            responses[i]=data;
          

            i = 317;
            data = "";
            responses[i]=data;
          

            i = 318;
            data = "1 subgoal (ID 369)	  	  ua : Univalence	  ============================	  forall u v : V, u = v <~> u ~~ v	";
            responses[i]=data;
          

            i = 319;
            data = "";
            responses[i]=data;
          

            i = 320;
            data = "1 subgoal (ID 371)	  	  ua : Univalence	  u, v : V	  ============================	  u = v <~> u ~~ v	";
            responses[i]=data;
          

            i = 321;
            data = "2 subgoals (ID 396)	  	  ua : Univalence	  u, v : V	  ============================	  u = v -> u ~~ v		subgoal 2 (ID 397) is:	 u ~~ v -> u = v	";
            responses[i]=data;
          

            i = 322;
            data = "1 subgoal (ID 396)	  	  ua : Univalence	  u, v : V	  ============================	  u = v -> u ~~ v	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 397)		subgoal 1 (ID 397) is:	 u ~~ v -> u = v	";
            responses[i]=data;
          

            i = 323;
            data = "1 subgoal (ID 397)	  	  ua : Univalence	  u, v : V	  ============================	  u ~~ v -> u = v	1 subgoal (ID 403)	  	  ua : Univalence	  u, v : V	  ============================	  forall u0 v0 : V, u0 ~~ v0 -> u0 = v0	";
            responses[i]=data;
          

            i = 324;
            data = "1 subgoal (ID 509)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  ============================	  forall v0 : V, set f ~~ v0 -> set f = v0	";
            responses[i]=data;
          

            i = 325;
            data = "1 subgoal (ID 583)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  ============================	  set f ~~ set g -> set f = set g	";
            responses[i]=data;
          

            i = 326;
            data = "1 subgoal (ID 596)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  ============================	  set f = set g	";
            responses[i]=data;
          

            i = 327;
            data = "1 subgoal (ID 599)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  ============================	  equal_img f g	";
            responses[i]=data;
          

            i = 328;
            data = "2 subgoals (ID 601)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  ============================	  forall a : A, hexists (fun b : B => f a = g b)		subgoal 2 (ID 602) is:	 forall b : B, hexists (fun a : A => f a = g b)	";
            responses[i]=data;
          

            i = 329;
            data = "1 subgoal (ID 601)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  ============================	  forall a : A, hexists (fun b : B => f a = g b)	";
            responses[i]=data;
          

            i = 330;
            data = "1 subgoal (ID 603)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  a : A	  ============================	  hexists (fun b : B => f a = g b)	";
            responses[i]=data;
          

            i = 331;
            data = "1 subgoal (ID 604)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  a : A	  ============================	  Trunc (-1)	    {b : B &	    V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	      (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	         (bitot_R : bitotal R)	         (h : SPushout (fun (x : A0) (x0 : B0) => R x x0) -> V)	         (H_h : SPushout (fun (x : A0) (x0 : B0) => R x x0) -> V -> hProp) =>	       transport_const (setext R bitot_R h)	         (bisim_aux A0	            (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	            (fun x : A0 =>	             H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))) @	       path_forall	         (bisim_aux A0	            (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	            (fun x : A0 =>	             H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x)))	         (bisim_aux B0	            (fun x : B0 => h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	            (fun x : B0 =>	             H_h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x)))	         (V_ind_hprop	            (fun v0 : V =>	             bisim_aux A0	               (fun x : A0 =>	                h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	               (fun x : A0 =>	                H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x)) v0 =	             bisim_aux B0	               (fun x : B0 =>	                h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	               (fun x : B0 =>	                H_h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x)) v0)	            (fun (C : Type) (h0 : C -> V)	               (_ : forall a0 : C,	                    bisim_aux A0	                      (fun x : A0 =>	                       h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                      (fun x : A0 =>	                       H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                      (h0 a0) =	                    bisim_aux B0	                      (fun x : B0 =>	                       h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                      (fun x : B0 =>	                       H_h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                      (h0 a0)) =>	             path_iff_hprop	               (fun	                  X : (forall a0 : A0,	                       Trunc (-1)	                         {b0 : C &	                         H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0)	                           (h0 b0)}) *	                      (forall b0 : C,	                       Trunc (-1)	                         {a0 : A0 &	                         H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0)	                           (h0 b0)}) =>	                (fun b0 : B0 =>	                 Trunc_rec	                   (fun	                      X0 : {a0 : A0 &	                           H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0) =	                           H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) b0)}	                    =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b1 : C &	                              H_h	                                (spushl (fun (x : A0) (x0 : B0) => R x x0)	                                   X0.1) (h0 b1)} =>	                       (X1.1;	                       transport trunctype_type (ap10 X0.2 (h0 X1.1)) X1.2))	                      (fst X X0.1))	                   (Trunc_functor (-1)	                      (fun X0 : {a0 : A0 & R a0 b0} =>	                       (X0.1;	                       ap H_h	                         (spglue (fun (x : A0) (x0 : B0) => R x x0) X0.2)))	                      (snd bitot_R b0)),	                fun c : C =>	                Trunc_rec	                  (fun	                     X0 : {a0 : A0 &	                          H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0)	                            (h0 c)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b0 : B0 &	                             H_h	                               (spushl (fun (x : A0) (x0 : B0) => R x x0)	                                  X0.1) =	                             H_h	                               (spushr (fun (x : A0) (x0 : B0) => R x x0) b0)}	                      =>	                      (X1.1;	                      transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                     (Trunc_functor (-1)	                        (fun X1 : {b0 : B0 & R X0.1 b0} =>	                         (X1.1;	                         ap H_h	                           (spglue (fun (x : A0) (x0 : B0) => R x x0) X1.2)))	                        (fst bitot_R X0.1))) (snd X c)))	               (fun	                  X : (forall a0 : B0,	                       Trunc (-1)	                         {b0 : C &	                         H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) a0)	                           (h0 b0)}) *	                      (forall b0 : C,	                       Trunc (-1)	                         {a0 : B0 &	                         H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) a0)	                           (h0 b0)}) =>	                (fun a0 : A0 =>	                 Trunc_rec	                   (fun	                      X0 : {b0 : B0 &	                           H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0) =	                           H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) b0)}	                    =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b0 : C &	                              H_h	                                (spushr (fun (x : A0) (x0 : B0) => R x x0)	                                   X0.1) (h0 b0)} =>	                       (X1.1;	                       transport trunctype_type (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                      (fst X X0.1))	                   (Trunc_functor (-1)	                      (fun X0 : {b0 : B0 & R a0 b0} =>	                       (X0.1;	                       ap H_h	                         (spglue (fun (x : A0) (x0 : B0) => R x x0) X0.2)))	                      (fst bitot_R a0)),	                fun c : C =>	                Trunc_rec	                  (fun	                     X0 : {a0 : B0 &	                          H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) a0)	                            (h0 c)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {a0 : A0 &	                             H_h	                               (spushl (fun (x : A0) (x0 : B0) => R x x0) a0) =	                             H_h	                               (spushr (fun (x : A0) (x0 : B0) => R x x0)	                                  X0.1)} =>	                      (X1.1;	                      transport trunctype_type (ap10 (X1.2)^ (h0 c)) X0.2))	                     (Trunc_functor (-1)	                        (fun X1 : {a0 : A0 & R a0 X0.1} =>	                         (X1.1;	                         ap H_h	                           (spglue (fun (x : A0) (x0 : B0) => R x x0) X1.2)))	                        (snd bitot_R X0.1))) (snd X c))))	            (fun v0 : V =>	             istrunc_paths hProp (-1)	               (bisim_aux A0	                  (fun x : A0 =>	                   h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                  (fun x : A0 =>	                   H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x)) v0)	               (bisim_aux B0	                  (fun x : B0 =>	                   h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                  (fun x : B0 =>	                   H_h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x)) v0))))	      (f a) (g b)} -> hexists (fun b : B => f a = g b)	";
            responses[i]=data;
          

            i = 332;
            data = "1 subgoal (ID 607)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  a : A	  ============================	  {b : B &	  V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	    (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) (bitot_R : bitotal R)	       (h : SPushout (fun (x : A0) (x0 : B0) => R x x0) -> V)	       (H_h : SPushout (fun (x : A0) (x0 : B0) => R x x0) -> V -> hProp) =>	     transport_const (setext R bitot_R h)	       (bisim_aux A0	          (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	          (fun x : A0 => H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))) @	     path_forall	       (bisim_aux A0	          (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	          (fun x : A0 => H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x)))	       (bisim_aux B0	          (fun x : B0 => h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	          (fun x : B0 => H_h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x)))	       (V_ind_hprop	          (fun v0 : V =>	           bisim_aux A0	             (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	             (fun x : A0 =>	              H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x)) v0 =	           bisim_aux B0	             (fun x : B0 => h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	             (fun x : B0 =>	              H_h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x)) v0)	          (fun (C : Type) (h0 : C -> V)	             (_ : forall a0 : C,	                  bisim_aux A0	                    (fun x : A0 =>	                     h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                    (fun x : A0 =>	                     H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                    (h0 a0) =	                  bisim_aux B0	                    (fun x : B0 =>	                     h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                    (fun x : B0 =>	                     H_h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                    (h0 a0)) =>	           path_iff_hprop	             (fun	                X : (forall a0 : A0,	                     Trunc (-1)	                       {b0 : C &	                       H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0)	                         (h0 b0)}) *	                    (forall b0 : C,	                     Trunc (-1)	                       {a0 : A0 &	                       H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0)	                         (h0 b0)}) =>	              (fun b0 : B0 =>	               Trunc_rec	                 (fun	                    X0 : {a0 : A0 &	                         H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0) =	                         H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) b0)}	                  =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {b1 : C &	                            H_h	                              (spushl (fun (x : A0) (x0 : B0) => R x x0) X0.1)	                              (h0 b1)} =>	                     (X1.1;	                     transport trunctype_type (ap10 X0.2 (h0 X1.1)) X1.2))	                    (fst X X0.1))	                 (Trunc_functor (-1)	                    (fun X0 : {a0 : A0 & R a0 b0} =>	                     (X0.1;	                     ap H_h (spglue (fun (x : A0) (x0 : B0) => R x x0) X0.2)))	                    (snd bitot_R b0)),	              fun c : C =>	              Trunc_rec	                (fun	                   X0 : {a0 : A0 &	                        H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0)	                          (h0 c)} =>	                 Trunc_functor (-1)	                   (fun	                      X1 : {b0 : B0 &	                           H_h	                             (spushl (fun (x : A0) (x0 : B0) => R x x0) X0.1) =	                           H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) b0)}	                    =>	                    (X1.1; transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                   (Trunc_functor (-1)	                      (fun X1 : {b0 : B0 & R X0.1 b0} =>	                       (X1.1;	                       ap H_h	                         (spglue (fun (x : A0) (x0 : B0) => R x x0) X1.2)))	                      (fst bitot_R X0.1))) (snd X c)))	             (fun	                X : (forall a0 : B0,	                     Trunc (-1)	                       {b0 : C &	                       H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) a0)	                         (h0 b0)}) *	                    (forall b0 : C,	                     Trunc (-1)	                       {a0 : B0 &	                       H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) a0)	                         (h0 b0)}) =>	              (fun a0 : A0 =>	               Trunc_rec	                 (fun	                    X0 : {b0 : B0 &	                         H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0) =	                         H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) b0)}	                  =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {b0 : C &	                            H_h	                              (spushr (fun (x : A0) (x0 : B0) => R x x0) X0.1)	                              (h0 b0)} =>	                     (X1.1;	                     transport trunctype_type (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                    (fst X X0.1))	                 (Trunc_functor (-1)	                    (fun X0 : {b0 : B0 & R a0 b0} =>	                     (X0.1;	                     ap H_h (spglue (fun (x : A0) (x0 : B0) => R x x0) X0.2)))	                    (fst bitot_R a0)),	              fun c : C =>	              Trunc_rec	                (fun	                   X0 : {a0 : B0 &	                        H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) a0)	                          (h0 c)} =>	                 Trunc_functor (-1)	                   (fun	                      X1 : {a0 : A0 &	                           H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0) =	                           H_h	                             (spushr (fun (x : A0) (x0 : B0) => R x x0) X0.1)}	                    =>	                    (X1.1;	                    transport trunctype_type (ap10 (X1.2)^ (h0 c)) X0.2))	                   (Trunc_functor (-1)	                      (fun X1 : {a0 : A0 & R a0 X0.1} =>	                       (X1.1;	                       ap H_h	                         (spglue (fun (x : A0) (x0 : B0) => R x x0) X1.2)))	                      (snd bitot_R X0.1))) (snd X c))))	          (fun v0 : V =>	           istrunc_paths hProp (-1)	             (bisim_aux A0	                (fun x : A0 =>	                 h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                (fun x : A0 =>	                 H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x)) v0)	             (bisim_aux B0	                (fun x : B0 =>	                 h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                (fun x : B0 =>	                 H_h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x)) v0))))	    (f a) (g b)} -> {b : B & f a = g b}	";
            responses[i]=data;
          

            i = 333;
            data = "1 subgoal (ID 612)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  a : A	  b : B	  h : V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	        (fun (A B : Type) (R : A -> B -> hProp) (bitot_R : bitotal R)	           (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	           (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp) =>	         transport_const (setext R bitot_R h)	           (bisim_aux A	              (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	              (fun x : A => H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	         path_forall	           (bisim_aux A	              (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	              (fun x : A => H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	           (bisim_aux B	              (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	              (fun x : B => H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	           (V_ind_hprop	              (fun v : V =>	               bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	               bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	              (fun (C : Type) (h0 : C -> V)	                 (_ : forall a : C,	                      bisim_aux A	                        (fun x : A =>	                         h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                        (fun x : A =>	                         H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                        (h0 a) =	                      bisim_aux B	                        (fun x : B =>	                         h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                        (fun x : B =>	                         H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                        (h0 a)) =>	               path_iff_hprop	                 (fun	                    X : (forall a : A,	                         Trunc (-1)	                           {b : C &	                           H_h (spushl (fun (x : A) (x0 : B) => R x x0) a)	                             (h0 b)}) *	                        (forall b : C,	                         Trunc (-1)	                           {a : A &	                           H_h (spushl (fun (x : A) (x0 : B) => R x x0) a)	                             (h0 b)}) =>	                  (fun b : B =>	                   Trunc_rec	                     (fun	                        X0 : {a : A &	                             H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	                             H_h (spushr (fun (x : A) (x0 : B) => R x x0) b)}	                      =>	                      Trunc_functor (-1)	                        (fun	                           X1 : {b0 : C &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0)	                                     X0.1) (h0 b0)} =>	                         (X1.1;	                         transport trunctype_type (ap10 X0.2 (h0 X1.1)) X1.2))	                        (fst X X0.1))	                     (Trunc_functor (-1)	                        (fun X0 : {a : A & R a b} =>	                         (X0.1;	                         ap H_h	                           (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                        (snd bitot_R b)),	                  fun c : C =>	                  Trunc_rec	                    (fun	                       X0 : {a : A &	                            H_h (spushl (fun (x : A) (x0 : B) => R x x0) a)	                              (h0 c)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b : B &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0)	                                    X0.1) =	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) b)}	                        =>	                        (X1.1;	                        transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                       (Trunc_functor (-1)	                          (fun X1 : {b : B & R X0.1 b} =>	                           (X1.1;	                           ap H_h	                             (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                          (fst bitot_R X0.1))) (snd X c)))	                 (fun	                    X : (forall a : B,	                         Trunc (-1)	                           {b : C &	                           H_h (spushr (fun (x : A) (x0 : B) => R x x0) a)	                             (h0 b)}) *	                        (forall b : C,	                         Trunc (-1)	                           {a : B &	                           H_h (spushr (fun (x : A) (x0 : B) => R x x0) a)	                             (h0 b)}) =>	                  (fun a : A =>	                   Trunc_rec	                     (fun	                        X0 : {b : B &	                             H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	                             H_h (spushr (fun (x : A) (x0 : B) => R x x0) b)}	                      =>	                      Trunc_functor (-1)	                        (fun	                           X1 : {b : C &	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0)	                                     X0.1) (h0 b)} =>	                         (X1.1;	                         transport trunctype_type 	                           (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                        (fst X X0.1))	                     (Trunc_functor (-1)	                        (fun X0 : {b : B & R a b} =>	                         (X0.1;	                         ap H_h	                           (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                        (fst bitot_R a)),	                  fun c : C =>	                  Trunc_rec	                    (fun	                       X0 : {a : B &	                            H_h (spushr (fun (x : A) (x0 : B) => R x x0) a)	                              (h0 c)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {a : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a) =	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0)	                                    X0.1)} =>	                        (X1.1;	                        transport trunctype_type (ap10 (X1.2)^ (h0 c)) X0.2))	                       (Trunc_functor (-1)	                          (fun X1 : {a : A & R a X0.1} =>	                           (X1.1;	                           ap H_h	                             (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                          (snd bitot_R X0.1))) (snd X c))))	              (fun v : V =>	               istrunc_paths hProp (-1)	                 (bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	        (f a) (g b)	  ============================	  {b0 : B & f a = g b0}	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 subgoal (ID 602)		subgoal 1 (ID 602) is:	 forall b : B, hexists (fun a : A => f a = g b)	";
            responses[i]=data;
          

            i = 334;
            data = "1 subgoal (ID 602)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  ============================	  forall b : B, hexists (fun a : A => f a = g b)	";
            responses[i]=data;
          

            i = 335;
            data = "1 subgoal (ID 615)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  b : B	  ============================	  hexists (fun a : A => f a = g b)	";
            responses[i]=data;
          

            i = 336;
            data = "1 subgoal (ID 616)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  b : B	  ============================	  Trunc (-1)	    {a : A &	    V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	      (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) 	         (bitot_R : bitotal R)	         (h : SPushout (fun (x : A0) (x0 : B0) => R x x0) -> V)	         (H_h : SPushout (fun (x : A0) (x0 : B0) => R x x0) -> V -> hProp) =>	       transport_const (setext R bitot_R h)	         (bisim_aux A0	            (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	            (fun x : A0 =>	             H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))) @	       path_forall	         (bisim_aux A0	            (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	            (fun x : A0 =>	             H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x)))	         (bisim_aux B0	            (fun x : B0 => h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	            (fun x : B0 =>	             H_h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x)))	         (V_ind_hprop	            (fun v0 : V =>	             bisim_aux A0	               (fun x : A0 =>	                h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	               (fun x : A0 =>	                H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x)) v0 =	             bisim_aux B0	               (fun x : B0 =>	                h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	               (fun x : B0 =>	                H_h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x)) v0)	            (fun (C : Type) (h0 : C -> V)	               (_ : forall a0 : C,	                    bisim_aux A0	                      (fun x : A0 =>	                       h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                      (fun x : A0 =>	                       H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                      (h0 a0) =	                    bisim_aux B0	                      (fun x : B0 =>	                       h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                      (fun x : B0 =>	                       H_h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                      (h0 a0)) =>	             path_iff_hprop	               (fun	                  X : (forall a0 : A0,	                       Trunc (-1)	                         {b0 : C &	                         H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0)	                           (h0 b0)}) *	                      (forall b0 : C,	                       Trunc (-1)	                         {a0 : A0 &	                         H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0)	                           (h0 b0)}) =>	                (fun b0 : B0 =>	                 Trunc_rec	                   (fun	                      X0 : {a0 : A0 &	                           H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0) =	                           H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) b0)}	                    =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b1 : C &	                              H_h	                                (spushl (fun (x : A0) (x0 : B0) => R x x0)	                                   X0.1) (h0 b1)} =>	                       (X1.1;	                       transport trunctype_type (ap10 X0.2 (h0 X1.1)) X1.2))	                      (fst X X0.1))	                   (Trunc_functor (-1)	                      (fun X0 : {a0 : A0 & R a0 b0} =>	                       (X0.1;	                       ap H_h	                         (spglue (fun (x : A0) (x0 : B0) => R x x0) X0.2)))	                      (snd bitot_R b0)),	                fun c : C =>	                Trunc_rec	                  (fun	                     X0 : {a0 : A0 &	                          H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0)	                            (h0 c)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {b0 : B0 &	                             H_h	                               (spushl (fun (x : A0) (x0 : B0) => R x x0)	                                  X0.1) =	                             H_h	                               (spushr (fun (x : A0) (x0 : B0) => R x x0) b0)}	                      =>	                      (X1.1;	                      transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                     (Trunc_functor (-1)	                        (fun X1 : {b0 : B0 & R X0.1 b0} =>	                         (X1.1;	                         ap H_h	                           (spglue (fun (x : A0) (x0 : B0) => R x x0) X1.2)))	                        (fst bitot_R X0.1))) (snd X c)))	               (fun	                  X : (forall a0 : B0,	                       Trunc (-1)	                         {b0 : C &	                         H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) a0)	                           (h0 b0)}) *	                      (forall b0 : C,	                       Trunc (-1)	                         {a0 : B0 &	                         H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) a0)	                           (h0 b0)}) =>	                (fun a0 : A0 =>	                 Trunc_rec	                   (fun	                      X0 : {b0 : B0 &	                           H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0) =	                           H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) b0)}	                    =>	                    Trunc_functor (-1)	                      (fun	                         X1 : {b0 : C &	                              H_h	                                (spushr (fun (x : A0) (x0 : B0) => R x x0)	                                   X0.1) (h0 b0)} =>	                       (X1.1;	                       transport trunctype_type (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                      (fst X X0.1))	                   (Trunc_functor (-1)	                      (fun X0 : {b0 : B0 & R a0 b0} =>	                       (X0.1;	                       ap H_h	                         (spglue (fun (x : A0) (x0 : B0) => R x x0) X0.2)))	                      (fst bitot_R a0)),	                fun c : C =>	                Trunc_rec	                  (fun	                     X0 : {a0 : B0 &	                          H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) a0)	                            (h0 c)} =>	                   Trunc_functor (-1)	                     (fun	                        X1 : {a0 : A0 &	                             H_h	                               (spushl (fun (x : A0) (x0 : B0) => R x x0) a0) =	                             H_h	                               (spushr (fun (x : A0) (x0 : B0) => R x x0)	                                  X0.1)} =>	                      (X1.1;	                      transport trunctype_type (ap10 (X1.2)^ (h0 c)) X0.2))	                     (Trunc_functor (-1)	                        (fun X1 : {a0 : A0 & R a0 X0.1} =>	                         (X1.1;	                         ap H_h	                           (spglue (fun (x : A0) (x0 : B0) => R x x0) X1.2)))	                        (snd bitot_R X0.1))) (snd X c))))	            (fun v0 : V =>	             istrunc_paths hProp (-1)	               (bisim_aux A0	                  (fun x : A0 =>	                   h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                  (fun x : A0 =>	                   H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x)) v0)	               (bisim_aux B0	                  (fun x : B0 =>	                   h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                  (fun x : B0 =>	                   H_h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x)) v0))))	      (f a) (g b)} -> hexists (fun a : A => f a = g b)	";
            responses[i]=data;
          

            i = 337;
            data = "1 subgoal (ID 619)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  b : B	  ============================	  {a : A &	  V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	    (fun (A0 B0 : Type) (R : A0 -> B0 -> hProp) (bitot_R : bitotal R)	       (h : SPushout (fun (x : A0) (x0 : B0) => R x x0) -> V)	       (H_h : SPushout (fun (x : A0) (x0 : B0) => R x x0) -> V -> hProp) =>	     transport_const (setext R bitot_R h)	       (bisim_aux A0	          (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	          (fun x : A0 => H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))) @	     path_forall	       (bisim_aux A0	          (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	          (fun x : A0 => H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x)))	       (bisim_aux B0	          (fun x : B0 => h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	          (fun x : B0 => H_h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x)))	       (V_ind_hprop	          (fun v0 : V =>	           bisim_aux A0	             (fun x : A0 => h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	             (fun x : A0 =>	              H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x)) v0 =	           bisim_aux B0	             (fun x : B0 => h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	             (fun x : B0 =>	              H_h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x)) v0)	          (fun (C : Type) (h0 : C -> V)	             (_ : forall a0 : C,	                  bisim_aux A0	                    (fun x : A0 =>	                     h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                    (fun x : A0 =>	                     H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                    (h0 a0) =	                  bisim_aux B0	                    (fun x : B0 =>	                     h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                    (fun x : B0 =>	                     H_h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                    (h0 a0)) =>	           path_iff_hprop	             (fun	                X : (forall a0 : A0,	                     Trunc (-1)	                       {b0 : C &	                       H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0)	                         (h0 b0)}) *	                    (forall b0 : C,	                     Trunc (-1)	                       {a0 : A0 &	                       H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0)	                         (h0 b0)}) =>	              (fun b0 : B0 =>	               Trunc_rec	                 (fun	                    X0 : {a0 : A0 &	                         H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0) =	                         H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) b0)}	                  =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {b1 : C &	                            H_h	                              (spushl (fun (x : A0) (x0 : B0) => R x x0) X0.1)	                              (h0 b1)} =>	                     (X1.1;	                     transport trunctype_type (ap10 X0.2 (h0 X1.1)) X1.2))	                    (fst X X0.1))	                 (Trunc_functor (-1)	                    (fun X0 : {a0 : A0 & R a0 b0} =>	                     (X0.1;	                     ap H_h (spglue (fun (x : A0) (x0 : B0) => R x x0) X0.2)))	                    (snd bitot_R b0)),	              fun c : C =>	              Trunc_rec	                (fun	                   X0 : {a0 : A0 &	                        H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0)	                          (h0 c)} =>	                 Trunc_functor (-1)	                   (fun	                      X1 : {b0 : B0 &	                           H_h	                             (spushl (fun (x : A0) (x0 : B0) => R x x0) X0.1) =	                           H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) b0)}	                    =>	                    (X1.1; transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                   (Trunc_functor (-1)	                      (fun X1 : {b0 : B0 & R X0.1 b0} =>	                       (X1.1;	                       ap H_h	                         (spglue (fun (x : A0) (x0 : B0) => R x x0) X1.2)))	                      (fst bitot_R X0.1))) (snd X c)))	             (fun	                X : (forall a0 : B0,	                     Trunc (-1)	                       {b0 : C &	                       H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) a0)	                         (h0 b0)}) *	                    (forall b0 : C,	                     Trunc (-1)	                       {a0 : B0 &	                       H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) a0)	                         (h0 b0)}) =>	              (fun a0 : A0 =>	               Trunc_rec	                 (fun	                    X0 : {b0 : B0 &	                         H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0) =	                         H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) b0)}	                  =>	                  Trunc_functor (-1)	                    (fun	                       X1 : {b0 : C &	                            H_h	                              (spushr (fun (x : A0) (x0 : B0) => R x x0) X0.1)	                              (h0 b0)} =>	                     (X1.1;	                     transport trunctype_type (ap10 (X0.2)^ (h0 X1.1)) X1.2))	                    (fst X X0.1))	                 (Trunc_functor (-1)	                    (fun X0 : {b0 : B0 & R a0 b0} =>	                     (X0.1;	                     ap H_h (spglue (fun (x : A0) (x0 : B0) => R x x0) X0.2)))	                    (fst bitot_R a0)),	              fun c : C =>	              Trunc_rec	                (fun	                   X0 : {a0 : B0 &	                        H_h (spushr (fun (x : A0) (x0 : B0) => R x x0) a0)	                          (h0 c)} =>	                 Trunc_functor (-1)	                   (fun	                      X1 : {a0 : A0 &	                           H_h (spushl (fun (x : A0) (x0 : B0) => R x x0) a0) =	                           H_h	                             (spushr (fun (x : A0) (x0 : B0) => R x x0) X0.1)}	                    =>	                    (X1.1;	                    transport trunctype_type (ap10 (X1.2)^ (h0 c)) X0.2))	                   (Trunc_functor (-1)	                      (fun X1 : {a0 : A0 & R a0 X0.1} =>	                       (X1.1;	                       ap H_h	                         (spglue (fun (x : A0) (x0 : B0) => R x x0) X1.2)))	                      (snd bitot_R X0.1))) (snd X c))))	          (fun v0 : V =>	           istrunc_paths hProp (-1)	             (bisim_aux A0	                (fun x : A0 =>	                 h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                (fun x : A0 =>	                 H_h (spushl (fun (x0 : A0) (x1 : B0) => R x0 x1) x)) v0)	             (bisim_aux B0	                (fun x : B0 =>	                 h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x))	                (fun x : B0 =>	                 H_h (spushr (fun (x0 : A0) (x1 : B0) => R x0 x1) x)) v0))))	    (f a) (g b)} -> {a : A & f a = g b}	";
            responses[i]=data;
          

            i = 338;
            data = "1 subgoal (ID 624)	  	  ua : Univalence	  u, v : V	  A : Type	  f : A -> V	  H_f : forall (a : A) (v : V), f a ~~ v -> f a = v	  B : Type	  g : B -> V	  H1 : forall a : A,	       Trunc (-1)	         {b : B &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  H2 : forall b : B,	       Trunc (-1)	         {a : A &	         V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	           (fun (A B : Type) (R : A -> B -> hProp) 	              (bitot_R : bitotal R)	              (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	              (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp)	            =>	            transport_const (setext R bitot_R h)	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	            path_forall	              (bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	              (V_ind_hprop	                 (fun v : V =>	                  bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	                  bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (fun (C : Type) (h0 : C -> V)	                    (_ : forall a0 : C,	                         bisim_aux A	                           (fun x : A =>	                            h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : A =>	                            H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0) =	                         bisim_aux B	                           (fun x : B =>	                            h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (fun x : B =>	                            H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                           (h0 a0)) =>	                  path_iff_hprop	                    (fun	                       X : (forall a0 : A,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : A &	                              H_h	                                (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun b0 : B =>	                      Trunc_rec	                        (fun	                           X0 : {a0 : A &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b1 : C &	                                   H_h	                                     (spushl (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b1)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 X0.2 (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {a0 : A & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (snd bitot_R b0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {b0 : B &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       X0.1) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       b0)} =>	                           (X1.1;	                           transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {b0 : B & R X0.1 b0} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (fst bitot_R X0.1))) 	                       (snd X c)))	                    (fun	                       X : (forall a0 : B,	                            Trunc (-1)	                              {b0 : C &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) *	                           (forall b0 : C,	                            Trunc (-1)	                              {a0 : B &	                              H_h	                                (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                (h0 b0)}) =>	                     (fun a0 : A =>	                      Trunc_rec	                        (fun	                           X0 : {b0 : B &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0) a0) =	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0) b0)}	                         =>	                         Trunc_functor (-1)	                           (fun	                              X1 : {b0 : C &	                                   H_h	                                     (spushr (fun (x : A) (x0 : B) => R x x0)	                                        X0.1) (h0 b0)} =>	                            (X1.1;	                            transport trunctype_type 	                              (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                           (fst X X0.1))	                        (Trunc_functor (-1)	                           (fun X0 : {b0 : B & R a0 b0} =>	                            (X0.1;	                            ap H_h	                              (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                           (fst bitot_R a0)),	                     fun c : C =>	                     Trunc_rec	                       (fun	                          X0 : {a0 : B &	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) a0)	                                 (h0 c)} =>	                        Trunc_functor (-1)	                          (fun	                             X1 : {a0 : A &	                                  H_h	                                    (spushl (fun (x : A) (x0 : B) => R x x0)	                                       a0) =	                                  H_h	                                    (spushr (fun (x : A) (x0 : B) => R x x0)	                                       X0.1)} =>	                           (X1.1;	                           transport trunctype_type 	                             (ap10 (X1.2)^ (h0 c)) X0.2))	                          (Trunc_functor (-1)	                             (fun X1 : {a0 : A & R a0 X0.1} =>	                              (X1.1;	                              ap H_h	                                (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                             (snd bitot_R X0.1))) 	                       (snd X c))))	                 (fun v : V =>	                  istrunc_paths hProp (-1)	                    (bisim_aux A	                       (fun x : A =>	                        h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : A =>	                        H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                    (bisim_aux B	                       (fun x : B =>	                        h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                       (fun x : B =>	                        H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	           (f a) (g b)}	  b : B	  a : A	  h : V_ind (fun _ : V => V -> hProp) (fun _ : V => trunc_arrow) bisim_aux	        (fun (A B : Type) (R : A -> B -> hProp) (bitot_R : bitotal R)	           (h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V)	           (H_h : SPushout (fun (x : A) (x0 : B) => R x x0) -> V -> hProp) =>	         transport_const (setext R bitot_R h)	           (bisim_aux A	              (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	              (fun x : A => H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))) @	         path_forall	           (bisim_aux A	              (fun x : A => h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	              (fun x : A => H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)))	           (bisim_aux B	              (fun x : B => h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	              (fun x : B => H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)))	           (V_ind_hprop	              (fun v : V =>	               bisim_aux A	                 (fun x : A =>	                  h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : A =>	                  H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v =	               bisim_aux B	                 (fun x : B =>	                  h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                 (fun x : B =>	                  H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	              (fun (C : Type) (h0 : C -> V)	                 (_ : forall a : C,	                      bisim_aux A	                        (fun x : A =>	                         h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                        (fun x : A =>	                         H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                        (h0 a) =	                      bisim_aux B	                        (fun x : B =>	                         h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                        (fun x : B =>	                         H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                        (h0 a)) =>	               path_iff_hprop	                 (fun	                    X : (forall a : A,	                         Trunc (-1)	                           {b : C &	                           H_h (spushl (fun (x : A) (x0 : B) => R x x0) a)	                             (h0 b)}) *	                        (forall b : C,	                         Trunc (-1)	                           {a : A &	                           H_h (spushl (fun (x : A) (x0 : B) => R x x0) a)	                             (h0 b)}) =>	                  (fun b : B =>	                   Trunc_rec	                     (fun	                        X0 : {a : A &	                             H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	                             H_h (spushr (fun (x : A) (x0 : B) => R x x0) b)}	                      =>	                      Trunc_functor (-1)	                        (fun	                           X1 : {b0 : C &	                                H_h	                                  (spushl (fun (x : A) (x0 : B) => R x x0)	                                     X0.1) (h0 b0)} =>	                         (X1.1;	                         transport trunctype_type (ap10 X0.2 (h0 X1.1)) X1.2))	                        (fst X X0.1))	                     (Trunc_functor (-1)	                        (fun X0 : {a : A & R a b} =>	                         (X0.1;	                         ap H_h	                           (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                        (snd bitot_R b)),	                  fun c : C =>	                  Trunc_rec	                    (fun	                       X0 : {a : A &	                            H_h (spushl (fun (x : A) (x0 : B) => R x x0) a)	                              (h0 c)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {b : B &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0)	                                    X0.1) =	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0) b)}	                        =>	                        (X1.1;	                        transport trunctype_type (ap10 X1.2 (h0 c)) X0.2))	                       (Trunc_functor (-1)	                          (fun X1 : {b : B & R X0.1 b} =>	                           (X1.1;	                           ap H_h	                             (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                          (fst bitot_R X0.1))) (snd X c)))	                 (fun	                    X : (forall a : B,	                         Trunc (-1)	                           {b : C &	                           H_h (spushr (fun (x : A) (x0 : B) => R x x0) a)	                             (h0 b)}) *	                        (forall b : C,	                         Trunc (-1)	                           {a : B &	                           H_h (spushr (fun (x : A) (x0 : B) => R x x0) a)	                             (h0 b)}) =>	                  (fun a : A =>	                   Trunc_rec	                     (fun	                        X0 : {b : B &	                             H_h (spushl (fun (x : A) (x0 : B) => R x x0) a) =	                             H_h (spushr (fun (x : A) (x0 : B) => R x x0) b)}	                      =>	                      Trunc_functor (-1)	                        (fun	                           X1 : {b : C &	                                H_h	                                  (spushr (fun (x : A) (x0 : B) => R x x0)	                                     X0.1) (h0 b)} =>	                         (X1.1;	                         transport trunctype_type 	                           (ap10 (X0.2)^ (h0 X1.1)) X1.2)) 	                        (fst X X0.1))	                     (Trunc_functor (-1)	                        (fun X0 : {b : B & R a b} =>	                         (X0.1;	                         ap H_h	                           (spglue (fun (x : A) (x0 : B) => R x x0) X0.2)))	                        (fst bitot_R a)),	                  fun c : C =>	                  Trunc_rec	                    (fun	                       X0 : {a : B &	                            H_h (spushr (fun (x : A) (x0 : B) => R x x0) a)	                              (h0 c)} =>	                     Trunc_functor (-1)	                       (fun	                          X1 : {a : A &	                               H_h	                                 (spushl (fun (x : A) (x0 : B) => R x x0) a) =	                               H_h	                                 (spushr (fun (x : A) (x0 : B) => R x x0)	                                    X0.1)} =>	                        (X1.1;	                        transport trunctype_type (ap10 (X1.2)^ (h0 c)) X0.2))	                       (Trunc_functor (-1)	                          (fun X1 : {a : A & R a X0.1} =>	                           (X1.1;	                           ap H_h	                             (spglue (fun (x : A) (x0 : B) => R x x0) X1.2)))	                          (snd bitot_R X0.1))) (snd X c))))	              (fun v : V =>	               istrunc_paths hProp (-1)	                 (bisim_aux A	                    (fun x : A =>	                     h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : A =>	                     H_h (spushl (fun (x0 : A) (x1 : B) => R x0 x1) x)) v)	                 (bisim_aux B	                    (fun x : B =>	                     h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x))	                    (fun x : B =>	                     H_h (spushr (fun (x0 : A) (x1 : B) => R x0 x1) x)) v))))	        (f a) (g b)	  ============================	  {a0 : A & f a0 = g b}	No more subgoals.	";
            responses[i]=data;
          

            i = 339;
            data = "";
            responses[i]=data;
          

            i = 340;
            data = "";
            responses[i]=data;
          

            i = 341;
            data = "";
            responses[i]=data;
          

            i = 342;
            data = "";
            responses[i]=data;
          

            i = 343;
            data = "";
            responses[i]=data;
          

            i = 344;
            data = "";
            responses[i]=data;
          

            i = 345;
            data = "";
            responses[i]=data;
          

            i = 346;
            data = "";
            responses[i]=data;
          

            i = 347;
            data = "";
            responses[i]=data;
          

            i = 348;
            data = "";
            responses[i]=data;
          

            i = 349;
            data = "<infomsg>ker_bisim is defined</infomsg>	";
            responses[i]=data;
          

            i = 350;
            data = "1 subgoal (ID 377)	  	  ua : Univalence	  A : Type	  f : A -> V	  ============================	  forall x y : A, f x = f y <~> ker_bisim f x y	";
            responses[i]=data;
          

            i = 351;
            data = "";
            responses[i]=data;
          

            i = 352;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 353;
            data = "";
            responses[i]=data;
          

            i = 354;
            data = "";
            responses[i]=data;
          

            i = 355;
            data = "";
            responses[i]=data;
          

            i = 356;
            data = "";
            responses[i]=data;
          

            i = 357;
            data = "";
            responses[i]=data;
          

            i = 358;
            data = "";
            responses[i]=data;
          

            i = 359;
            data = "<infomsg>u is declared</infomsg>	<infomsg>Au is declared</infomsg>	<infomsg>Au' is declared</infomsg>	<infomsg>h is declared</infomsg>	<infomsg>h' is declared</infomsg>	<infomsg>mu is declared</infomsg>	<infomsg>mono is declared</infomsg>	<infomsg>mu' is declared</infomsg>	<infomsg>mono' is declared</infomsg>	<infomsg>p is declared</infomsg>	<infomsg>p' is declared</infomsg>	";
            responses[i]=data;
          

            i = 360;
            data = "1 subgoal (ID 394)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  ============================	  (forall a : Au, {a' : Au' & mu' a' = mu a}) *	  (forall a' : Au', {a : Au & mu a = mu' a'})	";
            responses[i]=data;
          

            i = 361;
            data = "";
            responses[i]=data;
          

            i = 362;
            data = "2 subgoals (ID 396)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  ============================	  forall a : Au, {a' : Au' & mu' a' = mu a}		subgoal 2 (ID 397) is:	 forall a' : Au', {a : Au & mu a = mu' a'}	";
            responses[i]=data;
          

            i = 363;
            data = "1 subgoal (ID 396)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  ============================	  forall a : Au, {a' : Au' & mu' a' = mu a}	1 subgoal (ID 398)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  a : Au	  ============================	  {a' : Au' & mu' a' = mu a}	";
            responses[i]=data;
          

            i = 364;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 397)		subgoal 1 (ID 397) is:	 forall a' : Au', {a : Au & mu a = mu' a'}	";
            responses[i]=data;
          

            i = 365;
            data = "1 subgoal (ID 397)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  ============================	  forall a' : Au', {a : Au & mu a = mu' a'}	1 subgoal (ID 421)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  a' : Au'	  ============================	  {a : Au & mu a = mu' a'}	";
            responses[i]=data;
          

            i = 366;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 367;
            data = "";
            responses[i]=data;
          

            i = 368;
            data = "<infomsg>e is defined</infomsg>	";
            responses[i]=data;
          

            i = 369;
            data = "<infomsg>inv_e is defined</infomsg>	";
            responses[i]=data;
          

            i = 370;
            data = "1 subgoal (ID 407)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  ============================	  Sect inv_e e	";
            responses[i]=data;
          

            i = 371;
            data = "";
            responses[i]=data;
          

            i = 372;
            data = "1 subgoal (ID 409)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  a' : Au'	  ============================	  e (inv_e a') = a'	";
            responses[i]=data;
          

            i = 373;
            data = "1 subgoal (ID 412)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  a' : Au'	  ============================	  mu' (e (inv_e a')) = mu' a'	";
            responses[i]=data;
          

            i = 374;
            data = "2 subgoals (ID 428)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  a' : Au'	  ============================	  mu' (e (inv_e a')) = mu (inv_e a')		subgoal 2 (ID 430) is:	 mu (inv_e a') = mu' a'	";
            responses[i]=data;
          

            i = 375;
            data = "1 subgoal (ID 428)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  a' : Au'	  ============================	  mu' (e (inv_e a')) = mu (inv_e a')	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 430)		subgoal 1 (ID 430) is:	 mu (inv_e a') = mu' a'	";
            responses[i]=data;
          

            i = 376;
            data = "1 subgoal (ID 430)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  a' : Au'	  ============================	  mu (inv_e a') = mu' a'	No more subgoals.	";
            responses[i]=data;
          

            i = 377;
            data = "";
            responses[i]=data;
          

            i = 378;
            data = "1 subgoal (ID 410)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : Sect inv_e e	  ============================	  Sect e inv_e	";
            responses[i]=data;
          

            i = 379;
            data = "";
            responses[i]=data;
          

            i = 380;
            data = "1 subgoal (ID 412)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : Sect inv_e e	  a : Au	  ============================	  inv_e (e a) = a	";
            responses[i]=data;
          

            i = 381;
            data = "1 subgoal (ID 415)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : Sect inv_e e	  a : Au	  ============================	  mu (inv_e (e a)) = mu a	";
            responses[i]=data;
          

            i = 382;
            data = "2 subgoals (ID 431)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : Sect inv_e e	  a : Au	  ============================	  mu (inv_e (e a)) = mu' (e a)		subgoal 2 (ID 433) is:	 mu' (e a) = mu a	";
            responses[i]=data;
          

            i = 383;
            data = "1 subgoal (ID 431)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : Sect inv_e e	  a : Au	  ============================	  mu (inv_e (e a)) = mu' (e a)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 433)		subgoal 1 (ID 433) is:	 mu' (e a) = mu a	";
            responses[i]=data;
          

            i = 384;
            data = "1 subgoal (ID 433)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : Sect inv_e e	  a : Au	  ============================	  mu' (e a) = mu a	No more subgoals.	";
            responses[i]=data;
          

            i = 385;
            data = "";
            responses[i]=data;
          

            i = 386;
            data = "1 subgoal (ID 413)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : Sect e inv_e	  ============================	  Au' = Au	";
            responses[i]=data;
          

            i = 387;
            data = "";
            responses[i]=data;
          

            i = 388;
            data = "1 subgoal (ID 417)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : Sect e inv_e	  ============================	  Au' <~> Au	";
            responses[i]=data;
          

            i = 389;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 390;
            data = "";
            responses[i]=data;
          

            i = 391;
            data = "1 subgoal (ID 422)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  ============================	  transport (fun A : Type => A -> V) path^ mu = mu'	";
            responses[i]=data;
          

            i = 392;
            data = "";
            responses[i]=data;
          

            i = 393;
            data = "1 subgoal (ID 429)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  ============================	  transport (fun A : Type => A -> V) path^ mu == mu'	";
            responses[i]=data;
          

            i = 394;
            data = "1 subgoal (ID 431)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  a' : Au'	  ============================	  transport (fun A : Type => A -> V) path^ mu a' = mu' a'	";
            responses[i]=data;
          

            i = 395;
            data = "2 subgoals (ID 463)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  a' : Au'	  ============================	  transport (fun A : Type => A -> V) path^ mu a' =	  transport (fun _ : Type => V) path^ (mu (transport idmap (path^)^ a'))		subgoal 2 (ID 465) is:	 transport (fun _ : Type => V) path^ (mu (transport idmap (path^)^ a')) =	 mu' a'	";
            responses[i]=data;
          

            i = 396;
            data = "1 subgoal (ID 463)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  a' : Au'	  ============================	  transport (fun A : Type => A -> V) path^ mu a' =	  transport (fun _ : Type => V) path^ (mu (transport idmap (path^)^ a'))	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 465)		subgoal 1 (ID 465) is:	 transport (fun _ : Type => V) path^ (mu (transport idmap (path^)^ a')) =	 mu' a'	";
            responses[i]=data;
          

            i = 397;
            data = "1 subgoal (ID 465)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  a' : Au'	  ============================	  transport (fun _ : Type => V) path^ (mu (transport idmap (path^)^ a')) =	  mu' a'	2 subgoals (ID 495)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  a' : Au'	  ============================	  transport (fun _ : Type => V) path^ (mu (transport idmap (path^)^ a')) =	  mu (transport idmap (path^)^ a')		subgoal 2 (ID 497) is:	 mu (transport idmap (path^)^ a') = mu' a'	";
            responses[i]=data;
          

            i = 398;
            data = "1 subgoal (ID 495)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  a' : Au'	  ============================	  transport (fun _ : Type => V) path^ (mu (transport idmap (path^)^ a')) =	  mu (transport idmap (path^)^ a')	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 subgoal (ID 497)		subgoal 1 (ID 497) is:	 mu (transport idmap (path^)^ a') = mu' a'	";
            responses[i]=data;
          

            i = 399;
            data = "1 subgoal (ID 497)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  a' : Au'	  ============================	  mu (transport idmap (path^)^ a') = mu' a'	2 subgoals (ID 517)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  a' : Au'	  ============================	  mu (transport idmap (path^)^ a') = mu (inv_e a')		subgoal 2 (ID 519) is:	 mu (inv_e a') = mu' a'	";
            responses[i]=data;
          

            i = 400;
            data = "1 subgoal (ID 517)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  a' : Au'	  ============================	  mu (transport idmap (path^)^ a') = mu (inv_e a')	";
            responses[i]=data;
          

            i = 401;
            data = "1 subgoal (ID 531)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  a' : Au'	  ============================	  transport idmap (path^)^ a' = inv_e a'	";
            responses[i]=data;
          

            i = 402;
            data = "2 subgoals (ID 551)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  a' : Au'	  ============================	  transport idmap (path^)^ a' = transport idmap path a'		subgoal 2 (ID 553) is:	 transport idmap path a' = inv_e a'	";
            responses[i]=data;
          

            i = 403;
            data = "1 subgoal (ID 551)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  a' : Au'	  ============================	  transport idmap (path^)^ a' = transport idmap path a'	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	1 subgoal (ID 553)		subgoal 1 (ID 553) is:	 transport idmap path a' = inv_e a'	";
            responses[i]=data;
          

            i = 404;
            data = "1 subgoal (ID 553)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  a' : Au'	  ============================	  transport idmap path a' = inv_e a'	No more subgoals.	";
            responses[i]=data;
          

            i = 405;
            data = "";
            responses[i]=data;
          

            i = 406;
            data = "1 subgoal (ID 450)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  ============================	  (Au; mu; (h, mono, p)) = (Au'; mu'; (h', mono', p'))	";
            responses[i]=data;
          

            i = 407;
            data = "";
            responses[i]=data;
          

            i = 408;
            data = "1 subgoal (ID 454)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  ============================	  {p0 : Au = Au' &	  transport	    (fun A : Type => {m : A -> V & IsHSet A * IsEmbedding m * (u = set m)})	    p0 (mu; (h, mono, p)) = (mu'; (h', mono', p'))}	";
            responses[i]=data;
          

            i = 409;
            data = "1 subgoal (ID 459)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  ============================	  transport	    (fun A : Type => {m : A -> V & IsHSet A * IsEmbedding m * (u = set m)})	    path^ (mu; (h, mono, p)) = (mu'; (h', mono', p'))	";
            responses[i]=data;
          

            i = 410;
            data = "2 subgoals (ID 504)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  ============================	  transport	    (fun A : Type => {m : A -> V & IsHSet A * IsEmbedding m * (u = set m)})	    path^ (mu; (h, mono, p)) =	  (transport (fun A : Type => A -> V) path^ mu;	  transportD (fun A : Type => A -> V)	    (fun (A : Type) (m : (fun A0 : Type => A0 -> V) A) =>	     IsHSet A * IsEmbedding m * (u = set m)) path^ mu 	    (h, mono, p))		subgoal 2 (ID 506) is:	 (transport (fun A : Type => A -> V) path^ mu;	 transportD (fun A : Type => A -> V)	   (fun (A : Type) (m : (fun A0 : Type => A0 -> V) A) =>	    IsHSet A * IsEmbedding m * (u = set m)) path^ mu 	   (h, mono, p)) = (mu'; (h', mono', p'))	";
            responses[i]=data;
          

            i = 411;
            data = "1 subgoal (ID 504)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  ============================	  transport	    (fun A : Type => {m : A -> V & IsHSet A * IsEmbedding m * (u = set m)})	    path^ (mu; (h, mono, p)) =	  (transport (fun A : Type => A -> V) path^ mu;	  transportD (fun A : Type => A -> V)	    (fun (A : Type) (m : (fun A0 : Type => A0 -> V) A) =>	     IsHSet A * IsEmbedding m * (u = set m)) path^ mu 	    (h, mono, p))	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 506)		subgoal 1 (ID 506) is:	 (transport (fun A : Type => A -> V) path^ mu;	 transportD (fun A : Type => A -> V)	   (fun (A : Type) (m : (fun A0 : Type => A0 -> V) A) =>	    IsHSet A * IsEmbedding m * (u = set m)) path^ mu 	   (h, mono, p)) = (mu'; (h', mono', p'))	";
            responses[i]=data;
          

            i = 412;
            data = "1 subgoal (ID 506)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  ============================	  (transport (fun A : Type => A -> V) path^ mu;	  transportD (fun A : Type => A -> V)	    (fun (A : Type) (m : (fun A0 : Type => A0 -> V) A) =>	     IsHSet A * IsEmbedding m * (u = set m)) path^ mu 	    (h, mono, p)) = (mu'; (h', mono', p'))	";
            responses[i]=data;
          

            i = 413;
            data = "1 subgoal (ID 626)	  	  ua : Univalence	  u : V	  Au : Type	  Au' : Type	  h : IsHSet Au	  h' : IsHSet Au'	  mu : Au -> V	  mono : IsEmbedding mu	  mu' : Au' -> V	  mono' : IsEmbedding mu'	  p : u = set mu	  p' : u = set mu'	  e := fun a : Au => (fst eq_img_untrunc a).1 : Au -> Au'	  inv_e := fun a' : Au' => (snd eq_img_untrunc a').1 : Au' -> Au	  hom1 := (fun a' : Au' =>	           isinj_embedding mu' mono' (e (inv_e a')) a'	             ((fst eq_img_untrunc (inv_e a')).2 @ (snd eq_img_untrunc a').2))	   : Sect inv_e e	  hom2 := (fun a : Au =>	           isinj_embedding mu mono (inv_e (e a)) a	             ((snd eq_img_untrunc (e a)).2 @ (fst eq_img_untrunc a).2))	   : Sect e inv_e	  path := path_universe_uncurried (equiv_adjointify inv_e e hom2 hom1)	   : Au' = Au	  ============================	  transport (fun A : Type => A -> V) path^ mu = mu'	No more subgoals.	";
            responses[i]=data;
          

            i = 414;
            data = "";
            responses[i]=data;
          

            i = 415;
            data = "";
            responses[i]=data;
          

            i = 416;
            data = "";
            responses[i]=data;
          

            i = 417;
            data = "";
            responses[i]=data;
          

            i = 418;
            data = "";
            responses[i]=data;
          

            i = 419;
            data = "";
            responses[i]=data;
          

            i = 420;
            data = "1 subgoal (ID 385)	  	  ua : Univalence	  ============================	  forall u : V,	  {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (u = set m)}}	";
            responses[i]=data;
          

            i = 421;
            data = "";
            responses[i]=data;
          

            i = 422;
            data = "2 subgoals (ID 386)	  	  ua : Univalence	  ============================	  forall (A : Type) (f : A -> V),	  (forall a : A,	   {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (f a = set m)}}) ->	  {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (set f = set m)}}		subgoal 2 (ID 387) is:	 forall v : V,	 IsHProp	   {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (v = set m)}}	";
            responses[i]=data;
          

            i = 423;
            data = "1 subgoal (ID 386)	  	  ua : Univalence	  ============================	  forall (A : Type) (f : A -> V),	  (forall a : A,	   {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (f a = set m)}}) ->	  {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (set f = set m)}}	1 subgoal (ID 391)	  	  ua : Univalence	  A : Type	  f : A -> V	  ============================	  {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (set f = set m)}}	";
            responses[i]=data;
          

            i = 424;
            data = "1 subgoal (ID 426)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  ============================	  {Au0 : Type &	  {m : Au0 -> V & IsHSet Au0 * IsEmbedding m * (set f = set m)}}	";
            responses[i]=data;
          

            i = 425;
            data = "1 subgoal (ID 430)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  ============================	  IsHSet Au * IsEmbedding mu * (set f = set mu)	";
            responses[i]=data;
          

            i = 426;
            data = "1 subgoal (ID 433)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  ============================	  set f = set mu	";
            responses[i]=data;
          

            i = 427;
            data = "2 subgoals (ID 440)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  ============================	  forall a : A, hexists (fun b : Au => f a = mu b)		subgoal 2 (ID 441) is:	 forall b : Au, hexists (fun a : A => f a = mu b)	";
            responses[i]=data;
          

            i = 428;
            data = "1 subgoal (ID 440)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  ============================	  forall a : A, hexists (fun b : Au => f a = mu b)	1 subgoal (ID 442)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  a : A	  ============================	  hexists (fun b : Au => f a = mu b)	";
            responses[i]=data;
          

            i = 429;
            data = "1 subgoal (ID 447)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  a : A	  ============================	  f a = mu (eu a)	";
            responses[i]=data;
          

            i = 430;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 subgoals (ID 441)		subgoal 1 (ID 441) is:	 forall b : Au, hexists (fun a : A => f a = mu b)	subgoal 2 (ID 387) is:	 forall v : V,	 IsHProp	   {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (v = set m)}}	";
            responses[i]=data;
          

            i = 431;
            data = "1 subgoal (ID 441)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  ============================	  forall b : Au, hexists (fun a : A => f a = mu b)	1 subgoal (ID 452)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  a' : Au	  ============================	  hexists (fun a : A => f a = mu a')	";
            responses[i]=data;
          

            i = 432;
            data = "1 subgoal (ID 453)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  a' : Au	  ============================	  TrM.RSU.IsConnected (-1)%trunc (hfiber eu a') ->	  hexists (fun a : A => f a = mu a')	";
            responses[i]=data;
          

            i = 433;
            data = "1 subgoal (ID 472)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  a' : Au	  X : TrM.RSU.IsConnected (-1)%trunc (hfiber eu a')	  ============================	  hfiber eu a' -> {a : A & f a = mu a'}	";
            responses[i]=data;
          

            i = 434;
            data = "1 subgoal (ID 477)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  a' : Au	  X : TrM.RSU.IsConnected (-1)%trunc (hfiber eu a')	  a : A	  p : eu a = a'	  ============================	  {a0 : A & f a0 = mu a'}	";
            responses[i]=data;
          

            i = 435;
            data = "1 subgoal (ID 479)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  a' : Au	  X : TrM.RSU.IsConnected (-1)%trunc (hfiber eu a')	  a : A	  p : eu a = a'	  ============================	  f a = mu a'	";
            responses[i]=data;
          

            i = 436;
            data = "2 subgoals (ID 495)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  a' : Au	  X : TrM.RSU.IsConnected (-1)%trunc (hfiber eu a')	  a : A	  p : eu a = a'	  ============================	  f a = mu (eu a)		subgoal 2 (ID 497) is:	 mu (eu a) = mu a'	";
            responses[i]=data;
          

            i = 437;
            data = "1 subgoal (ID 495)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  a' : Au	  X : TrM.RSU.IsConnected (-1)%trunc (hfiber eu a')	  a : A	  p : eu a = a'	  ============================	  f a = mu (eu a)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	2 subgoals (ID 497)		subgoal 1 (ID 497) is:	 mu (eu a) = mu a'	subgoal 2 (ID 387) is:	 forall v : V,	 IsHProp	   {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (v = set m)}}	";
            responses[i]=data;
          

            i = 438;
            data = "1 subgoal (ID 497)	  	  ua : Univalence	  A : Type	  f : A -> V	  Au : Type	  eu : A -> Au	  mu : Au -> V	  hset_Au : IsHSet Au	  epi_eu : IsSurjection eu	  mono_mu : IsEmbedding mu	  factor : f = (fun x : A => mu (eu x))	  a' : Au	  X : TrM.RSU.IsConnected (-1)%trunc (hfiber eu a')	  a : A	  p : eu a = a'	  ============================	  mu (eu a) = mu a'	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 387)		subgoal 1 (ID 387) is:	 forall v : V,	 IsHProp	   {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (v = set m)}}	";
            responses[i]=data;
          

            i = 439;
            data = "1 subgoal (ID 387)	  	  ua : Univalence	  ============================	  forall v : V,	  IsHProp	    {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (v = set m)}}	1 subgoal (ID 506)	  	  ua : Univalence	  v : V	  ============================	  IsHProp	    {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (v = set m)}}	";
            responses[i]=data;
          

            i = 440;
            data = "1 subgoal (ID 507)	  	  ua : Univalence	  v : V	  ============================	  forall	  x y : {Au : Type & {m : Au -> V & IsHSet Au * IsEmbedding m * (v = set m)}},	  x = y	";
            responses[i]=data;
          

            i = 441;
            data = "1 subgoal (ID 524)	  	  ua : Univalence	  v : V	  Au : Type	  mu : Au -> V	  hset : IsHSet Au	  mono : IsEmbedding mu	  p : v = set mu	  ============================	  forall	  y : {Au0 : Type &	      {m : Au0 -> V & IsHSet Au0 * IsEmbedding m * (v = set m)}},	  (Au; mu; (hset, mono, p)) = y	";
            responses[i]=data;
          

            i = 442;
            data = "1 subgoal (ID 541)	  	  ua : Univalence	  v : V	  Au : Type	  mu : Au -> V	  hset : IsHSet Au	  mono : IsEmbedding mu	  p : v = set mu	  Au' : Type	  mu' : Au' -> V	  hset' : IsHSet Au'	  mono' : IsEmbedding mu'	  p' : v = set mu'	  ============================	  (Au; mu; (hset, mono, p)) = (Au'; mu'; (hset', mono', p'))	";
            responses[i]=data;
          

            i = 443;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 444;
            data = "";
            responses[i]=data;
          

            i = 445;
            data = "<infomsg>type_of_members is defined</infomsg>	";
            responses[i]=data;
          

            i = 446;
            data = "";
            responses[i]=data;
          

            i = 447;
            data = "<infomsg>func_of_members is defined</infomsg>	";
            responses[i]=data;
          

            i = 448;
            data = "<infomsg>is_hset_typeofmembers is defined</infomsg>	";
            responses[i]=data;
          

            i = 449;
            data = "<infomsg>IsEmbedding_funcofmembers is defined</infomsg>	";
            responses[i]=data;
          

            i = 450;
            data = "<infomsg>is_valid_presentation is defined</infomsg>	";
            responses[i]=data;
          

            i = 451;
            data = "";
            responses[i]=data;
          

            i = 452;
            data = "";
            responses[i]=data;
          

            i = 453;
            data = "";
            responses[i]=data;
          

            i = 454;
            data = "";
            responses[i]=data;
          

            i = 455;
            data = "";
            responses[i]=data;
          

            i = 456;
            data = "";
            responses[i]=data;
          

            i = 457;
            data = "";
            responses[i]=data;
          

            i = 458;
            data = "1 subgoal (ID 423)	  	  ua : Univalence	  ============================	  forall x y : V, x ⊆ y * y ⊆ x <-> x = y	";
            responses[i]=data;
          

            i = 459;
            data = "";
            responses[i]=data;
          

            i = 460;
            data = "1 subgoal (ID 605)	  	  ua : Univalence	  ============================	  forall (A : Type) (f : A -> V),	  (forall (a : A) (y : V), f a ⊆ y * y ⊆ f a <-> f a = y) ->	  forall y : V, set f ⊆ y * y ⊆ set f <-> set f = y	";
            responses[i]=data;
          

            i = 461;
            data = "1 subgoal (ID 609)	  	  ua : Univalence	  A : Type	  f : A -> V	  ============================	  forall y : V, set f ⊆ y * y ⊆ set f <-> set f = y	";
            responses[i]=data;
          

            i = 462;
            data = "1 subgoal (ID 758)	  	  ua : Univalence	  A : Type	  f : A -> V	  ============================	  forall (A0 : Type) (f0 : A0 -> V),	  (forall a : A0, set f ⊆ f0 a * f0 a ⊆ set f <-> set f = f0 a) ->	  set f ⊆ set f0 * set f0 ⊆ set f <-> set f = set f0	";
            responses[i]=data;
          

            i = 463;
            data = "1 subgoal (ID 762)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  ============================	  set f ⊆ set g * set g ⊆ set f <-> set f = set g	";
            responses[i]=data;
          

            i = 464;
            data = "2 subgoals (ID 764)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  ============================	  set f ⊆ set g * set g ⊆ set f -> set f = set g		subgoal 2 (ID 765) is:	 set f = set g -> set f ⊆ set g * set g ⊆ set f	";
            responses[i]=data;
          

            i = 465;
            data = "1 subgoal (ID 764)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  ============================	  set f ⊆ set g * set g ⊆ set f -> set f = set g	1 subgoal (ID 770)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  ============================	  set f = set g	";
            responses[i]=data;
          

            i = 466;
            data = "1 subgoal (ID 773)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  ============================	  equal_img f g	";
            responses[i]=data;
          

            i = 467;
            data = "2 subgoals (ID 775)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  ============================	  forall a : A, hexists (fun b : B => f a = g b)		subgoal 2 (ID 776) is:	 forall b : B, hexists (fun a : A => f a = g b)	";
            responses[i]=data;
          

            i = 468;
            data = "1 subgoal (ID 775)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  ============================	  forall a : A, hexists (fun b : B => f a = g b)	1 subgoal (ID 777)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  a : A	  ============================	  hexists (fun b : B => f a = g b)	";
            responses[i]=data;
          

            i = 469;
            data = "1 subgoal (ID 795)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  a : A	  ============================	  {a0 : B & g a0 = f a} -> hexists (fun b : B => f a = g b)	";
            responses[i]=data;
          

            i = 470;
            data = "1 subgoal (ID 800)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  a : A	  b : B	  p : g b = f a	  ============================	  hexists (fun b0 : B => f a = g b0)	";
            responses[i]=data;
          

            i = 471;
            data = "1 subgoal (ID 803)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  a : A	  b : B	  p : g b = f a	  ============================	  {b0 : B & f a = g b0}	";
            responses[i]=data;
          

            i = 472;
            data = "1 subgoal (ID 805)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  a : A	  b : B	  p : g b = f a	  ============================	  f a = g b	";
            responses[i]=data;
          

            i = 473;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 subgoals (ID 776)		subgoal 1 (ID 776) is:	 forall b : B, hexists (fun a : A => f a = g b)	subgoal 2 (ID 765) is:	 set f = set g -> set f ⊆ set g * set g ⊆ set f	";
            responses[i]=data;
          

            i = 474;
            data = "1 subgoal (ID 776)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  ============================	  forall b : B, hexists (fun a : A => f a = g b)	1 subgoal (ID 809)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  b : B	  ============================	  hexists (fun a : A => f a = g b)	";
            responses[i]=data;
          

            i = 475;
            data = "1 subgoal (ID 810)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  H1 : set f ⊆ set g	  H2 : set g ⊆ set f	  b : B	  ============================	  g b ∈ set g	";
            responses[i]=data;
          

            i = 476;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 765)		subgoal 1 (ID 765) is:	 set f = set g -> set f ⊆ set g * set g ⊆ set f	";
            responses[i]=data;
          

            i = 477;
            data = "1 subgoal (ID 765)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  ============================	  set f = set g -> set f ⊆ set g * set g ⊆ set f	2 subgoals (ID 819)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  p : set f = set g	  ============================	  set f ⊆ set g		subgoal 2 (ID 820) is:	 set g ⊆ set f	";
            responses[i]=data;
          

            i = 478;
            data = "1 subgoal (ID 819)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  p : set f = set g	  ============================	  set f ⊆ set g	1 subgoal (ID 823)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  p : set f = set g	  z : V	  Hz : z ∈ set f	  ============================	  z ∈ set g	";
            responses[i]=data;
          

            i = 479;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 subgoal (ID 820)		subgoal 1 (ID 820) is:	 set g ⊆ set f	";
            responses[i]=data;
          

            i = 480;
            data = "1 subgoal (ID 820)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  p : set f = set g	  ============================	  set g ⊆ set f	1 subgoal (ID 830)	  	  ua : Univalence	  A : Type	  f : A -> V	  B : Type	  g : B -> V	  p : set f = set g	  z : V	  Hz : z ∈ set g	  ============================	  z ∈ set f	";
            responses[i]=data;
          

            i = 481;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 482;
            data = "";
            responses[i]=data;
          

            i = 483;
            data = "1 subgoal (ID 428)	  	  ua : Univalence	  C : V -> hProp	  ============================	  (forall v : V, (forall x : V, x ∈ v -> C x) -> C v) -> forall v : V, C v	";
            responses[i]=data;
          

            i = 484;
            data = "";
            responses[i]=data;
          

            i = 485;
            data = "1 subgoal (ID 429)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  ============================	  forall v : V, C v	";
            responses[i]=data;
          

            i = 486;
            data = "1 subgoal (ID 448)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  ============================	  forall (A : Type) (f : A -> V), (forall a : A, C (f a)) -> C (set f)	";
            responses[i]=data;
          

            i = 487;
            data = "1 subgoal (ID 451)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  A : Type	  f : A -> V	  H_f : forall a : A, C (f a)	  ============================	  C (set f)	";
            responses[i]=data;
          

            i = 488;
            data = "1 subgoal (ID 452)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  A : Type	  f : A -> V	  H_f : forall a : A, C (f a)	  ============================	  forall x : V, x ∈ set f -> C x	";
            responses[i]=data;
          

            i = 489;
            data = "1 subgoal (ID 454)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  A : Type	  f : A -> V	  H_f : forall a : A, C (f a)	  x : V	  Hx : x ∈ set f	  ============================	  C x	";
            responses[i]=data;
          

            i = 490;
            data = "1 subgoal (ID 460)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  A : Type	  f : A -> V	  H_f : forall a : A, C (f a)	  x : V	  Hx : x ∈ set f	  ============================	  {a : A & f a = x} -> C x	";
            responses[i]=data;
          

            i = 491;
            data = "1 subgoal (ID 465)	  	  ua : Univalence	  C : V -> hProp	  H : forall v : V, (forall x : V, x ∈ v -> C x) -> C v	  A : Type	  f : A -> V	  H_f : forall a : A, C (f a)	  x : V	  Hx : x ∈ set f	  a : A	  p : f a = x	  ============================	  C x	";
            responses[i]=data;
          

            i = 492;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 493;
            data = "";
            responses[i]=data;
          

            i = 494;
            data = "";
            responses[i]=data;
          

            i = 495;
            data = "";
            responses[i]=data;
          

            i = 496;
            data = "";
            responses[i]=data;
          

            i = 497;
            data = "";
            responses[i]=data;
          

            i = 498;
            data = "";
            responses[i]=data;
          

            i = 499;
            data = "";
            responses[i]=data;
          

            i = 500;
            data = "";
            responses[i]=data;
          

            i = 501;
            data = "1 subgoal (ID 430)	  	  ua : Univalence	  ============================	  Irreflexive (fun x x0 : V => x ∈ x0)	";
            responses[i]=data;
          

            i = 502;
            data = "";
            responses[i]=data;
          

            i = 503;
            data = "2 subgoals (ID 433)	  	  ua : Univalence	  ============================	  forall v : V, IsHProp (complement (fun x x0 : V => x ∈ x0) v v)		subgoal 2 (ID 434) is:	 Irreflexive (fun x x0 : V => x ∈ x0)	";
            responses[i]=data;
          

            i = 504;
            data = "1 subgoal (ID 433)	  	  ua : Univalence	  ============================	  forall v : V, IsHProp (complement (fun x x0 : V => x ∈ x0) v v)	1 subgoal (ID 435)	  	  ua : Univalence	  v : V	  ============================	  IsHProp (complement (fun x x0 : V => x ∈ x0) v v)	";
            responses[i]=data;
          

            i = 505;
            data = "1 subgoal (ID 437)	  	  ua : Univalence	  v : V	  ============================	  IsHProp (~ v ∈ v)	";
            responses[i]=data;
          

            i = 506;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 subgoal (ID 434)		subgoal 1 (ID 434) is:	 Irreflexive (fun x x0 : V => x ∈ x0)	1 subgoal (ID 434)	  	  ua : Univalence	  X : forall v : V, IsHProp (complement (fun x x0 : V => x ∈ x0) v v)	  ============================	  Irreflexive (fun x x0 : V => x ∈ x0)	1 subgoal (ID 478)	  	  ua : Univalence	  X : forall v : V, IsHProp (complement (fun x x0 : V => x ∈ x0) v v)	  ============================	  forall v : V, (forall x : V, x ∈ v -> ~ x ∈ x) -> ~ v ∈ v	";
            responses[i]=data;
          

            i = 507;
            data = "1 subgoal (ID 480)	  	  ua : Univalence	  X : forall v : V, IsHProp (complement (fun x x0 : V => x ∈ x0) v v)	  v : V	  H : forall x : V, x ∈ v -> ~ x ∈ x	  ============================	  ~ v ∈ v	";
            responses[i]=data;
          

            i = 508;
            data = "1 subgoal (ID 482)	  	  ua : Univalence	  X : forall v : V, IsHProp (complement (fun x x0 : V => x ∈ x0) v v)	  v : V	  H : forall x : V, x ∈ v -> ~ x ∈ x	  Hv : v ∈ v	  ============================	  Empty	";
            responses[i]=data;
          

            i = 509;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 510;
            data = "";
            responses[i]=data;
          

            i = 511;
            data = "1 subgoal (ID 444)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  ============================	  set f = set g -> equal_img f g	";
            responses[i]=data;
          

            i = 512;
            data = "";
            responses[i]=data;
          

            i = 513;
            data = "1 subgoal (ID 445)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  ============================	  equal_img f g	";
            responses[i]=data;
          

            i = 514;
            data = "2 subgoals (ID 447)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  ============================	  forall a : A, hexists (fun b : B => f a = g b)		subgoal 2 (ID 448) is:	 forall b : B, hexists (fun a : A => f a = g b)	";
            responses[i]=data;
          

            i = 515;
            data = "1 subgoal (ID 447)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  ============================	  forall a : A, hexists (fun b : B => f a = g b)	1 subgoal (ID 449)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  ============================	  hexists (fun b : B => f a = g b)	";
            responses[i]=data;
          

            i = 516;
            data = "2 subgoals (ID 451)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  ============================	  f a ∈ set g		subgoal 2 (ID 453) is:	 hexists (fun b : B => f a = g b)	";
            responses[i]=data;
          

            i = 517;
            data = "1 subgoal (ID 451)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  ============================	  f a ∈ set g	1 subgoal (ID 461)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  ============================	  f a ∈ set f	";
            responses[i]=data;
          

            i = 518;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	2 subgoals (ID 453)		subgoal 1 (ID 453) is:	 hexists (fun b : B => f a = g b)	subgoal 2 (ID 448) is:	 forall b : B, hexists (fun a : A => f a = g b)	1 subgoal (ID 453)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  H : f a ∈ set g	  ============================	  hexists (fun b : B => f a = g b)	1 subgoal (ID 471)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  H : f a ∈ set g	  ============================	  {a0 : B & g a0 = f a} -> {b : B & f a = g b}	";
            responses[i]=data;
          

            i = 519;
            data = "1 subgoal (ID 476)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  a : A	  H : f a ∈ set g	  b : B	  p' : g b = f a	  ============================	  {b0 : B & f a = g b0}	";
            responses[i]=data;
          

            i = 520;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 448)		subgoal 1 (ID 448) is:	 forall b : B, hexists (fun a : A => f a = g b)	";
            responses[i]=data;
          

            i = 521;
            data = "1 subgoal (ID 448)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  ============================	  forall b : B, hexists (fun a : A => f a = g b)	1 subgoal (ID 482)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  ============================	  hexists (fun a : A => f a = g b)	";
            responses[i]=data;
          

            i = 522;
            data = "2 subgoals (ID 484)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  ============================	  g b ∈ set f		subgoal 2 (ID 486) is:	 hexists (fun a : A => f a = g b)	";
            responses[i]=data;
          

            i = 523;
            data = "1 subgoal (ID 484)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  ============================	  g b ∈ set f	1 subgoal (ID 497)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  ============================	  g b ∈ set g	";
            responses[i]=data;
          

            i = 524;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 subgoal (ID 486)		subgoal 1 (ID 486) is:	 hexists (fun a : A => f a = g b)	1 subgoal (ID 486)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  H : g b ∈ set f	  ============================	  hexists (fun a : A => f a = g b)	1 subgoal (ID 507)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  H : g b ∈ set f	  ============================	  {a : A & f a = g b} -> {a : A & f a = g b}	";
            responses[i]=data;
          

            i = 525;
            data = "1 subgoal (ID 512)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  p : set f = set g	  b : B	  H : g b ∈ set f	  a : A	  p' : f a = g b	  ============================	  {a0 : A & f a0 = g b}	";
            responses[i]=data;
          

            i = 526;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 527;
            data = "";
            responses[i]=data;
          

            i = 528;
            data = "";
            responses[i]=data;
          

            i = 529;
            data = "";
            responses[i]=data;
          

            i = 530;
            data = "";
            responses[i]=data;
          

            i = 531;
            data = "";
            responses[i]=data;
          

            i = 532;
            data = "";
            responses[i]=data;
          

            i = 533;
            data = "";
            responses[i]=data;
          

            i = 534;
            data = "";
            responses[i]=data;
          

            i = 535;
            data = "";
            responses[i]=data;
          

            i = 536;
            data = "";
            responses[i]=data;
          

            i = 537;
            data = "<infomsg>V_empty is defined</infomsg>	";
            responses[i]=data;
          

            i = 538;
            data = "";
            responses[i]=data;
          

            i = 539;
            data = "";
            responses[i]=data;
          

            i = 540;
            data = "";
            responses[i]=data;
          

            i = 541;
            data = "";
            responses[i]=data;
          

            i = 542;
            data = "<infomsg>V_singleton is defined</infomsg>	";
            responses[i]=data;
          

            i = 543;
            data = "1 subgoal (ID 457)	  	  ua : Univalence	  u, v : V	  ============================	  IsEquiv (ap V_singleton)	";
            responses[i]=data;
          

            i = 544;
            data = "";
            responses[i]=data;
          

            i = 545;
            data = "1 subgoal (ID 465)	  	  ua : Univalence	  u, v : V	  ============================	  V_singleton u = V_singleton v -> u = v	";
            responses[i]=data;
          

            i = 546;
            data = "1 subgoal (ID 465)	  	  ua : Univalence	  u, v : V	  ============================	  V_singleton u = V_singleton v -> u = v	1 subgoal (ID 641)	  	  ua : Univalence	  u, v : V	  H : V_singleton u = V_singleton v	  ============================	  u = v	";
            responses[i]=data;
          

            i = 547;
            data = "1 subgoal (ID 646)	  	  ua : Univalence	  u, v : V	  H : V_singleton u = V_singleton v	  ============================	  equal_img (Unit_ind u) (Unit_ind v) -> u = v	";
            responses[i]=data;
          

            i = 548;
            data = "1 subgoal (ID 652)	  	  ua : Univalence	  u, v : V	  H : V_singleton u = V_singleton v	  H1 : forall a : Unit, hexists (fun b : Unit => Unit_ind u a = Unit_ind v b)	  H2 : forall b : Unit, hexists (fun a : Unit => Unit_ind u a = Unit_ind v b)	  ============================	  u = v	";
            responses[i]=data;
          

            i = 549;
            data = "1 subgoal (ID 681)	  	  ua : Univalence	  u, v : V	  H : V_singleton u = V_singleton v	  H1 : forall a : Unit, hexists (fun b : Unit => Unit_ind u a = Unit_ind v b)	  H2 : forall b : Unit, hexists (fun a : Unit => Unit_ind u a = Unit_ind v b)	  ============================	  {b : Unit & Unit_ind u tt = Unit_ind v b} -> u = v	";
            responses[i]=data;
          

            i = 550;
            data = "1 subgoal (ID 686)	  	  ua : Univalence	  u, v : V	  H : V_singleton u = V_singleton v	  H1 : forall a : Unit, hexists (fun b : Unit => Unit_ind u a = Unit_ind v b)	  H2 : forall b : Unit, hexists (fun a : Unit => Unit_ind u a = Unit_ind v b)	  t : Unit	  p : Unit_ind u tt = Unit_ind v t	  ============================	  u = v	";
            responses[i]=data;
          

            i = 551;
            data = "No more subgoals.	No more subgoals.	";
            responses[i]=data;
          

            i = 552;
            data = "";
            responses[i]=data;
          

            i = 553;
            data = "";
            responses[i]=data;
          

            i = 554;
            data = "";
            responses[i]=data;
          

            i = 555;
            data = "";
            responses[i]=data;
          

            i = 556;
            data = "<infomsg>V_pair is defined</infomsg>	";
            responses[i]=data;
          

            i = 557;
            data = "1 subgoal (ID 469)	  	  ua : Univalence	  u, v, u', v' : V	  ============================	  (u = u') * (v = v') -> V_pair u v = V_pair u' v'	";
            responses[i]=data;
          

            i = 558;
            data = "";
            responses[i]=data;
          

            i = 559;
            data = "1 subgoal (ID 474)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  V_pair u v = V_pair u' v'	";
            responses[i]=data;
          

            i = 560;
            data = "1 subgoal (ID 477)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  equal_img (fun b : Bool => if b then u else v)	    (fun b : Bool => if b then u' else v')	";
            responses[i]=data;
          

            i = 561;
            data = "2 subgoals (ID 479)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  forall a : Bool,	  hexists (fun b : Bool => (if a then u else v) = (if b then u' else v'))		subgoal 2 (ID 480) is:	 forall b : Bool,	 hexists (fun a : Bool => (if a then u else v) = (if b then u' else v'))	";
            responses[i]=data;
          

            i = 562;
            data = "1 subgoal (ID 479)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  forall a : Bool,	  hexists (fun b : Bool => (if a then u else v) = (if b then u' else v'))	2 subgoals (ID 481)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  hexists (fun b : Bool => u = (if b then u' else v'))		subgoal 2 (ID 482) is:	 hexists (fun b : Bool => v = (if b then u' else v'))	";
            responses[i]=data;
          

            i = 563;
            data = "1 subgoal (ID 481)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  hexists (fun b : Bool => u = (if b then u' else v'))	1 subgoal (ID 487)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  u = u'	";
            responses[i]=data;
          

            i = 564;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	2 subgoals (ID 482)		subgoal 1 (ID 482) is:	 hexists (fun b : Bool => v = (if b then u' else v'))	subgoal 2 (ID 480) is:	 forall b : Bool,	 hexists (fun a : Bool => (if a then u else v) = (if b then u' else v'))	";
            responses[i]=data;
          

            i = 565;
            data = "1 subgoal (ID 482)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  hexists (fun b : Bool => v = (if b then u' else v'))	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 subgoal (ID 480)		subgoal 1 (ID 480) is:	 forall b : Bool,	 hexists (fun a : Bool => (if a then u else v) = (if b then u' else v'))	";
            responses[i]=data;
          

            i = 566;
            data = "1 subgoal (ID 480)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  forall b : Bool,	  hexists (fun a : Bool => (if a then u else v) = (if b then u' else v'))	2 subgoals (ID 493)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  hexists (fun a : Bool => (if a then u else v) = u')		subgoal 2 (ID 494) is:	 hexists (fun a : Bool => (if a then u else v) = v')	";
            responses[i]=data;
          

            i = 567;
            data = "1 subgoal (ID 493)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  hexists (fun a : Bool => (if a then u else v) = u')	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	1 subgoal (ID 494)		subgoal 1 (ID 494) is:	 hexists (fun a : Bool => (if a then u else v) = v')	";
            responses[i]=data;
          

            i = 568;
            data = "1 subgoal (ID 494)	  	  ua : Univalence	  u, v, u', v' : V	  H1 : u = u'	  H2 : v = v'	  ============================	  hexists (fun a : Bool => (if a then u else v) = v')	No more subgoals.	";
            responses[i]=data;
          

            i = 569;
            data = "";
            responses[i]=data;
          

            i = 570;
            data = "1 subgoal (ID 479)	  	  ua : Univalence	  u, v, w : V	  ============================	  V_pair u v = V_singleton w <-> (u = w) * (v = w)	";
            responses[i]=data;
          

            i = 571;
            data = "";
            responses[i]=data;
          

            i = 572;
            data = "2 subgoals (ID 481)	  	  ua : Univalence	  u, v, w : V	  ============================	  V_pair u v = V_singleton w -> (u = w) * (v = w)		subgoal 2 (ID 482) is:	 (u = w) * (v = w) -> V_pair u v = V_singleton w	";
            responses[i]=data;
          

            i = 573;
            data = "1 subgoal (ID 481)	  	  ua : Univalence	  u, v, w : V	  ============================	  V_pair u v = V_singleton w -> (u = w) * (v = w)	1 subgoal (ID 483)	  	  ua : Univalence	  u, v, w : V	  H : V_pair u v = V_singleton w	  ============================	  (u = w) * (v = w)	";
            responses[i]=data;
          

            i = 574;
            data = "1 subgoal (ID 493)	  	  ua : Univalence	  u, v, w : V	  H : V_pair u v = V_singleton w	  H1 : forall a : Bool,	       hexists (fun b : Unit => (if a then u else v) = Unit_ind w b)	  H2 : forall b : Unit,	       hexists (fun a : Bool => (if a then u else v) = Unit_ind w b)	  ============================	  (u = w) * (v = w)	";
            responses[i]=data;
          

            i = 575;
            data = "1 subgoal (ID 566)	  	  ua : Univalence	  u, v, w : V	  H : V_pair u v = V_singleton w	  H1 : forall a : Bool,	       hexists (fun b : Unit => (if a then u else v) = Unit_ind w b)	  H2 : forall b : Unit,	       hexists (fun a : Bool => (if a then u else v) = Unit_ind w b)	  ============================	  {b : Unit & u = Unit_ind w b} -> (u = w) * (v = w)	";
            responses[i]=data;
          

            i = 576;
            data = "1 subgoal (ID 577)	  	  ua : Univalence	  u, v, w : V	  H : V_pair u v = V_singleton w	  H1 : forall a : Bool,	       hexists (fun b : Unit => (if a then u else v) = Unit_ind w b)	  H2 : forall b : Unit,	       hexists (fun a : Bool => (if a then u else v) = Unit_ind w b)	  p : u = Unit_ind w tt	  ============================	  (u = w) * (v = w)	";
            responses[i]=data;
          

            i = 577;
            data = "1 subgoal (ID 650)	  	  ua : Univalence	  u, v, w : V	  H : V_pair u v = V_singleton w	  H1 : forall a : Bool,	       hexists (fun b : Unit => (if a then u else v) = Unit_ind w b)	  H2 : forall b : Unit,	       hexists (fun a : Bool => (if a then u else v) = Unit_ind w b)	  p : u = Unit_ind w tt	  ============================	  {b : Unit & v = Unit_ind w b} -> (u = w) * (v = w)	";
            responses[i]=data;
          

            i = 578;
            data = "1 subgoal (ID 661)	  	  ua : Univalence	  u, v, w : V	  H : V_pair u v = V_singleton w	  H1 : forall a : Bool,	       hexists (fun b : Unit => (if a then u else v) = Unit_ind w b)	  H2 : forall b : Unit,	       hexists (fun a : Bool => (if a then u else v) = Unit_ind w b)	  p : u = Unit_ind w tt	  p' : v = Unit_ind w tt	  ============================	  (u = w) * (v = w)	";
            responses[i]=data;
          

            i = 579;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 subgoal (ID 482)		subgoal 1 (ID 482) is:	 (u = w) * (v = w) -> V_pair u v = V_singleton w	";
            responses[i]=data;
          

            i = 580;
            data = "1 subgoal (ID 482)	  	  ua : Univalence	  u, v, w : V	  ============================	  (u = w) * (v = w) -> V_pair u v = V_singleton w	1 subgoal (ID 669)	  	  ua : Univalence	  u, v, w : V	  p1 : u = w	  p2 : v = w	  ============================	  V_pair u v = V_singleton w	";
            responses[i]=data;
          

            i = 581;
            data = "2 subgoals (ID 674)	  	  ua : Univalence	  u, v, w : V	  p1 : u = w	  p2 : v = w	  ============================	  forall a : Bool,	  hexists (fun b : Unit => (if a then u else v) = Unit_ind w b)		subgoal 2 (ID 675) is:	 forall b : Unit,	 hexists (fun a : Bool => (if a then u else v) = Unit_ind w b)	";
            responses[i]=data;
          

            i = 582;
            data = "1 subgoal (ID 674)	  	  ua : Univalence	  u, v, w : V	  p1 : u = w	  p2 : v = w	  ============================	  forall a : Bool,	  hexists (fun b : Unit => (if a then u else v) = Unit_ind w b)	1 subgoal (ID 681)	  	  ua : Univalence	  u, v, w : V	  p1 : u = w	  p2 : v = w	  a : Bool	  ============================	  (if a then u else v) = Unit_ind w tt	";
            responses[i]=data;
          

            i = 583;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	1 subgoal (ID 675)		subgoal 1 (ID 675) is:	 forall b : Unit,	 hexists (fun a : Bool => (if a then u else v) = Unit_ind w b)	";
            responses[i]=data;
          

            i = 584;
            data = "1 subgoal (ID 675)	  	  ua : Univalence	  u, v, w : V	  p1 : u = w	  p2 : v = w	  ============================	  forall b : Unit,	  hexists (fun a : Bool => (if a then u else v) = Unit_ind w b)	1 subgoal (ID 692)	  	  ua : Univalence	  u, v, w : V	  p1 : u = w	  p2 : v = w	  t : Unit	  ============================	  u = Unit_ind w t	";
            responses[i]=data;
          

            i = 585;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 586;
            data = "";
            responses[i]=data;
          

            i = 587;
            data = "";
            responses[i]=data;
          

            i = 588;
            data = "";
            responses[i]=data;
          

            i = 589;
            data = "";
            responses[i]=data;
          

            i = 590;
            data = "";
            responses[i]=data;
          

            i = 591;
            data = "<infomsg>V_pair_ord is defined</infomsg>	";
            responses[i]=data;
          

            i = 592;
            data = "";
            responses[i]=data;
          

            i = 593;
            data = "1 subgoal (ID 490)	  	  ua : Univalence	  a, b, c, d : V	  ============================	  [a, b] = [c, d] <-> (a = c) * (b = d)	";
            responses[i]=data;
          

            i = 594;
            data = "";
            responses[i]=data;
          

            i = 595;
            data = "2 subgoals (ID 492)	  	  ua : Univalence	  a, b, c, d : V	  ============================	  [a, b] = [c, d] -> (a = c) * (b = d)		subgoal 2 (ID 493) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	";
            responses[i]=data;
          

            i = 596;
            data = "1 subgoal (ID 492)	  	  ua : Univalence	  a, b, c, d : V	  ============================	  [a, b] = [c, d] -> (a = c) * (b = d)	1 subgoal (ID 494)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  ============================	  (a = c) * (b = d)	";
            responses[i]=data;
          

            i = 597;
            data = "2 subgoals (ID 497)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  ============================	  a = c		subgoal 2 (ID 499) is:	 (a = c) * (b = d)	";
            responses[i]=data;
          

            i = 598;
            data = "1 subgoal (ID 497)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  ============================	  a = c	2 subgoals (ID 500)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  ============================	  V_singleton a ∈ [c, d]		subgoal 2 (ID 502) is:	 a = c	";
            responses[i]=data;
          

            i = 599;
            data = "1 subgoal (ID 500)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  ============================	  V_singleton a ∈ [c, d]	1 subgoal (ID 510)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  ============================	  V_singleton a ∈ [a, b]	";
            responses[i]=data;
          

            i = 600;
            data = "1 subgoal (ID 513)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  ============================	  Trunc (-1)	    {a0 : Bool & (if a0 then V_singleton a else V_pair a b) = V_singleton a}	";
            responses[i]=data;
          

            i = 601;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	3 subgoals (ID 502)		subgoal 1 (ID 502) is:	 a = c	subgoal 2 (ID 499) is:	 (a = c) * (b = d)	subgoal 3 (ID 493) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	1 subgoal (ID 502)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  H : V_singleton a ∈ [c, d]	  ============================	  a = c	1 subgoal (ID 548)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  H : V_singleton a ∈ [c, d]	  ============================	  {a0 : Bool & (if a0 then V_singleton c else V_pair c d) = V_singleton a} ->	  a = c	";
            responses[i]=data;
          

            i = 602;
            data = "2 subgoals (ID 562)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  H : V_singleton a ∈ [c, d]	  p' : V_singleton c = V_singleton a	  ============================	  a = c		subgoal 2 (ID 563) is:	 a = c	";
            responses[i]=data;
          

            i = 603;
            data = "1 subgoal (ID 562)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  H : V_singleton a ∈ [c, d]	  p' : V_singleton c = V_singleton a	  ============================	  a = c	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	3 subgoals (ID 563)		subgoal 1 (ID 563) is:	 a = c	subgoal 2 (ID 499) is:	 (a = c) * (b = d)	subgoal 3 (ID 493) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	";
            responses[i]=data;
          

            i = 604;
            data = "1 subgoal (ID 563)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  H : V_singleton a ∈ [c, d]	  p' : V_pair c d = V_singleton a	  ============================	  a = c	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 subgoals (ID 499)		subgoal 1 (ID 499) is:	 (a = c) * (b = d)	subgoal 2 (ID 493) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	";
            responses[i]=data;
          

            i = 605;
            data = "1 subgoal (ID 499)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	  (a = c) * (b = d)	2 subgoals (ID 597)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	  a = c		subgoal 2 (ID 598) is:	 b = d	";
            responses[i]=data;
          

            i = 606;
            data = "1 subgoal (ID 597)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	  a = c	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	2 subgoals (ID 598)		subgoal 1 (ID 598) is:	 b = d	subgoal 2 (ID 493) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	";
            responses[i]=data;
          

            i = 607;
            data = "1 subgoal (ID 598)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	  b = d	2 subgoals (ID 603)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	  b = c \/ b = d		subgoal 2 (ID 605) is:	 b = d	";
            responses[i]=data;
          

            i = 608;
            data = "1 subgoal (ID 603)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	  b = c \/ b = d	2 subgoals (ID 606)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	  V_pair a b ∈ [c, d]		subgoal 2 (ID 608) is:	 b = c \/ b = d	";
            responses[i]=data;
          

            i = 609;
            data = "1 subgoal (ID 606)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	  V_pair a b ∈ [c, d]	1 subgoal (ID 616)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  ============================	  V_pair a b ∈ [a, b]	";
            responses[i]=data;
          

            i = 610;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	3 subgoals (ID 608)		subgoal 1 (ID 608) is:	 b = c \/ b = d	subgoal 2 (ID 605) is:	 b = d	subgoal 3 (ID 493) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	1 subgoal (ID 608)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  ============================	  b = c \/ b = d	1 subgoal (ID 631)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  ============================	  {a0 : Bool & (if a0 then V_singleton c else V_pair c d) = V_pair a b} ->	  b = c \/ b = d	";
            responses[i]=data;
          

            i = 611;
            data = "2 subgoals (ID 645)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_singleton c = V_pair a b	  ============================	  b = c \/ b = d		subgoal 2 (ID 646) is:	 b = c \/ b = d	";
            responses[i]=data;
          

            i = 612;
            data = "1 subgoal (ID 645)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_singleton c = V_pair a b	  ============================	  b = c \/ b = d	1 subgoal (ID 651)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_singleton c = V_pair a b	  ============================	  b = c	";
            responses[i]=data;
          

            i = 613;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	3 subgoals (ID 646)		subgoal 1 (ID 646) is:	 b = c \/ b = d	subgoal 2 (ID 605) is:	 b = d	subgoal 3 (ID 493) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	";
            responses[i]=data;
          

            i = 614;
            data = "1 subgoal (ID 646)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_pair c d = V_pair a b	  ============================	  b = c \/ b = d	1 subgoal (ID 673)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_pair c d = V_pair a b	  H1 : forall a0 : Bool,	       hexists	         (fun b0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  H2 : forall b0 : Bool,	       hexists	         (fun a0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  ============================	  b = c \/ b = d	";
            responses[i]=data;
          

            i = 615;
            data = "1 subgoal (ID 677)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_pair c d = V_pair a b	  H1 : forall a0 : Bool,	       hexists	         (fun b0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  H2 : forall b0 : Bool,	       hexists	         (fun a0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  ============================	  {a0 : Bool & (if a0 then c else d) = b} -> (b = c) + (b = d)	";
            responses[i]=data;
          

            i = 616;
            data = "2 subgoals (ID 691)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_pair c d = V_pair a b	  H1 : forall a0 : Bool,	       hexists	         (fun b0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  H2 : forall b0 : Bool,	       hexists	         (fun a0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  p'' : c = b	  ============================	  (b = c) + (b = d)		subgoal 2 (ID 692) is:	 (b = c) + (b = d)	";
            responses[i]=data;
          

            i = 617;
            data = "1 subgoal (ID 691)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_pair c d = V_pair a b	  H1 : forall a0 : Bool,	       hexists	         (fun b0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  H2 : forall b0 : Bool,	       hexists	         (fun a0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  p'' : c = b	  ============================	  (b = c) + (b = d)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	3 subgoals (ID 692)		subgoal 1 (ID 692) is:	 (b = c) + (b = d)	subgoal 2 (ID 605) is:	 b = d	subgoal 3 (ID 493) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	";
            responses[i]=data;
          

            i = 618;
            data = "1 subgoal (ID 692)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H' : V_pair a b ∈ [c, d]	  p' : V_pair c d = V_pair a b	  H1 : forall a0 : Bool,	       hexists	         (fun b0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  H2 : forall b0 : Bool,	       hexists	         (fun a0 : Bool => (if a0 then c else d) = (if b0 then a else b))	  p'' : d = b	  ============================	  (b = c) + (b = d)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	2 subgoals (ID 605)		subgoal 1 (ID 605) is:	 b = d	subgoal 2 (ID 493) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	1 subgoal (ID 605)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : b = c \/ b = d	  ============================	  b = d	1 subgoal (ID 731)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : b = c \/ b = d	  ============================	  (b = c) + (b = d) -> b = d	";
            responses[i]=data;
          

            i = 619;
            data = "2 subgoals (ID 738)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : b = c \/ b = d	  p' : b = c	  ============================	  b = d		subgoal 2 (ID 739) is:	 b = d	";
            responses[i]=data;
          

            i = 620;
            data = "1 subgoal (ID 738)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : b = c \/ b = d	  p' : b = c	  ============================	  b = d	";
            responses[i]=data;
          

            i = 621;
            data = "2 subgoals (ID 742)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : b = c \/ b = d	  p' : b = c	  ============================	  [a, b] = V_singleton (V_singleton b)		subgoal 2 (ID 744) is:	 b = d	";
            responses[i]=data;
          

            i = 622;
            data = "1 subgoal (ID 742)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : b = c \/ b = d	  p' : b = c	  ============================	  [a, b] = V_singleton (V_singleton b)	1 subgoal (ID 750)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : b = c \/ b = d	  p' : b = c	  ============================	  (V_singleton a = V_singleton b) * (V_pair a b = V_singleton b)	";
            responses[i]=data;
          

            i = 623;
            data = "2 subgoals (ID 752)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : b = c \/ b = d	  p' : b = c	  ============================	  V_singleton a = V_singleton b		subgoal 2 (ID 753) is:	 V_pair a b = V_singleton b	";
            responses[i]=data;
          

            i = 624;
            data = "1 subgoal (ID 752)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : b = c \/ b = d	  p' : b = c	  ============================	  V_singleton a = V_singleton b	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	3 subgoals (ID 753)		subgoal 1 (ID 753) is:	 V_pair a b = V_singleton b	subgoal 2 (ID 744) is:	 b = d	subgoal 3 (ID 493) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	";
            responses[i]=data;
          

            i = 625;
            data = "1 subgoal (ID 753)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : b = c \/ b = d	  p' : b = c	  ============================	  V_pair a b = V_singleton b	1 subgoal (ID 769)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : b = c \/ b = d	  p' : b = c	  ============================	  (a = b) * (b = b)	";
            responses[i]=data;
          

            i = 626;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	2 subgoals (ID 744)		subgoal 1 (ID 744) is:	 b = d	subgoal 2 (ID 493) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	";
            responses[i]=data;
          

            i = 627;
            data = "1 subgoal (ID 744)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : b = c \/ b = d	  p' : b = c	  H' : [a, b] = V_singleton (V_singleton b)	  ============================	  b = d	1 subgoal (ID 785)	  	  ua : Univalence	  a, b, c, d : V	  p : [a, b] = [c, d]	  p1 : a = c	  H : b = c \/ b = d	  p' : b = c	  H' : [a, b] = V_singleton (V_singleton b)	  H'' : V_pair c d = V_singleton b	  ============================	  b = d	";
            responses[i]=data;
          

            i = 628;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 493)		subgoal 1 (ID 493) is:	 (a = c) * (b = d) -> [a, b] = [c, d]	";
            responses[i]=data;
          

            i = 629;
            data = "1 subgoal (ID 493)	  	  ua : Univalence	  a, b, c, d : V	  ============================	  (a = c) * (b = d) -> [a, b] = [c, d]	1 subgoal (ID 827)	  	  ua : Univalence	  a, b, c, d : V	  p : a = c	  p' : b = d	  ============================	  [a, b] = [c, d]	";
            responses[i]=data;
          

            i = 630;
            data = "1 subgoal (ID 832)	  	  ua : Univalence	  a, b, c, d : V	  p : a = c	  p' : b = d	  ============================	  (V_singleton a = V_singleton c) * (V_pair a b = V_pair c d)	";
            responses[i]=data;
          

            i = 631;
            data = "2 subgoals (ID 834)	  	  ua : Univalence	  a, b, c, d : V	  p : a = c	  p' : b = d	  ============================	  V_singleton a = V_singleton c		subgoal 2 (ID 835) is:	 V_pair a b = V_pair c d	";
            responses[i]=data;
          

            i = 632;
            data = "1 subgoal (ID 834)	  	  ua : Univalence	  a, b, c, d : V	  p : a = c	  p' : b = d	  ============================	  V_singleton a = V_singleton c	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 subgoal (ID 835)		subgoal 1 (ID 835) is:	 V_pair a b = V_pair c d	";
            responses[i]=data;
          

            i = 633;
            data = "1 subgoal (ID 835)	  	  ua : Univalence	  a, b, c, d : V	  p : a = c	  p' : b = d	  ============================	  V_pair a b = V_pair c d	1 subgoal (ID 843)	  	  ua : Univalence	  a, b, c, d : V	  p : a = c	  p' : b = d	  ============================	  (a = c) * (b = d)	";
            responses[i]=data;
          

            i = 634;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 635;
            data = "";
            responses[i]=data;
          

            i = 636;
            data = "";
            responses[i]=data;
          

            i = 637;
            data = "";
            responses[i]=data;
          

            i = 638;
            data = "";
            responses[i]=data;
          

            i = 639;
            data = "";
            responses[i]=data;
          

            i = 640;
            data = "<infomsg>V_cart_prod is defined</infomsg>	";
            responses[i]=data;
          

            i = 641;
            data = "";
            responses[i]=data;
          

            i = 642;
            data = "";
            responses[i]=data;
          

            i = 643;
            data = "";
            responses[i]=data;
          

            i = 644;
            data = "";
            responses[i]=data;
          

            i = 645;
            data = "";
            responses[i]=data;
          

            i = 646;
            data = "";
            responses[i]=data;
          

            i = 647;
            data = "";
            responses[i]=data;
          

            i = 648;
            data = "";
            responses[i]=data;
          

            i = 649;
            data = "";
            responses[i]=data;
          

            i = 650;
            data = "";
            responses[i]=data;
          

            i = 651;
            data = "<infomsg>V_func is defined</infomsg>	";
            responses[i]=data;
          

            i = 652;
            data = "";
            responses[i]=data;
          

            i = 653;
            data = "";
            responses[i]=data;
          

            i = 654;
            data = "";
            responses[i]=data;
          

            i = 655;
            data = "";
            responses[i]=data;
          

            i = 656;
            data = "<infomsg>V_union is defined</infomsg>	";
            responses[i]=data;
          

            i = 657;
            data = "";
            responses[i]=data;
          

            i = 658;
            data = "";
            responses[i]=data;
          

            i = 659;
            data = "";
            responses[i]=data;
          

            i = 660;
            data = "";
            responses[i]=data;
          

            i = 661;
            data = "1 subgoal (ID 510)	  	  ua : Univalence	  ============================	  V -> V	";
            responses[i]=data;
          

            i = 662;
            data = "";
            responses[i]=data;
          

            i = 663;
            data = "2 subgoals (ID 516)	  	  ua : Univalence	  ============================	  forall A : Type, (A -> V) -> (A -> V) -> V		subgoal 2 (ID 518) is:	 forall (A B : Type) (f : A -> V) (g : B -> V),	 equal_img f g ->	 forall (H_f : A -> V) (H_g : B -> V),	 equal_img H_f H_g -> ?H_set A f H_f = ?H_set B g H_g	";
            responses[i]=data;
          

            i = 664;
            data = "1 subgoal (ID 516)	  	  ua : Univalence	  ============================	  forall A : Type, (A -> V) -> (A -> V) -> V	1 subgoal (ID 522)	  	  ua : Univalence	  A : Type	  f : A -> V	  ============================	  V	";
            responses[i]=data;
          

            i = 665;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 518)		subgoal 1 (ID 518) is:	 forall (A B : Type) (f : A -> V) (g : B -> V),	 equal_img f g ->	 forall (H_f : A -> V) (H_g : B -> V),	 equal_img H_f H_g ->	 (fun (A0 : Type) (f0 _ : A0 -> V) =>	  set	    (fun x : A0 + Unit => match x with	                          | inl a => f0 a	                          | inr tt => set f0	                          end)) A f H_f =	 (fun (A0 : Type) (f0 _ : A0 -> V) =>	  set	    (fun x : A0 + Unit => match x with	                          | inl a => f0 a	                          | inr tt => set f0	                          end)) B g H_g	";
            responses[i]=data;
          

            i = 666;
            data = "1 subgoal (ID 518)	  	  ua : Univalence	  ============================	  forall (A B : Type) (f : A -> V) (g : B -> V),	  equal_img f g ->	  forall (H_f : A -> V) (H_g : B -> V),	  equal_img H_f H_g ->	  (fun (A0 : Type) (f0 _ : A0 -> V) =>	   set	     (fun x : A0 + Unit =>	      match x with	      | inl a => f0 a	      | inr tt => set f0	      end)) A f H_f =	  (fun (A0 : Type) (f0 _ : A0 -> V) =>	   set	     (fun x : A0 + Unit =>	      match x with	      | inl a => f0 a	      | inr tt => set f0	      end)) B g H_g	1 subgoal (ID 537)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	  set (fun x : A + Unit => match x with	                           | inl a => f a	                           | inr tt => set f	                           end) =	  set (fun x : B + Unit => match x with	                           | inl a => g a	                           | inr tt => set g	                           end)	";
            responses[i]=data;
          

            i = 667;
            data = "1 subgoal (ID 540)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	  equal_img	    (fun x : A + Unit => match x with	                         | inl a => f a	                         | inr tt => set f	                         end)	    (fun x : B + Unit => match x with	                         | inl a => g a	                         | inr tt => set g	                         end)	";
            responses[i]=data;
          

            i = 668;
            data = "2 subgoals (ID 542)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	  forall a : A + Unit,	  hexists	    (fun b : B + Unit =>	     match a with	     | inl a0 => f a0	     | inr tt => set f	     end = match b with	           | inl a0 => g a0	           | inr tt => set g	           end)		subgoal 2 (ID 543) is:	 forall b : B + Unit,	 hexists	   (fun a : A + Unit =>	    match a with	    | inl a0 => f a0	    | inr tt => set f	    end = match b with	          | inl a0 => g a0	          | inr tt => set g	          end)	";
            responses[i]=data;
          

            i = 669;
            data = "1 subgoal (ID 542)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	  forall a : A + Unit,	  hexists	    (fun b : B + Unit =>	     match a with	     | inl a0 => f a0	     | inr tt => set f	     end = match b with	           | inl a0 => g a0	           | inr tt => set g	           end)	1 subgoal (ID 544)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  a : A + Unit	  ============================	  hexists	    (fun b : B + Unit =>	     match a with	     | inl a0 => f a0	     | inr tt => set f	     end = match b with	           | inl a0 => g a0	           | inr tt => set g	           end)	";
            responses[i]=data;
          

            i = 670;
            data = "2 subgoals (ID 550)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  a : A	  ============================	  hexists	    (fun b : B + Unit =>	     f a = match b with	           | inl a0 => g a0	           | inr tt => set g	           end)		subgoal 2 (ID 551) is:	 hexists	   (fun b : B + Unit =>	    match u with	    | tt => set f	    end = match b with	          | inl a => g a	          | inr tt => set g	          end)	";
            responses[i]=data;
          

            i = 671;
            data = "1 subgoal (ID 550)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  a : A	  ============================	  hexists	    (fun b : B + Unit =>	     f a = match b with	           | inl a0 => g a0	           | inr tt => set g	           end)	1 subgoal (ID 554)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  a : A	  ============================	  hexists (fun b : B => f a = g b) ->	  hexists	    (fun b : B + Unit =>	     f a = match b with	           | inl a0 => g a0	           | inr tt => set g	           end)	";
            responses[i]=data;
          

            i = 672;
            data = "1 subgoal (ID 557)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  a : A	  ============================	  {b : B & f a = g b} ->	  {b : B + Unit & f a = match b with	                        | inl a0 => g a0	                        | inr tt => set g	                        end}	";
            responses[i]=data;
          

            i = 673;
            data = "1 subgoal (ID 562)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  a : A	  b : B	  p : f a = g b	  ============================	  {b0 : B + Unit &	  f a = match b0 with	        | inl a0 => g a0	        | inr tt => set g	        end}	";
            responses[i]=data;
          

            i = 674;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	2 subgoals (ID 551)		subgoal 1 (ID 551) is:	 hexists	   (fun b : B + Unit =>	    match u with	    | tt => set f	    end = match b with	          | inl a => g a	          | inr tt => set g	          end)	subgoal 2 (ID 543) is:	 forall b : B + Unit,	 hexists	   (fun a : A + Unit =>	    match a with	    | inl a0 => f a0	    | inr tt => set f	    end = match b with	          | inl a0 => g a0	          | inr tt => set g	          end)	";
            responses[i]=data;
          

            i = 675;
            data = "1 subgoal (ID 551)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  u : Unit	  ============================	  hexists	    (fun b : B + Unit =>	     match u with	     | tt => set f	     end = match b with	           | inl a => g a	           | inr tt => set g	           end)	1 subgoal (ID 573)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  u : Unit	  ============================	  match u with	  | tt => set f	  end = set g	";
            responses[i]=data;
          

            i = 676;
            data = "1 subgoal (ID 576)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	  set f = set g	";
            responses[i]=data;
          

            i = 677;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 subgoal (ID 543)		subgoal 1 (ID 543) is:	 forall b : B + Unit,	 hexists	   (fun a : A + Unit =>	    match a with	    | inl a0 => f a0	    | inr tt => set f	    end = match b with	          | inl a0 => g a0	          | inr tt => set g	          end)	";
            responses[i]=data;
          

            i = 678;
            data = "1 subgoal (ID 543)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	  forall b : B + Unit,	  hexists	    (fun a : A + Unit =>	     match a with	     | inl a0 => f a0	     | inr tt => set f	     end = match b with	           | inl a0 => g a0	           | inr tt => set g	           end)	1 subgoal (ID 580)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  b : B + Unit	  ============================	  hexists	    (fun a : A + Unit =>	     match a with	     | inl a0 => f a0	     | inr tt => set f	     end = match b with	           | inl a0 => g a0	           | inr tt => set g	           end)	";
            responses[i]=data;
          

            i = 679;
            data = "2 subgoals (ID 586)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  b : B	  ============================	  hexists	    (fun a : A + Unit =>	     match a with	     | inl a0 => f a0	     | inr tt => set f	     end = g b)		subgoal 2 (ID 587) is:	 hexists	   (fun a : A + Unit =>	    match a with	    | inl a0 => f a0	    | inr tt => set f	    end = match u with	          | tt => set g	          end)	";
            responses[i]=data;
          

            i = 680;
            data = "1 subgoal (ID 586)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  b : B	  ============================	  hexists	    (fun a : A + Unit =>	     match a with	     | inl a0 => f a0	     | inr tt => set f	     end = g b)	1 subgoal (ID 590)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  b : B	  ============================	  hexists (fun a : A => f a = g b) ->	  hexists	    (fun a : A + Unit =>	     match a with	     | inl a0 => f a0	     | inr tt => set f	     end = g b)	";
            responses[i]=data;
          

            i = 681;
            data = "1 subgoal (ID 593)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  b : B	  ============================	  {a : A & f a = g b} ->	  {a : A + Unit & match a with	                  | inl a0 => f a0	                  | inr tt => set f	                  end = g b}	";
            responses[i]=data;
          

            i = 682;
            data = "1 subgoal (ID 598)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  b : B	  a : A	  p : f a = g b	  ============================	  {a0 : A + Unit &	  match a0 with	  | inl a1 => f a1	  | inr tt => set f	  end = g b}	";
            responses[i]=data;
          

            i = 683;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	1 subgoal (ID 587)		subgoal 1 (ID 587) is:	 hexists	   (fun a : A + Unit =>	    match a with	    | inl a0 => f a0	    | inr tt => set f	    end = match u with	          | tt => set g	          end)	";
            responses[i]=data;
          

            i = 684;
            data = "1 subgoal (ID 587)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  u : Unit	  ============================	  hexists	    (fun a : A + Unit =>	     match a with	     | inl a0 => f a0	     | inr tt => set f	     end = match u with	           | tt => set g	           end)	1 subgoal (ID 609)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  u : Unit	  ============================	  set f = match u with	          | tt => set g	          end	";
            responses[i]=data;
          

            i = 685;
            data = "1 subgoal (ID 612)	  	  ua : Univalence	  A : Type	  B : Type	  f : A -> V	  g : B -> V	  eq_img : equal_img f g	  ============================	  set f = set g	";
            responses[i]=data;
          

            i = 686;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 687;
            data = "";
            responses[i]=data;
          

            i = 688;
            data = "";
            responses[i]=data;
          

            i = 689;
            data = "";
            responses[i]=data;
          

            i = 690;
            data = "";
            responses[i]=data;
          

            i = 691;
            data = "";
            responses[i]=data;
          

            i = 692;
            data = "<infomsg>V_omega is defined</infomsg>	";
            responses[i]=data;
          

            i = 693;
            data = "";
            responses[i]=data;
          

            i = 694;
            data = "";
            responses[i]=data;
          

            i = 695;
            data = "";
            responses[i]=data;
          

            i = 696;
            data = "";
            responses[i]=data;
          

            i = 697;
            data = "";
            responses[i]=data;
          

            i = 698;
            data = "";
            responses[i]=data;
          

            i = 699;
            data = "";
            responses[i]=data;
          

            i = 700;
            data = "1 subgoal (ID 515)	  	  ua : Univalence	  ============================	  forall x : V, ~ x ∈ V_empty	";
            responses[i]=data;
          

            i = 701;
            data = "";
            responses[i]=data;
          

            i = 702;
            data = "1 subgoal (ID 518)	  	  ua : Univalence	  x : V	  Hx : x ∈ V_empty	  ============================	  Empty	";
            responses[i]=data;
          

            i = 703;
            data = "1 subgoal (ID 524)	  	  ua : Univalence	  x : V	  Hx : x ∈ V_empty	  ============================	  {a : Empty & Empty_ind (fun _ : Empty => V) a = x} -> Empty	";
            responses[i]=data;
          

            i = 704;
            data = "1 subgoal (ID 530)	  	  ua : Univalence	  x : V	  Hx : x ∈ V_empty	  ff : Empty	  ============================	  Empty	";
            responses[i]=data;
          

            i = 705;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 706;
            data = "";
            responses[i]=data;
          

            i = 707;
            data = "1 subgoal (ID 525)	  	  ua : Univalence	  ============================	  forall u v : V,	  hexists (fun w : V => forall x : V, x ∈ w <-> x = u \/ x = v)	";
            responses[i]=data;
          

            i = 708;
            data = "";
            responses[i]=data;
          

            i = 709;
            data = "1 subgoal (ID 527)	  	  ua : Univalence	  u, v : V	  ============================	  hexists (fun w : V => forall x : V, x ∈ w <-> x = u \/ x = v)	";
            responses[i]=data;
          

            i = 710;
            data = "1 subgoal (ID 530)	  	  ua : Univalence	  u, v : V	  ============================	  {w : V & forall x : V, x ∈ w <-> x = u \/ x = v}	";
            responses[i]=data;
          

            i = 711;
            data = "1 subgoal (ID 532)	  	  ua : Univalence	  u, v : V	  ============================	  forall x : V, x ∈ V_pair u v <-> x = u \/ x = v	";
            responses[i]=data;
          

            i = 712;
            data = "2 subgoals (ID 539)	  	  ua : Univalence	  u, v : V	  x : V	  ============================	  {a : Bool & (if a then u else v) = x} -> (x = u) + (x = v)		subgoal 2 (ID 542) is:	 (x = u) + (x = v) -> {a : Bool & (if a then u else v) = x}	";
            responses[i]=data;
          

            i = 713;
            data = "1 subgoal (ID 539)	  	  ua : Univalence	  u, v : V	  x : V	  ============================	  {a : Bool & (if a then u else v) = x} -> (x = u) + (x = v)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 542)		subgoal 1 (ID 542) is:	 (x = u) + (x = v) -> {a : Bool & (if a then u else v) = x}	";
            responses[i]=data;
          

            i = 714;
            data = "1 subgoal (ID 542)	  	  ua : Univalence	  u, v : V	  x : V	  ============================	  (x = u) + (x = v) -> {a : Bool & (if a then u else v) = x}	No more subgoals.	";
            responses[i]=data;
          

            i = 715;
            data = "";
            responses[i]=data;
          

            i = 716;
            data = "1 subgoal (ID 527)	  	  ua : Univalence	  ============================	  V_empty ∈ V_omega * (forall x : V, x ∈ V_omega -> V_succ x ∈ V_omega)	";
            responses[i]=data;
          

            i = 717;
            data = "";
            responses[i]=data;
          

            i = 718;
            data = "2 subgoals (ID 529)	  	  ua : Univalence	  ============================	  V_empty ∈ V_omega		subgoal 2 (ID 530) is:	 forall x : V, x ∈ V_omega -> V_succ x ∈ V_omega	";
            responses[i]=data;
          

            i = 719;
            data = "1 subgoal (ID 529)	  	  ua : Univalence	  ============================	  V_empty ∈ V_omega	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 530)		subgoal 1 (ID 530) is:	 forall x : V, x ∈ V_omega -> V_succ x ∈ V_omega	";
            responses[i]=data;
          

            i = 720;
            data = "1 subgoal (ID 530)	  	  ua : Univalence	  ============================	  forall x : V, x ∈ V_omega -> V_succ x ∈ V_omega	1 subgoal (ID 536)	  	  ua : Univalence	  x : V	  ============================	  x ∈ V_omega -> V_succ x ∈ V_omega	";
            responses[i]=data;
          

            i = 721;
            data = "1 subgoal (ID 539)	  	  ua : Univalence	  x : V	  ============================	  {a : nat &	  (fix I (n : nat) : V :=	     match n with	     | 0 => V_empty	     | n0.+1 => V_succ (I n0)	     end) a = x} ->	  {a : nat &	  (fix I (n : nat) : V :=	     match n with	     | 0 => V_empty	     | n0.+1 => V_succ (I n0)	     end) a = V_succ x}	";
            responses[i]=data;
          

            i = 722;
            data = "1 subgoal (ID 544)	  	  ua : Univalence	  x : V	  n : nat	  p : (fix I (n : nat) : V :=	         match n with	         | 0 => V_empty	         | n0.+1 => V_succ (I n0)	         end) n = x	  ============================	  {a : nat &	  (fix I (n0 : nat) : V :=	     match n0 with	     | 0 => V_empty	     | n1.+1 => V_succ (I n1)	     end) a = V_succ x}	";
            responses[i]=data;
          

            i = 723;
            data = "1 subgoal (ID 546)	  	  ua : Univalence	  x : V	  n : nat	  p : (fix I (n : nat) : V :=	         match n with	         | 0 => V_empty	         | n0.+1 => V_succ (I n0)	         end) n = x	  ============================	  V_succ	    ((fix I (n0 : nat) : V :=	        match n0 with	        | 0 => V_empty	        | n1.+1 => V_succ (I n1)	        end) n) = V_succ x	";
            responses[i]=data;
          

            i = 724;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 725;
            data = "";
            responses[i]=data;
          

            i = 726;
            data = "";
            responses[i]=data;
          

            i = 727;
            data = "";
            responses[i]=data;
          

            i = 728;
            data = "";
            responses[i]=data;
          

            i = 729;
            data = "";
            responses[i]=data;
          

            i = 730;
            data = "";
            responses[i]=data;
          

            i = 731;
            data = "";
            responses[i]=data;
          

            i = 732;
            data = "";
            responses[i]=data;
          

            i = 733;
            data = "";
            responses[i]=data;
          

            i = 734;
            data = "";
            responses[i]=data;
          

            i = 735;
            data = "";
            responses[i]=data;
          

            i = 736;
            data = "";
            responses[i]=data;
          

            i = 737;
            data = "";
            responses[i]=data;
          

            i = 738;
            data = "";
            responses[i]=data;
          

            i = 739;
            data = "";
            responses[i]=data;
          

            i = 740;
            data = "";
            responses[i]=data;
          

            i = 741;
            data = "";
            responses[i]=data;
          

            i = 742;
            data = "";
            responses[i]=data;
          

            i = 743;
            data = "";
            responses[i]=data;
          

            i = 744;
            data = "";
            responses[i]=data;
          

            i = 745;
            data = "";
            responses[i]=data;
          

            i = 746;
            data = "";
            responses[i]=data;
          

            i = 747;
            data = "";
            responses[i]=data;
          

            i = 748;
            data = "";
            responses[i]=data;
          

            i = 749;
            data = "";
            responses[i]=data;
          

            i = 750;
            data = "";
            responses[i]=data;
          

            i = 751;
            data = "";
            responses[i]=data;
          

            i = 752;
            data = "";
            responses[i]=data;
          

            i = 753;
            data = "";
            responses[i]=data;
          

            i = 754;
            data = "";
            responses[i]=data;
          

            i = 755;
            data = "";
            responses[i]=data;
          

            i = 756;
            data = "";
            responses[i]=data;
          

            i = 757;
            data = "";
            responses[i]=data;
          

            i = 758;
            data = "";
            responses[i]=data;
          

            i = 759;
            data = "";
            responses[i]=data;
          

            i = 760;
            data = "";
            responses[i]=data;
          

            i = 761;
            data = "";
            responses[i]=data;
          

            i = 762;
            data = "";
            responses[i]=data;
          

            i = 763;
            data = "";
            responses[i]=data;
          

            i = 764;
            data = "";
            responses[i]=data;
          

            i = 765;
            data = "";
            responses[i]=data;
          

            i = 766;
            data = "";
            responses[i]=data;
          

            i = 767;
            data = "";
            responses[i]=data;
          

            i = 768;
            data = "";
            responses[i]=data;
          

            i = 769;
            data = "";
            responses[i]=data;
          

            i = 770;
            data = "";
            responses[i]=data;
          

            i = 771;
            data = "";
            responses[i]=data;
          

            i = 772;
            data = "";
            responses[i]=data;
          

            i = 773;
            data = "";
            responses[i]=data;
          

            i = 774;
            data = "";
            responses[i]=data;
          

            i = 775;
            data = "";
            responses[i]=data;
          

            i = 776;
            data = "";
            responses[i]=data;
          

            i = 777;
            data = "";
            responses[i]=data;
          

            i = 778;
            data = "";
            responses[i]=data;
          

            i = 779;
            data = "";
            responses[i]=data;
          

            i = 780;
            data = "";
            responses[i]=data;
          

            i = 781;
            data = "";
            responses[i]=data;
          

            i = 782;
            data = "";
            responses[i]=data;
          

            i = 783;
            data = "";
            responses[i]=data;
          

            i = 784;
            data = "";
            responses[i]=data;
          

            i = 785;
            data = "";
            responses[i]=data;
          

            i = 786;
            data = "";
            responses[i]=data;
          

            i = 787;
            data = "";
            responses[i]=data;
          

            i = 788;
            data = "";
            responses[i]=data;
          

            i = 789;
            data = "";
            responses[i]=data;
          

            i = 790;
            data = "";
            responses[i]=data;
          

            i = 791;
            data = "";
            responses[i]=data;
          

            i = 792;
            data = "";
            responses[i]=data;
          

            i = 793;
            data = "";
            responses[i]=data;
          

            i = 794;
            data = "";
            responses[i]=data;
          

            i = 795;
            data = "";
            responses[i]=data;
          

            i = 796;
            data = "";
            responses[i]=data;
          

            i = 797;
            data = "";
            responses[i]=data;
          

            i = 798;
            data = "";
            responses[i]=data;
          

            i = 799;
            data = "";
            responses[i]=data;
          

            i = 800;
            data = "";
            responses[i]=data;
          

            i = 801;
            data = "";
            responses[i]=data;
          

            i = 802;
            data = "";
            responses[i]=data;
          

            i = 803;
            data = "";
            responses[i]=data;
          

            i = 804;
            data = "";
            responses[i]=data;
          

            i = 805;
            data = "";
            responses[i]=data;
          

            i = 806;
            data = "";
            responses[i]=data;
          

            i = 807;
            data = "";
            responses[i]=data;
          

            i = 808;
            data = "";
            responses[i]=data;
          

            i = 809;
            data = "";
            responses[i]=data;
          

            i = 810;
            data = "";
            responses[i]=data;
          

            i = 811;
            data = "";
            responses[i]=data;
          

            i = 812;
            data = "";
            responses[i]=data;
          

            i = 813;
            data = "";
            responses[i]=data;
          

            i = 814;
            data = "";
            responses[i]=data;
          

            i = 815;
            data = "";
            responses[i]=data;
          

            i = 816;
            data = "";
            responses[i]=data;
          

            i = 817;
            data = "";
            responses[i]=data;
          

            i = 818;
            data = "";
            responses[i]=data;
          

            i = 819;
            data = "";
            responses[i]=data;
          

            i = 820;
            data = "";
            responses[i]=data;
          

            i = 821;
            data = "";
            responses[i]=data;
          

            i = 822;
            data = "";
            responses[i]=data;
          

            i = 823;
            data = "";
            responses[i]=data;
          

            i = 824;
            data = "";
            responses[i]=data;
          

            i = 825;
            data = "";
            responses[i]=data;
          

            i = 826;
            data = "";
            responses[i]=data;
          

            i = 827;
            data = "";
            responses[i]=data;
          

            i = 828;
            data = "";
            responses[i]=data;
          

            i = 829;
            data = "";
            responses[i]=data;
          

            i = 830;
            data = "";
            responses[i]=data;
          

            i = 831;
            data = "";
            responses[i]=data;
          

            i = 832;
            data = "";
            responses[i]=data;
          

            i = 833;
            data = "";
            responses[i]=data;
          

            i = 834;
            data = "";
            responses[i]=data;
          

            i = 835;
            data = "";
            responses[i]=data;
          

            i = 836;
            data = "";
            responses[i]=data;
          

            i = 837;
            data = "";
            responses[i]=data;
          

            i = 838;
            data = "";
            responses[i]=data;
          

            i = 839;
            data = "";
            responses[i]=data;
          

            i = 840;
            data = "";
            responses[i]=data;
          

            i = 841;
            data = "";
            responses[i]=data;
          

            i = 842;
            data = "";
            responses[i]=data;
          

            i = 843;
            data = "";
            responses[i]=data;
          

            i = 844;
            data = "";
            responses[i]=data;
          

            i = 845;
            data = "";
            responses[i]=data;
          

            i = 846;
            data = "";
            responses[i]=data;
          

            i = 847;
            data = "";
            responses[i]=data;
          

            i = 848;
            data = "";
            responses[i]=data;
          

            i = 849;
            data = "";
            responses[i]=data;
          

            i = 850;
            data = "";
            responses[i]=data;
          

            i = 851;
            data = "";
            responses[i]=data;
          

            i = 852;
            data = "";
            responses[i]=data;
          

            i = 853;
            data = "";
            responses[i]=data;
          

            i = 854;
            data = "";
            responses[i]=data;
          

            i = 855;
            data = "";
            responses[i]=data;
          

            i = 856;
            data = "";
            responses[i]=data;
          

            i = 857;
            data = "";
            responses[i]=data;
          

            i = 858;
            data = "";
            responses[i]=data;
          

            i = 859;
            data = "";
            responses[i]=data;
          

            i = 860;
            data = "";
            responses[i]=data;
          

            i = 861;
            data = "";
            responses[i]=data;
          

            i = 862;
            data = "1 subgoal (ID 532)	  	  ua : Univalence	  C : V -> hProp	  ============================	  forall a : V, hexists (fun w : V => forall x : V, x ∈ w <-> x ∈ a * C x)	";
            responses[i]=data;
          

            i = 863;
            data = "";
            responses[i]=data;
          

            i = 864;
            data = "1 subgoal (ID 551)	  	  ua : Univalence	  C : V -> hProp	  ============================	  forall (A : Type) (f : A -> V),	  (forall a : A, hexists (fun w : V => forall x : V, x ∈ w <-> x ∈ f a * C x)) ->	  hexists (fun w : V => forall x : V, x ∈ w <-> x ∈ set f * C x)	";
            responses[i]=data;
          

            i = 865;
            data = "1 subgoal (ID 555)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  ============================	  hexists (fun w : V => forall x : V, x ∈ w <-> x ∈ set f * C x)	";
            responses[i]=data;
          

            i = 866;
            data = "1 subgoal (ID 558)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  ============================	  {w : V & forall x : V, x ∈ w <-> x ∈ set f * C x}	";
            responses[i]=data;
          

            i = 867;
            data = "1 subgoal (ID 564)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  ============================	  forall x : V,	  x ∈ set (fun z : {a : A & C (f a)} => f z.1) <-> x ∈ set f * C x	";
            responses[i]=data;
          

            i = 868;
            data = "2 subgoals (ID 567)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  ============================	  x ∈ set (fun z : {a : A & C (f a)} => f z.1) -> x ∈ set f * C x		subgoal 2 (ID 568) is:	 x ∈ set f * C x -> x ∈ set (fun z : {a : A & C (f a)} => f z.1)	";
            responses[i]=data;
          

            i = 869;
            data = "1 subgoal (ID 567)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  ============================	  x ∈ set (fun z : {a : A & C (f a)} => f z.1) -> x ∈ set f * C x	1 subgoal (ID 597)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  ============================	  {a : {a : A & C (f a)} & f a.1 = x} -> x ∈ set f * C x	";
            responses[i]=data;
          

            i = 870;
            data = "1 subgoal (ID 606)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  a : A	  h : C (f a)	  p : f (a; h).1 = x	  ============================	  x ∈ set f * C x	";
            responses[i]=data;
          

            i = 871;
            data = "2 subgoals (ID 608)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  a : A	  h : C (f a)	  p : f (a; h).1 = x	  ============================	  x ∈ set f		subgoal 2 (ID 609) is:	 C x	1 subgoal (ID 608)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  a : A	  h : C (f a)	  p : f (a; h).1 = x	  ============================	  x ∈ set f	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 subgoals (ID 609)		subgoal 1 (ID 609) is:	 C x	subgoal 2 (ID 568) is:	 x ∈ set f * C x -> x ∈ set (fun z : {a : A & C (f a)} => f z.1)	1 subgoal (ID 609)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  a : A	  h : C (f a)	  p : f (a; h).1 = x	  ============================	  C x	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 subgoal (ID 568)		subgoal 1 (ID 568) is:	 x ∈ set f * C x -> x ∈ set (fun z : {a : A & C (f a)} => f z.1)	";
            responses[i]=data;
          

            i = 872;
            data = "1 subgoal (ID 568)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  ============================	  x ∈ set f * C x -> x ∈ set (fun z : {a : A & C (f a)} => f z.1)	1 subgoal (ID 622)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  H1 : x ∈ set f	  H2 : C x	  ============================	  x ∈ set (fun z : {a : A & C (f a)} => f z.1)	";
            responses[i]=data;
          

            i = 873;
            data = "1 subgoal (ID 623)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  H1 : x ∈ set f	  H2 : C x	  ============================	  x ∈ set f -> x ∈ set (fun z : {a : A & C (f a)} => f z.1)	";
            responses[i]=data;
          

            i = 874;
            data = "1 subgoal (ID 626)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  H1 : x ∈ set f	  H2 : C x	  ============================	  {a : A & f a = x} -> {a : {a : A & C (f a)} & f a.1 = x}	";
            responses[i]=data;
          

            i = 875;
            data = "1 subgoal (ID 631)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  H1 : x ∈ set f	  H2 : C x	  a : A	  p : f a = x	  ============================	  {a0 : {a0 : A & C (f a0)} & f a0.1 = x}	";
            responses[i]=data;
          

            i = 876;
            data = "1 subgoal (ID 642)	  	  ua : Univalence	  C : V -> hProp	  A : Type	  f : A -> V	  x : V	  H1 : x ∈ set f	  H2 : C x	  a : A	  p : f a = x	  ============================	  f (a; transport (fun x0 : V => C x0) p^ H2).1 = x	";
            responses[i]=data;
          

            i = 877;
            data = "No more subgoals.	";
            responses[i]=data;
          

            i = 878;
            data = "";
            responses[i]=data;
          

            i = 879;
            data = "";
            responses[i]=data;
          

            i = 880;
            data = "";
            responses[i]=data;
          

            i = 881;
            data = "";
            responses[i]=data;
          

            i = 882;
            data = "";
            responses[i]=data;
          

            i = 883;
            data = "";
            responses[i]=data;
          

            i = 884;
            data = "";
            responses[i]=data;
          

            i = 885;
            data = "";
            responses[i]=data;
          

            i = 886;
            data = "";
            responses[i]=data;
          

            i = 887;
            data = "";
            responses[i]=data;
          

            i = 888;
            data = "";
            responses[i]=data;
          

            i = 889;
            data = "";
            responses[i]=data;
          

            i = 890;
            data = "";
            responses[i]=data;
          
        };
        
        function get_response(id) {
          return responses[id];
        };

        function set_response(response, scene) {
          goalId = "goal"+scene;
          elById = document.getElementById(goalId);
          if(elById){ 
            goalSpan = elById.getElementsByTagName("span")[0];
            goalSpan.innerHTML = response.replace(/	/g , '\n');
          }
        };
      </script>
</head>
<body onload="set_array()"><div id="page" scenenumber="0" class="doc">
<div id="header" scenenumber="1" class="doc">
</div>
<div id="main" scenenumber="3" class="doc">
<h1 class="libtitle">Library HoTT.HIT.V</h1>
<div scenenumber="3" class="code"><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(6, '0_3_3');
      ">
<br>
</span></div>
<div class="goal" id="goal0_3_3"><pre><span></span></pre></div>
<div class="doc" scenenumber="5">
<a name="lab430"></a><h1 class="section">The cumulative hierarchy <span class="inlinecode"><a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a></span>.</h1>
</div>
<div scenenumber="7" class="code">
<span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(13, '0_3_7');
      ">
<br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Basics.html#"><span class="id" title="library">HoTT.Basics</span></a> <a class="idref" href="HoTT.Basics.Utf8.html#"><span class="id" title="library">HoTT.Basics.Utf8</span></a> <a class="idref" href="HoTT.Types.html#"><span class="id" title="library">HoTT.Types</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(14, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.HProp.html#"><span class="id" title="library">HProp</span></a> <a class="idref" href="HoTT.HSet.html#"><span class="id" title="library">HSet</span></a> <a class="idref" href="HoTT.UnivalenceImpliesFunext.html#"><span class="id" title="library">UnivalenceImpliesFunext</span></a> <a class="idref" href="HoTT.TruncType.html#"><span class="id" title="library">TruncType</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(15, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Colimits.SpanPushout.html#"><span class="id" title="library">Colimits.SpanPushout</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(16, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Truncations.html#"><span class="id" title="library">HoTT.Truncations</span></a> <a class="idref" href="HoTT.Colimits.Quotient.html#"><span class="id" title="library">Colimits.Quotient</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(17, '0_3_7');
      "><br>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">nat_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(18, '0_3_7');
      "><br>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">path_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(19, '0_3_7');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_7"><pre><span></span></pre></div>
<div class="doc" scenenumber="9">
Bitotal relation 
</div>
<div scenenumber="11" class="code">
<span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(23, '0_3_11');
      ">
<br>
<span class="id" title="keyword">Definition</span> <a name="bitotal"><span class="id" title="definition">bitotal</span></a> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">R</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) :=<br>
   <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a>) ⇒ <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a>)<a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a><br>
 <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">b</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> (<span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a>) ⇒ <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a>)<a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(24, '0_3_11');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_11"><pre><span></span></pre></div>
<div class="doc" scenenumber="13">
<a name="lab431"></a><h2 class="section">The cumulative hierarchy V</h2>
</div>
<div scenenumber="15" class="code">
<span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(31, '0_3_15');
      ">
<br>
<span class="id" title="keyword">Module</span> <span class="id" title="keyword">Export</span> <a name="CumulativeHierarchy"><span class="id" title="module">CumulativeHierarchy</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(32, '0_3_15');
      "><br>
<br>
<span class="id" title="var">Private</span> <span class="id" title="keyword">Inductive</span> <a name="CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a> : <span class="id" title="var">Type@</span>{<span class="id" title="var">U'</span>} :=<br>
| <a name="CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> {<span class="id" title="var">A</span> : <span class="id" title="var">Type@</span>{<span class="id" title="var">U</span>}} (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(33, '0_3_15');
      "><br>
<br>
<span class="id" title="keyword">Axiom</span> <a name="CumulativeHierarchy.setext"><span class="id" title="axiom">setext</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">{</span></a><span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">R</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>)<br>
  (<span class="id" title="var">bitot_R</span> : <a class="idref" href="HoTT.HIT.V.html#bitotal"><span class="id" title="definition">bitotal</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) (<span class="id" title="var">h</span> : <a class="idref" href="HoTT.Colimits.SpanPushout.html#SPushout"><span class="id" title="definition">SPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a><br>
<a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> (<a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.SpanPushout.html#spushl"><span class="id" title="definition">spushl</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a><a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">)</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> (<a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.SpanPushout.html#spushr"><span class="id" title="definition">spushr</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a><a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(34, '0_3_15');
      "><br>
<br>
<span class="id" title="keyword">Axiom</span> <a name="CumulativeHierarchy.is0trunc_V"><span class="id" title="axiom">is0trunc_V</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> 0 <a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(35, '0_3_15');
      "><br>
<span class="id" title="var">Existing</span> <span class="id" title="keyword">Instance</span> <span class="id" title="var">is0trunc_V</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(36, '0_3_15');
      "><br>
<br>
<span class="id" title="keyword">Fixpoint</span> <a name="CumulativeHierarchy.V_ind"><span class="id" title="definition">V_ind</span></a> (<span class="id" title="var">P</span> : <a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>)<br>
  (<span class="id" title="var">H_0trunc</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">v</span> : <a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> 0 (<a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a>))<br>
  (<span class="id" title="var">H_set</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">H_f</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a>)<a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a>))<br>
  (<span class="id" title="var">H_setext</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">R</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) (<span class="id" title="var">bitot_R</span> : <a class="idref" href="HoTT.HIT.V.html#bitotal"><span class="id" title="definition">bitotal</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>)<br>
    (<span class="id" title="var">h</span> : <a class="idref" href="HoTT.Colimits.SpanPushout.html#SPushout"><span class="id" title="definition">SPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">H_h</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">x</span> : <a class="idref" href="HoTT.Colimits.SpanPushout.html#SPushout"><span class="id" title="definition">SPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>)<a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a><br>
    <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.setext"><span class="id" title="axiom">setext</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#bitot_R"><span class="id" title="variable">bitot_R</span></a> <a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> (<a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushl"><span class="id" title="definition">spushl</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) (<a class="idref" href="HoTT.HIT.V.html#H_h"><span class="id" title="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4865cac678f2d85eddb9eba6f2bc6344"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushl"><span class="id" title="definition">spushl</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>)<a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">)</span></a><br>
      <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> (<a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushr"><span class="id" title="definition">spushr</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) (<a class="idref" href="HoTT.HIT.V.html#H_h"><span class="id" title="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4865cac678f2d85eddb9eba6f2bc6344"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushr"><span class="id" title="definition">spushr</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) )<br>
  (<span class="id" title="var">v</span> : <a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.V"><span class="id" title="inductive">V</span></a>)<br>
: <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a><br>
:= (<span class="id" title="keyword">match</span> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a> <span class="id" title="keyword">with</span><br>
     | <a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy.set"><span class="id" title="constructor">set</span></a> <span class="id" title="var">A</span> <span class="id" title="var">f</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <span class="id" title="var">A</span> <span class="id" title="var">f</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#V_ind"><span class="id" title="definition">V_ind</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#H_0trunc"><span class="id" title="variable">H_0trunc</span></a> <a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#H_setext"><span class="id" title="variable">H_setext</span></a> (<span class="id" title="var">f</span> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a>))<br>
    <span class="id" title="keyword">end</span>) <a class="idref" href="HoTT.HIT.V.html#H_setext"><span class="id" title="variable">H_setext</span></a> <a class="idref" href="HoTT.HIT.V.html#H_0trunc"><span class="id" title="variable">H_0trunc</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(37, '0_3_15');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_15"><pre><span></span></pre></div>
<div class="doc" scenenumber="17">
We don't need to axiomatize the computation rule because we get it for free thanks to 0-truncation 
</div>
<div scenenumber="19" class="code">
<span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(41, '0_3_19');
      ">
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.HIT.V.html#CumulativeHierarchy"><span class="id" title="module">CumulativeHierarchy</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(42, '0_3_19');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="V_comp_setext"><span class="id" title="definition">V_comp_setext</span></a> (<span class="id" title="var">P</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>)<br>
  (<span class="id" title="var">H_0trunc</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">v</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> 0 (<a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a>))<br>
  (<span class="id" title="var">H_set</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">H_f</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a>)<a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a>))<br>
  (<span class="id" title="var">H_setext</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">R</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) (<span class="id" title="var">bitot_R</span> : <a class="idref" href="HoTT.HIT.V.html#bitotal"><span class="id" title="definition">bitotal</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>)<br>
    (<span class="id" title="var">h</span> : <a class="idref" href="HoTT.Colimits.SpanPushout.html#SPushout"><span class="id" title="definition">SPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">H_h</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">x</span> : <a class="idref" href="HoTT.Colimits.SpanPushout.html#SPushout"><span class="id" title="definition">SPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>)<a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a><br>
    <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#setext"><span class="id" title="axiom">setext</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#bitot_R"><span class="id" title="variable">bitot_R</span></a> <a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a><a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> (<a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushl"><span class="id" title="definition">spushl</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) (<a class="idref" href="HoTT.HIT.V.html#H_h"><span class="id" title="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4865cac678f2d85eddb9eba6f2bc6344"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushl"><span class="id" title="definition">spushl</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>)<a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">)</span></a><br>
      <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> (<a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushr"><span class="id" title="definition">spushr</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) (<a class="idref" href="HoTT.HIT.V.html#H_h"><span class="id" title="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4865cac678f2d85eddb9eba6f2bc6344"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushr"><span class="id" title="definition">spushr</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) )<br>
  (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">R</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) (<span class="id" title="var">bitot_R</span> : <a class="idref" href="HoTT.HIT.V.html#bitotal"><span class="id" title="definition">bitotal</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) (<span class="id" title="var">h</span> : <a class="idref" href="HoTT.Colimits.SpanPushout.html#SPushout"><span class="id" title="definition">SPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>)<br>
: <a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> (<a class="idref" href="HoTT.HIT.V.html#V_ind"><span class="id" title="definition">V_ind</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#H_0trunc"><span class="id" title="variable">H_0trunc</span></a> <a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#H_setext"><span class="id" title="variable">H_setext</span></a>) (<a class="idref" href="HoTT.HIT.V.html#setext"><span class="id" title="axiom">setext</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#bitot_R"><span class="id" title="variable">bitot_R</span></a> <a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a>)<br>
  <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#H_setext"><span class="id" title="variable">H_setext</span></a> <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#bitot_R"><span class="id" title="variable">bitot_R</span></a> <a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#4865cac678f2d85eddb9eba6f2bc6344"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#V_ind"><span class="id" title="definition">V_ind</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#H_0trunc"><span class="id" title="variable">H_0trunc</span></a> <a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#H_setext"><span class="id" title="variable">H_setext</span></a><a class="idref" href="HoTT.Basics.Overture.html#4865cac678f2d85eddb9eba6f2bc6344"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4865cac678f2d85eddb9eba6f2bc6344"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(43, '0_3_19');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(44, '0_3_19');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(45, '0_3_19');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(46, '0_3_19');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_19"><pre><span></span></pre></div>
<div class="doc" scenenumber="21">
The non-dependent eliminator 
</div>
<div scenenumber="23" class="code">
<span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(50, '0_3_23');
      ">
<br>
<span class="id" title="keyword">Definition</span> <a name="V_rec"><span class="id" title="definition">V_rec</span></a> (<span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>)<br>
  (<span class="id" title="var">H_0trunc</span> : <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> 0 <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a>)<br>
  (<span class="id" title="var">H_set</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a><a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a>)<br>
  (<span class="id" title="var">H_setext</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">R</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) (<span class="id" title="var">bitot_R</span> : <a class="idref" href="HoTT.HIT.V.html#bitotal"><span class="id" title="definition">bitotal</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>)<br>
    (<span class="id" title="var">h</span> : <a class="idref" href="HoTT.Colimits.SpanPushout.html#SPushout"><span class="id" title="definition">SPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">H_h</span> : <a class="idref" href="HoTT.Colimits.SpanPushout.html#SPushout"><span class="id" title="definition">SPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a><br>
    <a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> (<a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushl"><span class="id" title="definition">spushl</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) (<a class="idref" href="HoTT.HIT.V.html#H_h"><span class="id" title="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushl"><span class="id" title="definition">spushl</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> (<a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushr"><span class="id" title="definition">spushr</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) (<a class="idref" href="HoTT.HIT.V.html#H_h"><span class="id" title="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushr"><span class="id" title="definition">spushr</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) )<br>
: <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(51, '0_3_23');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(52, '0_3_23');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_ind"><span class="id" title="definition">V_ind</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">H_set</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(53, '0_3_23');
      "><br>
  <span class="id" title="tactic">intros</span>. </span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(54, '0_3_23');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_const"><span class="id" title="definition">transport_const</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">H_setext</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">R</span> <span class="id" title="var">bitot_R</span> <span class="id" title="var">h</span> <span class="id" title="var">H_h</span>).</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(55, '0_3_23');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(56, '0_3_23');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="V_comp_nd_setext"><span class="id" title="definition">V_comp_nd_setext</span></a> (<span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>)<br>
  (<span class="id" title="var">H_0trunc</span> : <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> 0 <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a>)<br>
  (<span class="id" title="var">H_set</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a><a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a>)<br>
  (<span class="id" title="var">H_setext</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">R</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) (<span class="id" title="var">bitot_R</span> : <a class="idref" href="HoTT.HIT.V.html#bitotal"><span class="id" title="definition">bitotal</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>)<br>
    (<span class="id" title="var">h</span> : <a class="idref" href="HoTT.Colimits.SpanPushout.html#SPushout"><span class="id" title="definition">SPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">H_h</span> : <a class="idref" href="HoTT.Colimits.SpanPushout.html#SPushout"><span class="id" title="definition">SPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a><br>
    <a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> (<a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushl"><span class="id" title="definition">spushl</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) (<a class="idref" href="HoTT.HIT.V.html#H_h"><span class="id" title="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushl"><span class="id" title="definition">spushl</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> (<a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushr"><span class="id" title="definition">spushr</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) (<a class="idref" href="HoTT.HIT.V.html#H_h"><span class="id" title="variable">H_h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushr"><span class="id" title="definition">spushr</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) )<br>
  (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">R</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) (<span class="id" title="var">bitot_R</span> : <a class="idref" href="HoTT.HIT.V.html#bitotal"><span class="id" title="definition">bitotal</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a>) (<span class="id" title="var">h</span> : <a class="idref" href="HoTT.Colimits.SpanPushout.html#SPushout"><span class="id" title="definition">SPushout</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>)<br>
: <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.HIT.V.html#V_rec"><span class="id" title="definition">V_rec</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#H_0trunc"><span class="id" title="variable">H_0trunc</span></a> <a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#H_setext"><span class="id" title="variable">H_setext</span></a>) (<a class="idref" href="HoTT.HIT.V.html#setext"><span class="id" title="axiom">setext</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#bitot_R"><span class="id" title="variable">bitot_R</span></a> <a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a>)<br>
  <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#H_setext"><span class="id" title="variable">H_setext</span></a> <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.HIT.V.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="HoTT.HIT.V.html#bitot_R"><span class="id" title="variable">bitot_R</span></a> <a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#V_rec"><span class="id" title="definition">V_rec</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#H_0trunc"><span class="id" title="variable">H_0trunc</span></a> <a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#H_setext"><span class="id" title="variable">H_setext</span></a><a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.HIT.V.html#h"><span class="id" title="variable">h</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(57, '0_3_23');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(58, '0_3_23');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(59, '0_3_23');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(60, '0_3_23');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_23"><pre><span></span></pre></div>
<div class="doc" scenenumber="25">
<a name="lab432"></a><h2 class="section">Alternative induction principle (This is close to the one from the book)</h2>
</div>
<div scenenumber="27" class="code">
<span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(67, '0_3_27');
      ">
<br>
<span class="id" title="keyword">Definition</span> <a name="equal_img"><span class="id" title="definition">equal_img</span></a> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#C"><span class="id" title="variable">C</span></a>) (<span class="id" title="var">g</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#C"><span class="id" title="variable">C</span></a>) :=<br>
   <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a>) ⇒ <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a>)<a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a><br>
 <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">b</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> (<span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a>) ⇒ <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a>)<a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(68, '0_3_27');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="setext'"><span class="id" title="definition">setext'</span></a> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">g</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">eq_img</span> : <a class="idref" href="HoTT.HIT.V.html#equal_img"><span class="id" title="definition">equal_img</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#g"><span class="id" title="variable">g</span></a>)<br>
: <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#g"><span class="id" title="variable">g</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(69, '0_3_27');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(70, '0_3_27');
      "><br>
  <span class="id" title="tactic">pose</span> (<span class="id" title="var">R</span> := <span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> ⇒ <a class="idref" href="HoTT.Basics.Trunc.html#BuildhProp"><span class="id" title="abbreviation">BuildhProp</span></a> (<span class="id" title="var">f</span> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="var">g</span> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(71, '0_3_27');
      "><br>
  <span class="id" title="tactic">pose</span> (<span class="id" title="var">h</span> := <a class="idref" href="HoTT.Colimits.SpanPushout.html#SPushout_rec"><span class="id" title="definition">SPushout_rec</span></a> <span class="id" title="var">R</span> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <span class="id" title="var">f</span> <span class="id" title="var">g</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">r</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#r"><span class="id" title="variable">r</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(72, '0_3_27');
      "><br>
  <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.HIT.V.html#setext"><span class="id" title="axiom">setext</span></a> <span class="id" title="var">R</span> <span class="id" title="var">eq_img</span> <span class="id" title="var">h</span>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(73, '0_3_27');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(74, '0_3_27');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="V_rec'"><span class="id" title="definition">V_rec'</span></a> (<span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>)<br>
  (<span class="id" title="var">H_0trunc</span> : <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> 0 <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a>)<br>
  (<span class="id" title="var">H_set</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a><a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a>)<br>
  (<span class="id" title="var">H_setext'</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">g</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#equal_img"><span class="id" title="definition">equal_img</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#g"><span class="id" title="variable">g</span></a><a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a><br>
    <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><span class="id" title="var">H_f</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a>) (<span class="id" title="var">H_g</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#equal_img"><span class="id" title="definition">equal_img</span></a> <a class="idref" href="HoTT.HIT.V.html#H_f"><span class="id" title="variable">H_f</span></a> <a class="idref" href="HoTT.HIT.V.html#H_g"><span class="id" title="variable">H_g</span></a><a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a><br>
    <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#H_f"><span class="id" title="variable">H_f</span></a><a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.HIT.V.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.V.html#H_g"><span class="id" title="variable">H_g</span></a><a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">)</span></a> )<br>
: <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(75, '0_3_27');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(76, '0_3_27');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_rec"><span class="id" title="definition">V_rec</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">H_set</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(77, '0_3_27');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">R</span> <span class="id" title="var">bitot_R</span> <span class="id" title="var">h</span> <span class="id" title="var">H_h</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(78, '0_3_27');
      "><br>
  <span class="id" title="tactic">apply</span> <span class="id" title="var">H_setext'</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(79, '0_3_27');
      "><br>
  - <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(80, '0_3_27');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(81, '0_3_27');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">bitot_R</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(82, '0_3_27');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(83, '0_3_27');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">r</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(84, '0_3_27');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(85, '0_3_27');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">h</span> (<a class="idref" href="HoTT.Colimits.SpanPushout.html#spglue"><span class="id" title="definition">spglue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">r</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(86, '0_3_27');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(87, '0_3_27');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">bitot_R</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(88, '0_3_27');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(89, '0_3_27');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">r</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(90, '0_3_27');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(91, '0_3_27');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">h</span> (<a class="idref" href="HoTT.Colimits.SpanPushout.html#spglue"><span class="id" title="definition">spglue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">r</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(92, '0_3_27');
      "><br>
  - <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(93, '0_3_27');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(94, '0_3_27');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">bitot_R</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(95, '0_3_27');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(96, '0_3_27');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">r</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(97, '0_3_27');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(98, '0_3_27');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">H_h</span> (<a class="idref" href="HoTT.Colimits.SpanPushout.html#spglue"><span class="id" title="definition">spglue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">r</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(99, '0_3_27');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(100, '0_3_27');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">bitot_R</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(101, '0_3_27');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(102, '0_3_27');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">r</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(103, '0_3_27');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(104, '0_3_27');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">H_h</span> (<a class="idref" href="HoTT.Colimits.SpanPushout.html#spglue"><span class="id" title="definition">spglue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">r</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(105, '0_3_27');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(106, '0_3_27');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_27"><pre><span></span></pre></div>
<div class="doc" scenenumber="29">
Note that the hypothesis H_setext' differs from the one given in section 10.5 of the HoTT book. 
</div>
<div scenenumber="31" class="code">
<span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(110, '0_3_31');
      ">
<span class="id" title="keyword">Definition</span> <a name="V_ind'"><span class="id" title="definition">V_ind'</span></a> (<span class="id" title="var">P</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>)<br>
  (<span class="id" title="var">H_0trunc</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">v</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> 0 (<a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a>))<br>
  (<span class="id" title="var">H_set</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">H_f</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a>)<a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a>))<br>
  (<span class="id" title="var">H_setext'</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">g</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>)<br>
    (<span class="id" title="var">eq_img</span>: <a class="idref" href="HoTT.HIT.V.html#equal_img"><span class="id" title="definition">equal_img</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#g"><span class="id" title="variable">g</span></a>)<br>
    (<span class="id" title="var">H_f</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a>)) (<span class="id" title="var">H_g</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">b</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a>))<br>
    (<span class="id" title="var">H_eqimg</span> : <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a>) ⇒<br>
                  <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> (<span class="id" title="var">p</span>:<a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a>) ⇒ <a class="idref" href="HoTT.HIT.V.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#H_f"><span class="id" title="variable">H_f</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#H_g"><span class="id" title="variable">H_g</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a>))<a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a><br>
             <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">b</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> (<span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a>) ⇒<br>
                  <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> (<span class="id" title="var">p</span>:<a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a>) ⇒ <a class="idref" href="HoTT.HIT.V.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#H_f"><span class="id" title="variable">H_f</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#H_g"><span class="id" title="variable">H_g</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a>))<a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a><br>
    <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#setext'"><span class="id" title="definition">setext'</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.V.html#eq_img"><span class="id" title="variable">eq_img</span></a><a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#H_f"><span class="id" title="variable">H_f</span></a><a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#H_set"><span class="id" title="variable">H_set</span></a> <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.HIT.V.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.V.html#H_g"><span class="id" title="variable">H_g</span></a><a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">)</span></a><br>
  )<br>
: <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">v</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(111, '0_3_31');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(112, '0_3_31');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#V_ind"><span class="id" title="definition">V_ind</span></a> <span class="id" title="keyword">with</span> <span class="id" title="var">H_set</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(113, '0_3_31');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">R</span> <span class="id" title="var">bitot_R</span> <span class="id" title="var">h</span> <span class="id" title="var">H_h</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(114, '0_3_31');
      "><br>
  <span class="id" title="tactic">pose</span> (<span class="id" title="var">f</span> := <span class="id" title="var">h</span> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushl"><span class="id" title="definition">spushl</span></a> <span class="id" title="var">R</span> : <span class="id" title="var">A</span> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> ).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(115, '0_3_31');
      "><br>
  <span class="id" title="tactic">pose</span> (<span class="id" title="var">g</span> := <span class="id" title="var">h</span> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushr"><span class="id" title="definition">spushr</span></a> <span class="id" title="var">R</span> : <span class="id" title="var">B</span> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> ).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(116, '0_3_31');
      "><br>
  <span class="id" title="tactic">pose</span> (<span class="id" title="var">H_f</span> := <span class="id" title="var">H_h</span> <a class="idref" href="HoTT.Basics.Overture.html#4865cac678f2d85eddb9eba6f2bc6344"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushl"><span class="id" title="definition">spushl</span></a> <span class="id" title="var">R</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">a</span> : <span class="id" title="var">A</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <span class="id" title="var">P</span> (<span class="id" title="var">f</span> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(117, '0_3_31');
      "><br>
  <span class="id" title="tactic">pose</span> (<span class="id" title="var">H_g</span> := <span class="id" title="var">H_h</span> <a class="idref" href="HoTT.Basics.Overture.html#4865cac678f2d85eddb9eba6f2bc6344"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushr"><span class="id" title="definition">spushr</span></a> <span class="id" title="var">R</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">b</span> : <span class="id" title="var">B</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <span class="id" title="var">P</span> (<span class="id" title="var">g</span> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(118, '0_3_31');
      "><br>
  <span class="id" title="tactic">assert</span> (<span class="id" title="var">eq_img</span> : <a class="idref" href="HoTT.HIT.V.html#equal_img"><span class="id" title="definition">equal_img</span></a> <span class="id" title="var">f</span> <span class="id" title="var">g</span>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(119, '0_3_31');
      "><br>
  { <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(120, '0_3_31');
      "><br>
    - <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(121, '0_3_31');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">bitot_R</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(122, '0_3_31');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(123, '0_3_31');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">r</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(124, '0_3_31');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(125, '0_3_31');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">h</span> (<a class="idref" href="HoTT.Colimits.SpanPushout.html#spglue"><span class="id" title="definition">spglue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">r</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(126, '0_3_31');
      "><br>
    - <span class="id" title="tactic">intro</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(127, '0_3_31');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">bitot_R</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(128, '0_3_31');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(129, '0_3_31');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">r</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(130, '0_3_31');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(131, '0_3_31');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">h</span> (<a class="idref" href="HoTT.Colimits.SpanPushout.html#spglue"><span class="id" title="definition">spglue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">r</span>)). }</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(132, '0_3_31');
      "><br>
  <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <span class="id" title="var">P</span> (<a class="idref" href="HoTT.HIT.V.html#setext'"><span class="id" title="definition">setext'</span></a> (<span class="id" title="var">h</span> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushl"><span class="id" title="definition">spushl</span></a> <span class="id" title="var">R</span>) (<span class="id" title="var">h</span> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushr"><span class="id" title="definition">spushr</span></a> <span class="id" title="var">R</span>) <span class="id" title="var">eq_img</span>)<br>
      (<span class="id" title="var">H_set</span> <span class="id" title="var">A</span> (<span class="id" title="var">h</span> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushl"><span class="id" title="definition">spushl</span></a> <span class="id" title="var">R</span>) (<span class="id" title="var">H_h</span> <a class="idref" href="HoTT.Basics.Overture.html#4865cac678f2d85eddb9eba6f2bc6344"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushl"><span class="id" title="definition">spushl</span></a> <span class="id" title="var">R</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(133, '0_3_31');
      "><br>
  { <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">p</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <span class="id" title="var">P</span> <a class="idref" href="HoTT.HIT.V.html#p"><span class="id" title="variable">p</span></a> (<span class="id" title="var">H_set</span> <span class="id" title="var">A</span> (<span class="id" title="var">h</span> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushl"><span class="id" title="definition">spushl</span></a> <span class="id" title="var">R</span>) (<span class="id" title="var">H_h</span> <a class="idref" href="HoTT.Basics.Overture.html#4865cac678f2d85eddb9eba6f2bc6344"><span class="id" title="notation">oD</span></a> <a class="idref" href="HoTT.Colimits.SpanPushout.html#spushl"><span class="id" title="definition">spushl</span></a> <span class="id" title="var">R</span>)))).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(134, '0_3_31');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a>. }<br>
  <span class="id" title="tactic">apply</span> (<span class="id" title="var">H_setext'</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> <span class="id" title="var">eq_img</span> <span class="id" title="var">H_f</span> <span class="id" title="var">H_g</span>). </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(135, '0_3_31');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(136, '0_3_31');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(137, '0_3_31');
      "><br>
    <span class="id" title="tactic">set</span> (<span class="id" title="var">truncb</span> := <a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">bitot_R</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(138, '0_3_31');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">truncb</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(139, '0_3_31');
      "><br>
    <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(140, '0_3_31');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">Rab</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(141, '0_3_31');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(142, '0_3_31');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(143, '0_3_31');
      "><br>
    <span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">h</span> (<a class="idref" href="HoTT.Colimits.SpanPushout.html#spglue"><span class="id" title="definition">spglue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">Rab</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(144, '0_3_31');
      "><br>
    <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#concatR"><span class="id" title="abbreviation">concatR</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <span class="id" title="var">H_h</span> (<a class="idref" href="HoTT.Colimits.SpanPushout.html#spglue"><span class="id" title="definition">spglue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">Rab</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(145, '0_3_31');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#inverse"><span class="id" title="definition">inverse</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(146, '0_3_31');
      "><span class="id" title="tactic">unfold</span> <span class="id" title="var">f</span>, <span class="id" title="var">g</span>. </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(147, '0_3_31');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_compose"><span class="id" title="lemma">transport_compose</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(148, '0_3_31');
      "><br>
  - <span class="id" title="tactic">intros</span> <span class="id" title="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(149, '0_3_31');
      "><br>
    <span class="id" title="tactic">set</span> (<span class="id" title="var">trunca</span> := <a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">bitot_R</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(150, '0_3_31');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">trunca</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(151, '0_3_31');
      "><br>
    <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(152, '0_3_31');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">Rab</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(153, '0_3_31');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(154, '0_3_31');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(155, '0_3_31');
      "><br>
    <span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">h</span> (<a class="idref" href="HoTT.Colimits.SpanPushout.html#spglue"><span class="id" title="definition">spglue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">Rab</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(156, '0_3_31');
      "><br>
    <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#concatR"><span class="id" title="abbreviation">concatR</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <span class="id" title="var">H_h</span> (<a class="idref" href="HoTT.Colimits.SpanPushout.html#spglue"><span class="id" title="definition">spglue</span></a> <span class="id" title="var">R</span> <span class="id" title="var">Rab</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(157, '0_3_31');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#inverse"><span class="id" title="definition">inverse</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(158, '0_3_31');
      "><span class="id" title="tactic">unfold</span> <span class="id" title="var">f</span>, <span class="id" title="var">g</span>. </span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(159, '0_3_31');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_compose"><span class="id" title="lemma">transport_compose</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(160, '0_3_31');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(161, '0_3_31');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_31"><pre><span></span></pre></div>
<div class="doc" scenenumber="33">
Simpler induction principle when the goal is an hprop 
</div>
<div scenenumber="35" class="code">
<span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(165, '0_3_35');
      ">
<br>
<span class="id" title="keyword">Definition</span> <a name="V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> (<span class="id" title="var">P</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>)<br>
  (<span class="id" title="var">H_set</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">H_f</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a>)<a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a>))<br>
  (<span class="id" title="var">isHProp_P</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">v</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsHProp"><span class="id" title="abbreviation">IsHProp</span></a> (<a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a>))<br>
  : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">v</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(166, '0_3_35');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(167, '0_3_35');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_ind"><span class="id" title="definition">V_ind</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">H_set</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(168, '0_3_35');
      "><br>
  <span class="id" title="tactic">intros</span>. </span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(169, '0_3_35');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(170, '0_3_35');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(171, '0_3_35');
      "><br>
<br>
<span class="id" title="keyword">Section</span> <a name="AssumingUA"><span class="id" title="section">AssumingUA</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(172, '0_3_35');
      "><br>
<span class="id" title="keyword">Context</span> `{<span class="id" title="var">ua</span> : <a class="idref" href="HoTT.Types.Universe.html#Univalence"><span class="id" title="class">Univalence</span></a>}.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(173, '0_3_35');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_35"><pre><span></span></pre></div>
<div class="doc" scenenumber="37">
<a name="lab433"></a><h2 class="section">Membership relation</h2>
</div>
<div scenenumber="39" class="code">
<span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(180, '0_3_39');
      ">
<br>
<span class="id" title="keyword">Definition</span> <a name="mem"><span class="id" title="definition">mem</span></a> (<span class="id" title="var">x</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(181, '0_3_39');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(182, '0_3_39');
      "><br>
  <span class="id" title="tactic">simple</span> <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_rec'"><span class="id" title="definition">V_rec'</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(183, '0_3_39');
      "><br>
  - <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(184, '0_3_39');
      "><br>
    <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> : <span class="id" title="var">A</span> ⇒ <span class="id" title="var">f</span> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="var">x</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(185, '0_3_39');
      "><br>
  - <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(186, '0_3_39');
      "><br>
    <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> <span class="id" title="var">eqimg</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(187, '0_3_39');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.TruncType.html#path_iff_hprop"><span class="id" title="definition">path_iff_hprop</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(188, '0_3_39');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(189, '0_3_39');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> <span class="id" title="var">H</span>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(190, '0_3_39');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(191, '0_3_39');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">eqimg</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(192, '0_3_39');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(193, '0_3_39');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p'</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(194, '0_3_39');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(195, '0_3_39');
      "><span class="id" title="tactic">transitivity</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span>); <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">path_hints</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(196, '0_3_39');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(197, '0_3_39');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> <span class="id" title="var">H</span>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(198, '0_3_39');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(199, '0_3_39');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">eqimg</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(200, '0_3_39');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(201, '0_3_39');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p'</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(202, '0_3_39');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(203, '0_3_39');
      "><span class="id" title="tactic">transitivity</span> (<span class="id" title="var">g</span> <span class="id" title="var">b</span>); <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">path_hints</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(204, '0_3_39');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(205, '0_3_39');
      "><br>
<br>
<span class="id" title="var">Declare</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(206, '0_3_39');
      "><br>
<span class="id" title="keyword">Notation</span> <a name="f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">"</span></a>x ∈ v" := (<a class="idref" href="HoTT.HIT.V.html#mem"><span class="id" title="definition">mem</span></a> <span class="id" title="var">x</span> <span class="id" title="var">v</span>) : <span class="id" title="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(207, '0_3_39');
      "><br>
<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(208, '0_3_39');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_39"><pre><span></span></pre></div>
<div class="doc" scenenumber="41">
<a name="lab434"></a><h2 class="section">Subset relation</h2>
</div>
<div scenenumber="43" class="code">
<span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(215, '0_3_43');
      ">
<br>
<span class="id" title="keyword">Definition</span> <a name="subset"><span class="id" title="definition">subset</span></a> (<span class="id" title="var">x</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">y</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a><br>
:= <a class="idref" href="HoTT.Basics.Trunc.html#BuildhProp"><span class="id" title="abbreviation">BuildhProp</span></a> (<a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">z</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(216, '0_3_43');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a name="148945668c671cfec4e39166c697f7ca"><span class="id" title="notation">"</span></a>x ⊆ y" := (<a class="idref" href="HoTT.HIT.V.html#subset"><span class="id" title="definition">subset</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) : <span class="id" title="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(217, '0_3_43');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_43"><pre><span></span></pre></div>
<div class="doc" scenenumber="45">
<a name="lab435"></a><h2 class="section">Bisimulation relation</h2>
 The equality in V lives in Type@{U'}. We define the bisimulation relation which is a U-small resizing of the equality in V: it must live in hProp_U : Type{U'}, hence the codomain is hProp@{U}. We then prove that bisimulation is equality (bisim_equals_id), then use it to prove the key lemma monic_set_present. 
</div>
<div scenenumber="47" class="code">
<span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(224, '0_3_47');
      ">
<br>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a name="bisim_aux"><span class="id" title="definition">bisim_aux</span></a> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">H_f</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(225, '0_3_47');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(226, '0_3_47');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#V_rec'"><span class="id" title="definition">V_rec'</span></a> <span class="id" title="keyword">with</span><br>
    (<span class="id" title="keyword">fun</span> <span class="id" title="var">B</span> <span class="id" title="var">g</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Basics.Trunc.html#BuildhProp"><span class="id" title="abbreviation">BuildhProp</span></a> ( <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> ⇒ <span class="id" title="var">H_f</span> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> (<a class="idref" href="HoTT.HIT.V.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a>))<a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a><br>
                               <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">b</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> ⇒ <span class="id" title="var">H_f</span> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> (<a class="idref" href="HoTT.HIT.V.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a>)) )<br>
    ).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(227, '0_3_47');
      "><br>
  - <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(228, '0_3_47');
      "><br>
  - <span class="id" title="tactic">intros</span> <span class="id" title="var">B</span> <span class="id" title="var">B'</span> <span class="id" title="var">g</span> <span class="id" title="var">g'</span> <span class="id" title="var">eq_img</span> <span class="id" title="var">H_g</span> <span class="id" title="var">H_g'</span> <span class="id" title="var">H_img</span>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(229, '0_3_47');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.TruncType.html#path_iff_hprop"><span class="id" title="definition">path_iff_hprop</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(230, '0_3_47');
      "><br>
    + <span class="id" title="tactic">intros</span> [<span class="id" title="var">H1</span> <span class="id" title="var">H2</span>]; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(231, '0_3_47');
      "><br>
      × <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(232, '0_3_47');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">H1</span> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(233, '0_3_47');
      "><br>
        <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(234, '0_3_47');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">eq_img</span> <span class="id" title="var">b</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(235, '0_3_47');
      "><br>
        <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(236, '0_3_47');
      "><span class="id" title="tactic">refine</span> (@<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1) <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><span class="id" title="var">b0</span> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <span class="id" title="var">B'</span> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <span class="id" title="var">g</span> <span class="id" title="var">b</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="var">g'</span> <a class="idref" href="HoTT.HIT.V.html#b0"><span class="id" title="variable">b0</span></a><a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><span class="id" title="var">b0</span> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <span class="id" title="var">B'</span> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <span class="id" title="var">H_f</span> <span class="id" title="var">a</span> (<span class="id" title="var">g'</span> <a class="idref" href="HoTT.HIT.V.html#b0"><span class="id" title="variable">b0</span></a>)<a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(237, '0_3_47');
      "><br>
        <span class="id" title="tactic">intros</span> [<span class="id" title="var">b'</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(238, '0_3_47');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b'</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(239, '0_3_47');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">H_f</span> <span class="id" title="var">a</span> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="var">p</span> <span class="id" title="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(240, '0_3_47');
      "><br>
      × <span class="id" title="tactic">intro</span> <span class="id" title="var">b'</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(241, '0_3_47');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">eq_img</span> <span class="id" title="var">b'</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(242, '0_3_47');
      "><br>
        <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(243, '0_3_47');
      "><span class="id" title="tactic">generalize</span> (<span class="id" title="var">H2</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(244, '0_3_47');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(245, '0_3_47');
      "><br>
        <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(246, '0_3_47');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(247, '0_3_47');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">H_f</span> <span class="id" title="var">a</span> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="var">p</span> <span class="id" title="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(248, '0_3_47');
      "><br>
    + <span class="id" title="tactic">intros</span> [<span class="id" title="var">H1</span> <span class="id" title="var">H2</span>]; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(249, '0_3_47');
      "><br>
      × <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(250, '0_3_47');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">H1</span> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(251, '0_3_47');
      "><br>
        <span class="id" title="tactic">intros</span> [<span class="id" title="var">b'</span> <span class="id" title="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(252, '0_3_47');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">eq_img</span> <span class="id" title="var">b'</span>). </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(253, '0_3_47');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(254, '0_3_47');
      "><br>
        <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(255, '0_3_47');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(256, '0_3_47');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">H_f</span> <span class="id" title="var">a</span> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <span class="id" title="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(257, '0_3_47');
      "><br>
      × <span class="id" title="tactic">intro</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(258, '0_3_47');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">eq_img</span> <span class="id" title="var">b</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(259, '0_3_47');
      "><br>
        <span class="id" title="tactic">intros</span> [<span class="id" title="var">b'</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(260, '0_3_47');
      "><span class="id" title="tactic">generalize</span> (<span class="id" title="var">H2</span> <span class="id" title="var">b'</span>). </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(261, '0_3_47');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(262, '0_3_47');
      "><br>
        <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(263, '0_3_47');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(264, '0_3_47');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">H_f</span> <span class="id" title="var">a</span> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <span class="id" title="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(265, '0_3_47');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(266, '0_3_47');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="bisimulation"><span class="id" title="definition">bisimulation</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V@</span></a>{<span class="id" title="var">U'</span> <span class="id" title="var">U</span>} <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V@</span></a>{<span class="id" title="var">U'</span> <span class="id" title="var">U</span>} <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp@</span></a>{<span class="id" title="var">U</span>}.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(267, '0_3_47');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(268, '0_3_47');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_rec'"><span class="id" title="definition">V_rec'</span></a> (<a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) <span class="id" title="var">_</span> <a class="idref" href="HoTT.HIT.V.html#bisim_aux"><span class="id" title="definition">bisim_aux</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(269, '0_3_47');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> <span class="id" title="var">eq_img</span> <span class="id" title="var">H_f</span> <span class="id" title="var">H_g</span> <span class="id" title="var">H_img</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(270, '0_3_47');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#path_forall"><span class="id" title="definition">path_forall</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(271, '0_3_47');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(272, '0_3_47');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">C</span> <span class="id" title="var">h</span> <span class="id" title="var">_</span>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(273, '0_3_47');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.TruncType.html#path_iff_hprop"><span class="id" title="definition">path_iff_hprop</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(274, '0_3_47');
      "><br>
  - <span class="id" title="tactic">intros</span> [<span class="id" title="var">H1</span> <span class="id" title="var">H2</span>]; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(275, '0_3_47');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(276, '0_3_47');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">H_img</span> <span class="id" title="var">b</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(277, '0_3_47');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(278, '0_3_47');
      "><span class="id" title="tactic">generalize</span> (<span class="id" title="var">H1</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(279, '0_3_47');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(280, '0_3_47');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">c</span> <span class="id" title="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(281, '0_3_47');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">c</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(282, '0_3_47');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" title="definition">ap10</span></a> <span class="id" title="var">p</span> (<span class="id" title="var">h</span> <span class="id" title="var">c</span>)<a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <span class="id" title="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(283, '0_3_47');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">c</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(284, '0_3_47');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">H2</span> <span class="id" title="var">c</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(285, '0_3_47');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(286, '0_3_47');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">H_img</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(287, '0_3_47');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(288, '0_3_47');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(289, '0_3_47');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(290, '0_3_47');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" title="definition">ap10</span></a> <span class="id" title="var">p</span> (<span class="id" title="var">h</span> <span class="id" title="var">c</span>)<a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <span class="id" title="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(291, '0_3_47');
      "><br>
  - <span class="id" title="tactic">intros</span> [<span class="id" title="var">H1</span> <span class="id" title="var">H2</span>]; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(292, '0_3_47');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(293, '0_3_47');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">H_img</span> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(294, '0_3_47');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(295, '0_3_47');
      "><span class="id" title="tactic">generalize</span> (<span class="id" title="var">H1</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(296, '0_3_47');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(297, '0_3_47');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">c</span> <span class="id" title="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(298, '0_3_47');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">c</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(299, '0_3_47');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" title="definition">ap10</span></a> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">c</span>)<a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <span class="id" title="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(300, '0_3_47');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">c</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(301, '0_3_47');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">H2</span> <span class="id" title="var">c</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(302, '0_3_47');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">H3</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(303, '0_3_47');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">H_img</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(304, '0_3_47');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(305, '0_3_47');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(306, '0_3_47');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(307, '0_3_47');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" title="definition">ap10</span></a> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">c</span>)<a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <span class="id" title="var">H3</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(308, '0_3_47');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(309, '0_3_47');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a name="522815bdfed329d51c502b2896923471"><span class="id" title="notation">"</span></a>u ~~ v" := (<a class="idref" href="HoTT.HIT.V.html#bisimulation"><span class="id" title="definition">bisimulation</span></a> <span class="id" title="var">u</span> <span class="id" title="var">v</span>) : <span class="id" title="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(310, '0_3_47');
      "><br>
<br>
<span class="id" title="keyword">Global Instance</span> <a name="reflexive_bisimulation"><span class="id" title="instance">reflexive_bisimulation</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#Reflexive"><span class="id" title="class">Reflexive</span></a> <a class="idref" href="HoTT.HIT.V.html#bisimulation"><span class="id" title="definition">bisimulation</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(311, '0_3_47');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(312, '0_3_47');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(313, '0_3_47');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">H_f</span>; <span class="id" title="tactic">simpl</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(314, '0_3_47');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(315, '0_3_47');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">auto</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(316, '0_3_47');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">auto</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(317, '0_3_47');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(318, '0_3_47');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="bisimulation_equiv_id"><span class="id" title="lemma">bisimulation_equiv_id</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">u</span> <span class="id" title="var">v</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a><a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.HIT.V.html#522815bdfed329d51c502b2896923471"><span class="id" title="notation">~~</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a><a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(319, '0_3_47');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(320, '0_3_47');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">u</span> <span class="id" title="var">v</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(321, '0_3_47');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#equiv_iff_hprop"><span class="id" title="definition">equiv_iff_hprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(322, '0_3_47');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">u</span> <a class="idref" href="HoTT.HIT.V.html#522815bdfed329d51c502b2896923471"><span class="id" title="notation">~~</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="var">p</span> (<a class="idref" href="HoTT.HIT.V.html#reflexive_bisimulation"><span class="id" title="instance">reflexive_bisimulation</span></a> <span class="id" title="var">u</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(323, '0_3_47');
      "><br>
  - <span class="id" title="tactic">generalize</span> <span class="id" title="var">u</span> <span class="id" title="var">v</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(324, '0_3_47');
      "><br>
    <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>); <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">H_f</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(325, '0_3_47');
      "><br>
    <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>); <span class="id" title="tactic">intros</span> <span class="id" title="var">B</span> <span class="id" title="var">g</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(326, '0_3_47');
      "><br>
    <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">intros</span> [<span class="id" title="var">H1</span> <span class="id" title="var">H2</span>].</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(327, '0_3_47');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#setext'"><span class="id" title="definition">setext'</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(328, '0_3_47');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(329, '0_3_47');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(330, '0_3_47');
      "><span class="id" title="tactic">generalize</span> (<span class="id" title="var">H1</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(331, '0_3_47');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(332, '0_3_47');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">h</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(333, '0_3_47');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">exact</span> (<span class="id" title="var">H_f</span> <span class="id" title="var">a</span> (<span class="id" title="var">g</span> <span class="id" title="var">b</span>) <span class="id" title="var">h</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(334, '0_3_47');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(335, '0_3_47');
      "><span class="id" title="tactic">generalize</span> (<span class="id" title="var">H2</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(336, '0_3_47');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(337, '0_3_47');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">h</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(338, '0_3_47');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">exact</span> (<span class="id" title="var">H_f</span> <span class="id" title="var">a</span> (<span class="id" title="var">g</span> <span class="id" title="var">b</span>) <span class="id" title="var">h</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(339, '0_3_47');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(340, '0_3_47');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_47"><pre><span></span></pre></div>
<div class="doc" scenenumber="49">
<a name="lab436"></a><h2 class="section">Canonical presentation of V-sets (Lemma 10.5.6)</h2>
<div class="doc" scenenumber="4"> </div>

 Using the regular kernel would lead to a universe inconsistency in the monic_set_present lemma later. 
</div>
<div scenenumber="51" class="code">
<span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(349, '0_3_51');
      ">
<span class="id" title="keyword">Definition</span> <a name="ker_bisim"><span class="id" title="definition">ker_bisim</span></a> {<span class="id" title="var">A</span>} (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a>) := (<a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#522815bdfed329d51c502b2896923471"><span class="id" title="notation">~~</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(350, '0_3_51');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="ker_bisim_is_ker"><span class="id" title="definition">ker_bisim_is_ker</span></a> {<span class="id" title="var">A</span>} (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>)<br>
  : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.HIT.V.html#ker_bisim"><span class="id" title="definition">ker_bisim</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(351, '0_3_51');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(352, '0_3_51');
      "><br>
  <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#bisimulation_equiv_id"><span class="id" title="lemma">bisimulation_equiv_id</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(353, '0_3_51');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(354, '0_3_51');
      "><br>
<br>
<span class="id" title="keyword">Section</span> <a name="AssumingUA.MonicSetPresent_Uniqueness"><span class="id" title="section">MonicSetPresent_Uniqueness</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(355, '0_3_51');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_51"><pre><span></span></pre></div>
<div class="doc" scenenumber="53">
Given u : V, we want to show that the representation u = @set Au mu, where Au is an hSet and mu is monic, is unique. 
</div>
<div scenenumber="55" class="code">
<span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(359, '0_3_55');
      ">
<br>
<span class="id" title="keyword">Context</span> {<span class="id" title="var">u</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>} {<span class="id" title="var">Au</span> <span class="id" title="var">Au'</span>: <span class="id" title="keyword">Type</span>} {<span class="id" title="var">h</span> : <a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" title="abbreviation">IsHSet</span></a> <a class="idref" href="HoTT.HIT.V.html#Au"><span class="id" title="variable">Au</span></a>} {<span class="id" title="var">h'</span> : <a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" title="abbreviation">IsHSet</span></a> <a class="idref" href="HoTT.HIT.V.html#Au'"><span class="id" title="variable">Au'</span></a>} {<span class="id" title="var">mu</span> : <a class="idref" href="HoTT.HIT.V.html#Au"><span class="id" title="variable">Au</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>} {<span class="id" title="var">mono</span> : <a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" title="abbreviation">IsEmbedding</span></a> <a class="idref" href="HoTT.HIT.V.html#mu"><span class="id" title="variable">mu</span></a>}<br>
  {<span class="id" title="var">mu'</span> : <a class="idref" href="HoTT.HIT.V.html#Au'"><span class="id" title="variable">Au'</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>} {<span class="id" title="var">mono'</span> : <a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" title="abbreviation">IsEmbedding</span></a> <a class="idref" href="HoTT.HIT.V.html#mu'"><span class="id" title="variable">mu'</span></a>} {<span class="id" title="var">p</span> : <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#mu"><span class="id" title="variable">mu</span></a>} {<span class="id" title="var">p'</span> : <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#mu'"><span class="id" title="variable">mu'</span></a>}.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(360, '0_3_55');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="eq_img_untrunc"><span class="id" title="lemma">eq_img_untrunc</span></a> : <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" title="variable">Au</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><span class="id" title="var">a'</span> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au'"><span class="id" title="variable">Au'</span></a> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu'"><span class="id" title="variable">mu'</span></a> <a class="idref" href="HoTT.HIT.V.html#a'"><span class="id" title="variable">a'</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a><a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a><br>
                     <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">a'</span> : <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au'"><span class="id" title="variable">Au'</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><span class="id" title="var">a</span> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" title="variable">Au</span></a> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu'"><span class="id" title="variable">mu'</span></a> <a class="idref" href="HoTT.HIT.V.html#a'"><span class="id" title="variable">a'</span></a><a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a><a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(361, '0_3_55');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(362, '0_3_55');
      "><br>
  <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(363, '0_3_55');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(364, '0_3_55');
      "><span class="id" title="tactic">exact</span> (@<a class="idref" href="HoTT.Truncations.Core.html#untrunc_istrunc"><span class="id" title="definition">untrunc_istrunc</span></a> (-1) <span class="id" title="var">_</span> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono'"><span class="id" title="variable">mono'</span></a> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <span class="id" title="var">a</span>)) (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <span class="id" title="var">a</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>) (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.p"><span class="id" title="variable">p</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.p'"><span class="id" title="variable">p'</span></a>) (<a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> 1<a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>))).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(365, '0_3_55');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">a'</span>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(366, '0_3_55');
      "><span class="id" title="tactic">exact</span> (@<a class="idref" href="HoTT.Truncations.Core.html#untrunc_istrunc"><span class="id" title="definition">untrunc_istrunc</span></a> (-1) <span class="id" title="var">_</span> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono"><span class="id" title="variable">mono</span></a> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu'"><span class="id" title="variable">mu'</span></a> <span class="id" title="var">a'</span>)) (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu'"><span class="id" title="variable">mu'</span></a> <span class="id" title="var">a'</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>) (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.p'"><span class="id" title="variable">p'</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.p"><span class="id" title="variable">p</span></a>) (<a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">a'</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> 1<a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>))).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(367, '0_3_55');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(368, '0_3_55');
      "><br>
<br>
<span class="id" title="keyword">Let</span> <a name="AssumingUA.MonicSetPresent_Uniqueness.e"><span class="id" title="variable">e</span></a> : <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" title="variable">Au</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au'"><span class="id" title="variable">Au'</span></a> := <span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.HIT.V.html#eq_img_untrunc"><span class="id" title="lemma">eq_img_untrunc</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(369, '0_3_55');
      "><br>
<span class="id" title="keyword">Let</span> <a name="AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" title="variable">inv_e</span></a> : <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au'"><span class="id" title="variable">Au'</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" title="variable">Au</span></a> := <span class="id" title="keyword">fun</span> <span class="id" title="var">a'</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.HIT.V.html#eq_img_untrunc"><span class="id" title="lemma">eq_img_untrunc</span></a> <a class="idref" href="HoTT.HIT.V.html#a'"><span class="id" title="variable">a'</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(370, '0_3_55');
      "><br>
<br>
<span class="id" title="keyword">Let</span> <a name="AssumingUA.MonicSetPresent_Uniqueness.hom1"><span class="id" title="variable">hom1</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#Sect"><span class="id" title="definition">Sect</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" title="variable">inv_e</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.e"><span class="id" title="variable">e</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(371, '0_3_55');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(372, '0_3_55');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">a'</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(373, '0_3_55');
      "><br>
  <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HSet.html#isinj_embedding"><span class="id" title="lemma">isinj_embedding</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu'"><span class="id" title="variable">mu'</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono'"><span class="id" title="variable">mono'</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(374, '0_3_55');
      "><br>
  <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" title="variable">inv_e</span></a> <span class="id" title="var">a'</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(375, '0_3_55');
      "><br>
  - <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.HIT.V.html#eq_img_untrunc"><span class="id" title="lemma">eq_img_untrunc</span></a> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" title="variable">inv_e</span></a> <span class="id" title="var">a'</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(376, '0_3_55');
      "><br>
  - <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.HIT.V.html#eq_img_untrunc"><span class="id" title="lemma">eq_img_untrunc</span></a> <span class="id" title="var">a'</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(377, '0_3_55');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(378, '0_3_55');
      "><br>
<br>
<span class="id" title="keyword">Let</span> <a name="AssumingUA.MonicSetPresent_Uniqueness.hom2"><span class="id" title="variable">hom2</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#Sect"><span class="id" title="definition">Sect</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.e"><span class="id" title="variable">e</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" title="variable">inv_e</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(379, '0_3_55');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(380, '0_3_55');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(381, '0_3_55');
      "><br>
  <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HSet.html#isinj_embedding"><span class="id" title="lemma">isinj_embedding</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono"><span class="id" title="variable">mono</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(382, '0_3_55');
      "><br>
  <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu'"><span class="id" title="variable">mu'</span></a> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.e"><span class="id" title="variable">e</span></a> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(383, '0_3_55');
      "><br>
  - <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.HIT.V.html#eq_img_untrunc"><span class="id" title="lemma">eq_img_untrunc</span></a> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.e"><span class="id" title="variable">e</span></a> <span class="id" title="var">a</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(384, '0_3_55');
      "><br>
  - <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.HIT.V.html#eq_img_untrunc"><span class="id" title="lemma">eq_img_untrunc</span></a> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(385, '0_3_55');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(386, '0_3_55');
      "><br>
<br>
<span class="id" title="keyword">Let</span> <a name="AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a> : <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au'"><span class="id" title="variable">Au'</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" title="variable">Au</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(387, '0_3_55');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(388, '0_3_55');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Universe.html#path_universe_uncurried"><span class="id" title="definition">path_universe_uncurried</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(389, '0_3_55');
      "><br>
  <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_adjointify"><span class="id" title="definition">equiv_adjointify</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" title="variable">inv_e</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.e"><span class="id" title="variable">e</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.hom2"><span class="id" title="variable">hom2</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.hom1"><span class="id" title="variable">hom1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(390, '0_3_55');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(391, '0_3_55');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="mu_eq_mu'"><span class="id" title="lemma">mu_eq_mu'</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu'"><span class="id" title="variable">mu'</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(392, '0_3_55');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(393, '0_3_55');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#path_forall"><span class="id" title="definition">path_forall</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(394, '0_3_55');
      "><span class="id" title="tactic">intro</span> <span class="id" title="var">a'</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(395, '0_3_55');
      "><br>
  <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">X</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#X"><span class="id" title="variable">X</span></a>) <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^^</span></a> <span class="id" title="var">a'</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(396, '0_3_55');
      "><br>
  - <span class="id" title="tactic">apply</span> (@<a class="idref" href="HoTT.Types.Arrow.html#transport_arrow"><span class="id" title="definition">transport_arrow</span></a> <span class="id" title="keyword">Type</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#X"><span class="id" title="variable">X</span></a>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">X</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" title="variable">Au</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au'"><span class="id" title="variable">Au'</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <span class="id" title="var">a'</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(397, '0_3_55');
      "><br>
  - <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^^</span></a> <span class="id" title="var">a'</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(398, '0_3_55');
      "><br>
    + <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_const"><span class="id" title="definition">transport_const</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(399, '0_3_55');
      "><br>
    + <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> (<a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.inv_e"><span class="id" title="variable">inv_e</span></a> <span class="id" title="var">a'</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(400, '0_3_55');
      "><br>
      2: <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.HIT.V.html#eq_img_untrunc"><span class="id" title="lemma">eq_img_untrunc</span></a> <span class="id" title="var">a'</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(401, '0_3_55');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(402, '0_3_55');
      "><br>
      <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a> <span class="id" title="var">a'</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(403, '0_3_55');
      "><br>
      × <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="var">a'</span>) (<a class="idref" href="HoTT.Basics.PathGroupoids.html#inv_V"><span class="id" title="definition">inv_V</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(404, '0_3_55');
      "><br>
      × <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Universe.html#transport_path_universe"><span class="id" title="definition">transport_path_universe</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(405, '0_3_55');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(406, '0_3_55');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="monic_set_present_uniqueness"><span class="id" title="lemma">monic_set_present_uniqueness</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" title="variable">Au</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <a class="idref" href="Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.h"><span class="id" title="variable">h</span></a><a class="idref" href="Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono"><span class="id" title="variable">mono</span></a><a class="idref" href="Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.p"><span class="id" title="variable">p</span></a><a class="idref" href="Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">))</span></a> <a class="idref" href="HoTT.Basics.Overture.html#b8b2ebc8e1a8b9aa935c0702efb5dccf"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au'"><span class="id" title="variable">Au'</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu'"><span class="id" title="variable">mu'</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <a class="idref" href="Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.h'"><span class="id" title="variable">h'</span></a><a class="idref" href="Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono'"><span class="id" title="variable">mono'</span></a><a class="idref" href="Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.p'"><span class="id" title="variable">p'</span></a><a class="idref" href="Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">))</span></a> <a class="idref" href="HoTT.Basics.Overture.html#b8b2ebc8e1a8b9aa935c0702efb5dccf"><span class="id" title="notation">:&gt;</span></a> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><span class="id" title="var">A</span> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <span class="id" title="keyword">Type</span> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><span class="id" title="var">m</span> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" title="abbreviation">IsHSet</span></a> <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" title="abbreviation">IsEmbedding</span></a> <a class="idref" href="HoTT.HIT.V.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#m"><span class="id" title="variable">m</span></a><a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a><a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}}</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(407, '0_3_55');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(408, '0_3_55');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Sigma.html#path_sigma_uncurried"><span class="id" title="definition">path_sigma_uncurried</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(409, '0_3_55');
      "><br>
  <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(410, '0_3_55');
      "><br>
  <span class="id" title="tactic">transitivity</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Basics.PathGroupoids.html#transportD"><span class="id" title="definition">transportD</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">A</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">A</span> <span class="id" title="var">m</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" title="abbreviation">IsHSet</span></a> <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" title="abbreviation">IsEmbedding</span></a> <a class="idref" href="HoTT.HIT.V.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#m"><span class="id" title="variable">m</span></a><a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a>) <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a> <a class="idref" href="Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.h"><span class="id" title="variable">h</span></a><a class="idref" href="Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono"><span class="id" title="variable">mono</span></a><a class="idref" href="Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.p"><span class="id" title="variable">p</span></a><a class="idref" href="Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(411, '0_3_55');
      "><br>
  - <span class="id" title="tactic">apply</span> (@<a class="idref" href="HoTT.Types.Sigma.html#transport_sigma"><span class="id" title="definition">transport_sigma</span></a> <span class="id" title="keyword">Type</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">A</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">A</span> <span class="id" title="var">m</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" title="abbreviation">IsHSet</span></a> <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" title="abbreviation">IsEmbedding</span></a> <a class="idref" href="HoTT.HIT.V.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#m"><span class="id" title="variable">m</span></a><a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a>) <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au"><span class="id" title="variable">Au</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.Au'"><span class="id" title="variable">Au'</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.path"><span class="id" title="variable">path</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mu"><span class="id" title="variable">mu</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <a class="idref" href="Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.h"><span class="id" title="variable">h</span></a><a class="idref" href="Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.mono"><span class="id" title="variable">mono</span></a><a class="idref" href="Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness.p"><span class="id" title="variable">p</span></a><a class="idref" href="Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(412, '0_3_55');
      "><br>
  - <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Sigma.html#path_sigma_hprop"><span class="id" title="definition">path_sigma_hprop</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(413, '0_3_55');
      "><br>
    <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.HIT.V.html#mu_eq_mu'"><span class="id" title="lemma">mu_eq_mu'</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(414, '0_3_55');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(415, '0_3_55');
      "><br>
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.HIT.V.html#AssumingUA.MonicSetPresent_Uniqueness"><span class="id" title="section">MonicSetPresent_Uniqueness</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(416, '0_3_55');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_55"><pre><span></span></pre></div>
<div class="doc" scenenumber="57">
This lemma actually says a little more than 10.5.6, i.e., that Au is a hSet 
</div>
<div scenenumber="59" class="code">
<span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(420, '0_3_59');
      ">
<span class="id" title="keyword">Lemma</span> <a name="monic_set_present"><span class="id" title="lemma">monic_set_present</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">u</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="Coq.Init.Specif.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">∃</span></a> <a class="idref" href="Coq.Init.Specif.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">(</span></a><span class="id" title="var">Au</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">m</span> : <a class="idref" href="HoTT.HIT.V.html#Au"><span class="id" title="variable">Au</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="Coq.Init.Specif.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">),</span></a><br>
  <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" title="abbreviation">IsHSet</span></a> <a class="idref" href="HoTT.HIT.V.html#Au"><span class="id" title="variable">Au</span></a><a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" title="abbreviation">IsEmbedding</span></a> <a class="idref" href="HoTT.HIT.V.html#m"><span class="id" title="variable">m</span></a><a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#m"><span class="id" title="variable">m</span></a><a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(421, '0_3_59');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(422, '0_3_59');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(423, '0_3_59');
      "><br>
  - <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(424, '0_3_59');
      "><br>
    <span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.Colimits.Quotient.html#quotient_kernel_factor"><span class="id" title="lemma">quotient_kernel_factor</span></a> <span class="id" title="var">f</span> (<a class="idref" href="HoTT.HIT.V.html#ker_bisim"><span class="id" title="definition">ker_bisim</span></a> <span class="id" title="var">f</span>) (<a class="idref" href="HoTT.HIT.V.html#ker_bisim_is_ker"><span class="id" title="definition">ker_bisim_is_ker</span></a> <span class="id" title="var">f</span>))<br>
      <span class="id" title="keyword">as</span> [<span class="id" title="var">Au</span> [<span class="id" title="var">eu</span> [<span class="id" title="var">mu</span> (((<span class="id" title="var">hset_Au</span>, <span class="id" title="var">epi_eu</span>), <span class="id" title="var">mono_mu</span>), <span class="id" title="var">factor</span>)]]].</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(425, '0_3_59');
      "><br>
    <span class="id" title="tactic">∃</span> <span class="id" title="var">Au</span>, <span class="id" title="var">mu</span>. </span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(426, '0_3_59');
      "><span class="id" title="tactic">split</span>;[<span class="id" title="tactic">exact</span> <a class="idref" href="Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><span class="id" title="var">hset_Au</span><a class="idref" href="Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <span class="id" title="var">mono_mu</span><a class="idref" href="Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>|].</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(427, '0_3_59');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#setext'"><span class="id" title="definition">setext'</span></a>; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(428, '0_3_59');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(429, '0_3_59');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> (<span class="id" title="var">eu</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(430, '0_3_59');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" title="definition">ap10</span></a> <span class="id" title="var">factor</span> <span class="id" title="var">a</span>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(431, '0_3_59');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">a'</span>. </span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(432, '0_3_59');
      "><span class="id" title="tactic">generalize</span> (<span class="id" title="var">epi_eu</span> <span class="id" title="var">a'</span>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(433, '0_3_59');
      "><br>
      <span class="id" title="tactic">intros</span> ?; <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1) <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Basics.Overture.html#center"><span class="id" title="projection">center</span></a> <span class="id" title="var">_</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(434, '0_3_59');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(435, '0_3_59');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(436, '0_3_59');
      "><span class="id" title="tactic">transitivity</span> (<span class="id" title="var">mu</span> (<span class="id" title="var">eu</span> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(437, '0_3_59');
      "><br>
      × <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" title="definition">ap10</span></a> <span class="id" title="var">factor</span> <span class="id" title="var">a</span>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(438, '0_3_59');
      "><br>
      × <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">mu</span> <span class="id" title="var">p</span>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(439, '0_3_59');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">v</span>. </span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(440, '0_3_59');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#hprop_allpath"><span class="id" title="lemma">hprop_allpath</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(441, '0_3_59');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">Au</span> [<span class="id" title="var">mu</span> ((<span class="id" title="var">hset</span>, <span class="id" title="var">mono</span>), <span class="id" title="var">p</span>)]].</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(442, '0_3_59');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">Au'</span> [<span class="id" title="var">mu'</span> ((<span class="id" title="var">hset'</span>, <span class="id" title="var">mono'</span>), <span class="id" title="var">p'</span>)]].</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(443, '0_3_59');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#monic_set_present_uniqueness"><span class="id" title="lemma">monic_set_present_uniqueness</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(444, '0_3_59');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(445, '0_3_59');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="type_of_members"><span class="id" title="definition">type_of_members</span></a> (<span class="id" title="var">u</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) : <span class="id" title="keyword">Type</span> := <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> (<a class="idref" href="HoTT.HIT.V.html#monic_set_present"><span class="id" title="lemma">monic_set_present</span></a> <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(446, '0_3_59');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a name="9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">"</span></a>[ u ]" := (<a class="idref" href="HoTT.HIT.V.html#type_of_members"><span class="id" title="definition">type_of_members</span></a> <span class="id" title="var">u</span>) : <span class="id" title="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(447, '0_3_59');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="func_of_members"><span class="id" title="definition">func_of_members</span></a> {<span class="id" title="var">u</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>} : <a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a><a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">]</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> := <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.HIT.V.html#monic_set_present"><span class="id" title="lemma">monic_set_present</span></a> <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a>)) : <a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a><a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">]</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(448, '0_3_59');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="is_hset_typeofmembers"><span class="id" title="definition">is_hset_typeofmembers</span></a> {<span class="id" title="var">u</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>} : <a class="idref" href="HoTT.Basics.Overture.html#IsHSet"><span class="id" title="abbreviation">IsHSet</span></a> (<a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a><a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">]</span></a>) := <a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.HIT.V.html#monic_set_present"><span class="id" title="lemma">monic_set_present</span></a> <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a>)))).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(449, '0_3_59');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="IsEmbedding_funcofmembers"><span class="id" title="definition">IsEmbedding_funcofmembers</span></a> {<span class="id" title="var">u</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>} : <a class="idref" href="HoTT.Basics.Trunc.html#IsEmbedding"><span class="id" title="abbreviation">IsEmbedding</span></a> <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> := <a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.HIT.V.html#monic_set_present"><span class="id" title="lemma">monic_set_present</span></a> <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a>)))).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(450, '0_3_59');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a name="is_valid_presentation"><span class="id" title="definition">is_valid_presentation</span></a> (<span class="id" title="var">u</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> := <a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<a class="idref" href="HoTT.HIT.V.html#monic_set_present"><span class="id" title="lemma">monic_set_present</span></a> <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a>))).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(451, '0_3_59');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_59"><pre><span></span></pre></div>
<div class="doc" scenenumber="61">
<a name="lab437"></a><h2 class="section">Lemmas 10.5.8 (i) &amp; (vii), we put them here because they are useful later</h2>
</div>
<div scenenumber="63" class="code">
<span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(458, '0_3_63');
      ">
<span class="id" title="keyword">Lemma</span> <a name="extensionality"><span class="id" title="lemma">extensionality</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">{</span></a><span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">},</span></a> <a class="idref" href="Coq.Init.Datatypes.html#4bfb4f2d0721ba668e3a802ab1b745a1"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#148945668c671cfec4e39166c697f7ca"><span class="id" title="notation">⊆</span></a> <a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.HIT.V.html#148945668c671cfec4e39166c697f7ca"><span class="id" title="notation">⊆</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="Coq.Init.Datatypes.html#4bfb4f2d0721ba668e3a802ab1b745a1"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#4bfb4f2d0721ba668e3a802ab1b745a1"><span class="id" title="notation">↔</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(459, '0_3_63');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(460, '0_3_63');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>). </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(461, '0_3_63');
      "><span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(462, '0_3_63');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>). </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(463, '0_3_63');
      "><span class="id" title="tactic">intros</span> <span class="id" title="var">B</span> <span class="id" title="var">g</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(464, '0_3_63');
      "><br>
  <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(465, '0_3_63');
      "><br>
  - <span class="id" title="tactic">intros</span> [<span class="id" title="var">H1</span> <span class="id" title="var">H2</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(466, '0_3_63');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#setext'"><span class="id" title="definition">setext'</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(467, '0_3_63');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(468, '0_3_63');
      "><br>
    + <span class="id" title="tactic">intro</span>. </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(469, '0_3_63');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">H1</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span>) (<a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a>1<a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>))).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(470, '0_3_63');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(471, '0_3_63');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(472, '0_3_63');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(473, '0_3_63');
      "><span class="id" title="tactic">exact</span> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(474, '0_3_63');
      "><br>
    + <span class="id" title="tactic">intro</span>. </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(475, '0_3_63');
      "><span class="id" title="tactic">apply</span> (<span class="id" title="var">H2</span> (<span class="id" title="var">g</span> <span class="id" title="var">b</span>)). </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(476, '0_3_63');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(477, '0_3_63');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(478, '0_3_63');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">z</span> <span class="id" title="var">Hz</span>. </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(479, '0_3_63');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">z</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="var">p</span> <span class="id" title="var">Hz</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(480, '0_3_63');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">z</span> <span class="id" title="var">Hz</span>. </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(481, '0_3_63');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">z</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <span class="id" title="var">Hz</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(482, '0_3_63');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(483, '0_3_63');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="mem_induction"><span class="id" title="lemma">mem_induction</span></a> (<span class="id" title="var">C</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>)<br>
: <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">v</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#C"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#C"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a><a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">v</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#C"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(484, '0_3_63');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(485, '0_3_63');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(486, '0_3_63');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(487, '0_3_63');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">H_f</span>. </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(488, '0_3_63');
      "><span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(489, '0_3_63');
      "><span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">Hx</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(490, '0_3_63');
      "><br>
  <span class="id" title="tactic">generalize</span> <span class="id" title="var">Hx</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(491, '0_3_63');
      "><br>
  <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(492, '0_3_63');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <span class="id" title="var">C</span> <span class="id" title="var">p</span> (<span class="id" title="var">H_f</span> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(493, '0_3_63');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(494, '0_3_63');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_63"><pre><span></span></pre></div>
<div class="doc" scenenumber="65">
<a name="lab438"></a><h2 class="section">Two useful lemmas</h2>
</div>
<div scenenumber="67" class="code">
<span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(501, '0_3_67');
      ">
<br>
<span class="id" title="keyword">Global Instance</span> <a name="irreflexive_mem"><span class="id" title="instance">irreflexive_mem</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#Irreflexive"><span class="id" title="class">Irreflexive</span></a> <a class="idref" href="HoTT.HIT.V.html#mem"><span class="id" title="definition">mem</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(502, '0_3_67');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(503, '0_3_67');
      "><br>
  <span class="id" title="tactic">assert</span> (<a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">v</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsHProp"><span class="id" title="abbreviation">IsHProp</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#complement"><span class="id" title="definition">complement</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> <span class="id" title="var">x0</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> ⇒ <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#x0"><span class="id" title="variable">x0</span></a>) <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a>)).   { </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(504, '0_3_67');
      "><span class="id" title="tactic">intro</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(505, '0_3_67');
      "><br>
    <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Basics.Overture.html#complement"><span class="id" title="definition">complement</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(506, '0_3_67');
      "><br>
    <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>. }<br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#mem_induction"><span class="id" title="lemma">mem_induction</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="HoTT.Basics.Trunc.html#BuildhProp"><span class="id" title="abbreviation">BuildhProp</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">¬</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>)) <span class="id" title="var">_</span>); <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> ×.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(507, '0_3_67');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">v</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(508, '0_3_67');
      "><span class="id" title="tactic">intro</span> <span class="id" title="var">Hv</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(509, '0_3_67');
      "><br>
  <span class="id" title="tactic">exact</span> (<span class="id" title="var">H</span> <span class="id" title="var">v</span> <span class="id" title="var">Hv</span> <span class="id" title="var">Hv</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(510, '0_3_67');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(511, '0_3_67');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="path_V_eqimg"><span class="id" title="lemma">path_V_eqimg</span></a> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} {<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.V.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>} {<span class="id" title="var">g</span> : <a class="idref" href="HoTT.HIT.V.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>} : <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <a class="idref" href="HoTT.HIT.V.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#equal_img"><span class="id" title="definition">equal_img</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#g"><span class="id" title="variable">g</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(512, '0_3_67');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(513, '0_3_67');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">p</span>. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(514, '0_3_67');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(515, '0_3_67');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(516, '0_3_67');
      "><br>
    <span class="id" title="tactic">assert</span> (<span class="id" title="var">H</span> : <span class="id" title="var">f</span> <span class="id" title="var">a</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <span class="id" title="var">g</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(517, '0_3_67');
      "><br>
    { <span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.HIT.V.html#extensionality"><span class="id" title="lemma">extensionality</span></a> <span class="id" title="var">p</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(518, '0_3_67');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">reflexivity</span>. }<br>
    <span class="id" title="tactic">generalize</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)). </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(519, '0_3_67');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p'</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(520, '0_3_67');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">p'</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(521, '0_3_67');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(522, '0_3_67');
      "><br>
    <span class="id" title="tactic">assert</span> (<span class="id" title="var">H</span> : <span class="id" title="var">g</span> <span class="id" title="var">b</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <span class="id" title="var">f</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(523, '0_3_67');
      "><br>
    { <span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.HIT.V.html#extensionality"><span class="id" title="lemma">extensionality</span></a> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(524, '0_3_67');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">reflexivity</span>. }<br>
    <span class="id" title="tactic">generalize</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)). </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(525, '0_3_67');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p'</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(526, '0_3_67');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">p'</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(527, '0_3_67');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(528, '0_3_67');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_67"><pre><span></span></pre></div>
<div class="doc" scenenumber="69">
<a name="lab439"></a><h2 class="section">Definitions of particular sets in V</h2>
<div class="doc" scenenumber="4"> </div>

 The empty set 
</div>
<div scenenumber="71" class="code">
<span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(537, '0_3_71');
      ">
<span class="id" title="keyword">Definition</span> <a name="V_empty"><span class="id" title="definition">V_empty</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> := <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#Empty_ind"><span class="id" title="definition">Empty_ind</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(538, '0_3_71');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_71"><pre><span></span></pre></div>
<div class="doc" scenenumber="73">
The singleton {u} 
</div>
<div scenenumber="75" class="code">
<span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(542, '0_3_75');
      ">
<span class="id" title="keyword">Definition</span> <a name="V_singleton"><span class="id" title="definition">V_singleton</span></a> (<span class="id" title="var">u</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V@</span></a>{<span class="id" title="var">U'</span> <span class="id" title="var">U</span>} := <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#Unit_ind"><span class="id" title="definition">Unit_ind</span></a> <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(543, '0_3_75');
      "><br>
<br>
<span class="id" title="keyword">Global Instance</span> <a name="isequiv_ap_V_singleton"><span class="id" title="instance">isequiv_ap_V_singleton</span></a> {<span class="id" title="var">u</span> <span class="id" title="var">v</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>}<br>
: <a class="idref" href="HoTT.Basics.Overture.html#IsEquiv"><span class="id" title="class">IsEquiv</span></a> (@<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.HIT.V.html#V_singleton"><span class="id" title="definition">V_singleton</span></a> <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(544, '0_3_75');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(545, '0_3_75');
      "><br>
  <span class="id" title="tactic">simple</span> <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#Build_IsEquiv"><span class="id" title="constructor">Build_IsEquiv</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>); <span class="id" title="tactic">try</span> <span class="id" title="tactic">solve</span> [ <span class="id" title="tactic">intro</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a> ].</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(546, '0_3_75');
      "><br>
  { <span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(547, '0_3_75');
      "><span class="id" title="tactic">specialize</span> (<a class="idref" href="HoTT.HIT.V.html#path_V_eqimg"><span class="id" title="lemma">path_V_eqimg</span></a> <span class="id" title="var">H</span>). </span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(548, '0_3_75');
      "><span class="id" title="tactic">intros</span> (<span class="id" title="var">H1</span>, <span class="id" title="var">H2</span>).</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(549, '0_3_75');
      "><br>
    <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">H1</span> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>)). </span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(550, '0_3_75');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">t</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(551, '0_3_75');
      "><span class="id" title="tactic">destruct</span> <span class="id" title="var">t</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">p</span>. }<br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(552, '0_3_75');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_75"><pre><span></span></pre></div>
<div class="doc" scenenumber="77">
The pair {u,v} 
</div>
<div scenenumber="79" class="code">
<span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(556, '0_3_79');
      ">
<span class="id" title="keyword">Definition</span> <a name="V_pair"><span class="id" title="definition">V_pair</span></a> (<span class="id" title="var">u</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">v</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V@</span></a>{<span class="id" title="var">U'</span> <span class="id" title="var">U</span>} := <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> : <a class="idref" href="HoTT.Types.Bool.html#Bool"><span class="id" title="inductive">Bool</span></a> ⇒ <span class="id" title="keyword">if</span> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a> <span class="id" title="keyword">then</span> <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a> <span class="id" title="keyword">else</span> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(557, '0_3_79');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="path_pair"><span class="id" title="lemma">path_pair</span></a> {<span class="id" title="var">u</span> <span class="id" title="var">v</span> <span class="id" title="var">u'</span> <span class="id" title="var">v'</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V@</span></a>{<span class="id" title="var">U'</span> <span class="id" title="var">U</span>}} : <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#u'"><span class="id" title="variable">u'</span></a><a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#v'"><span class="id" title="variable">v'</span></a><a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V_pair"><span class="id" title="definition">V_pair</span></a> <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#V_pair"><span class="id" title="definition">V_pair</span></a> <a class="idref" href="HoTT.HIT.V.html#u'"><span class="id" title="variable">u'</span></a> <a class="idref" href="HoTT.HIT.V.html#v'"><span class="id" title="variable">v'</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(558, '0_3_79');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(559, '0_3_79');
      "><br>
  <span class="id" title="tactic">intros</span> (<span class="id" title="var">H1</span>, <span class="id" title="var">H2</span>). </span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(560, '0_3_79');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#setext'"><span class="id" title="definition">setext'</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(561, '0_3_79');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(562, '0_3_79');
      "><br>
  + <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Bool.html#Bool_ind"><span class="id" title="definition">Bool_ind</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(563, '0_3_79');
      "><br>
    × <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(564, '0_3_79');
      "><span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(565, '0_3_79');
      "><br>
    × <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>; <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(566, '0_3_79');
      "><br>
  + <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Bool.html#Bool_ind"><span class="id" title="definition">Bool_ind</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(567, '0_3_79');
      "><br>
    × <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>; <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(568, '0_3_79');
      "><br>
    × <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>; <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(569, '0_3_79');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(570, '0_3_79');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="pair_eq_singleton"><span class="id" title="lemma">pair_eq_singleton</span></a> {<span class="id" title="var">u</span> <span class="id" title="var">v</span> <span class="id" title="var">w</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>} : <a class="idref" href="HoTT.HIT.V.html#V_pair"><span class="id" title="definition">V_pair</span></a> <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#V_singleton"><span class="id" title="definition">V_singleton</span></a> <a class="idref" href="HoTT.HIT.V.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="Coq.Init.Datatypes.html#4bfb4f2d0721ba668e3a802ab1b745a1"><span class="id" title="notation">↔</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#w"><span class="id" title="variable">w</span></a><a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#w"><span class="id" title="variable">w</span></a><a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(571, '0_3_79');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(572, '0_3_79');
      "><br>
  <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(573, '0_3_79');
      "><br>
  + <span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(574, '0_3_79');
      "><span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.HIT.V.html#path_V_eqimg"><span class="id" title="lemma">path_V_eqimg</span></a> <span class="id" title="var">H</span>) <span class="id" title="keyword">as</span> (<span class="id" title="var">H1</span>, <span class="id" title="var">H2</span>).</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(575, '0_3_79');
      "><br>
    <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">H1</span> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>)). </span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(576, '0_3_79');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">t</span> <span class="id" title="var">p</span>]; <span class="id" title="tactic">destruct</span> <span class="id" title="var">t</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(577, '0_3_79');
      "><br>
    <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">H1</span> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>)). </span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(578, '0_3_79');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">t</span> <span class="id" title="var">p'</span>]; <span class="id" title="tactic">destruct</span> <span class="id" title="var">t</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(579, '0_3_79');
      "><br>
    <span class="id" title="tactic">split</span>; [<span class="id" title="tactic">exact</span> <span class="id" title="var">p</span>| <span class="id" title="tactic">exact</span> <span class="id" title="var">p'</span>].</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(580, '0_3_79');
      "><br>
  + <span class="id" title="tactic">intros</span> (<span class="id" title="var">p1</span>, <span class="id" title="var">p2</span>). </span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(581, '0_3_79');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#setext'"><span class="id" title="definition">setext'</span></a>; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(582, '0_3_79');
      "><br>
    × <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(583, '0_3_79');
      "><span class="id" title="tactic">destruct</span> <span class="id" title="var">a</span>; [<span class="id" title="tactic">exact</span> <span class="id" title="var">p1</span> | <span class="id" title="tactic">exact</span> <span class="id" title="var">p2</span>].</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(584, '0_3_79');
      "><br>
    × <span class="id" title="tactic">intro</span> <span class="id" title="var">t</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(585, '0_3_79');
      "><span class="id" title="tactic">destruct</span> <span class="id" title="var">t</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">p1</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(586, '0_3_79');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(587, '0_3_79');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_79"><pre><span></span></pre></div>
<div class="doc" scenenumber="81">
The ordered pair (u,v) 
</div>
<div scenenumber="83" class="code">
<span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(591, '0_3_83');
      ">
<span class="id" title="keyword">Definition</span> <a name="V_pair_ord"><span class="id" title="definition">V_pair_ord</span></a> (<span class="id" title="var">u</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">v</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> := <a class="idref" href="HoTT.HIT.V.html#V_pair"><span class="id" title="definition">V_pair</span></a> (<a class="idref" href="HoTT.HIT.V.html#V_singleton"><span class="id" title="definition">V_singleton</span></a> <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a>) (<a class="idref" href="HoTT.HIT.V.html#V_pair"><span class="id" title="definition">V_pair</span></a> <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(592, '0_3_83');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a name="5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">"</span></a> [ u , v ] " := (<a class="idref" href="HoTT.HIT.V.html#V_pair_ord"><span class="id" title="definition">V_pair_ord</span></a> <span class="id" title="var">u</span> <span class="id" title="var">v</span>) : <span class="id" title="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(593, '0_3_83');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="path_pair_ord"><span class="id" title="lemma">path_pair_ord</span></a> {<span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> <span class="id" title="var">d</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>} : <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#c"><span class="id" title="variable">c</span></a><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#d"><span class="id" title="variable">d</span></a><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a> <a class="idref" href="Coq.Init.Datatypes.html#4bfb4f2d0721ba668e3a802ab1b745a1"><span class="id" title="notation">↔</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#c"><span class="id" title="variable">c</span></a><a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#d"><span class="id" title="variable">d</span></a><a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(594, '0_3_83');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(595, '0_3_83');
      "><br>
  <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(596, '0_3_83');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">p</span>. </span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(597, '0_3_83');
      "><span class="id" title="tactic">assert</span> (<span class="id" title="var">p1</span> : <span class="id" title="var">a</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="var">c</span>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(598, '0_3_83');
      "><br>
    + <span class="id" title="tactic">assert</span> (<span class="id" title="var">H</span> : <a class="idref" href="HoTT.HIT.V.html#V_singleton"><span class="id" title="definition">V_singleton</span></a> <span class="id" title="var">a</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><span class="id" title="var">c</span><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a> <span class="id" title="var">d</span><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(599, '0_3_83');
      "><br>
      { <span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.HIT.V.html#extensionality"><span class="id" title="lemma">extensionality</span></a> <span class="id" title="var">p</span>). </span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(600, '0_3_83');
      "><span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(601, '0_3_83');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a>; <span class="id" title="tactic">reflexivity</span>. }<br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> <span class="id" title="var">H</span>). </span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(602, '0_3_83');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">t</span> <span class="id" title="var">p'</span>]; <span class="id" title="tactic">destruct</span> <span class="id" title="var">t</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(603, '0_3_83');
      "><br>
      × <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.HIT.V.html#V_singleton"><span class="id" title="definition">V_singleton</span></a><a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">)^-1</span></a> <span class="id" title="var">p'</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(604, '0_3_83');
      "><br>
      × <span class="id" title="tactic">symmetry</span>; <span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.HIT.V.html#pair_eq_singleton"><span class="id" title="lemma">pair_eq_singleton</span></a> <span class="id" title="var">p'</span>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(605, '0_3_83');
      "><br>
    + <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(606, '0_3_83');
      "><br>
      × <span class="id" title="tactic">exact</span> <span class="id" title="var">p1</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(607, '0_3_83');
      "><br>
      × <span class="id" title="tactic">assert</span> (<span class="id" title="var">H</span> : <a class="idref" href="HoTT.Truncations.Core.html#hor"><span class="id" title="definition">hor</span></a> (<span class="id" title="var">b</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="var">c</span>) (<span class="id" title="var">b</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="var">d</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(608, '0_3_83');
      "><br>
        { <span class="id" title="tactic">assert</span> (<span class="id" title="var">H'</span> : <a class="idref" href="HoTT.HIT.V.html#V_pair"><span class="id" title="definition">V_pair</span></a> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><span class="id" title="var">c</span><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a> <span class="id" title="var">d</span><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(609, '0_3_83');
      "><br>
          { <span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.HIT.V.html#extensionality"><span class="id" title="lemma">extensionality</span></a> <span class="id" title="var">p</span>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(610, '0_3_83');
      "><br>
            <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>; <span class="id" title="tactic">reflexivity</span>. }<br>
          <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> <span class="id" title="var">H'</span>). </span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(611, '0_3_83');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">t</span> <span class="id" title="var">p'</span>]; <span class="id" title="tactic">destruct</span> <span class="id" title="var">t</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(612, '0_3_83');
      "><br>
          - <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">left</span>. </span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(613, '0_3_83');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.HIT.V.html#pair_eq_singleton"><span class="id" title="lemma">pair_eq_singleton</span></a> <span class="id" title="var">p'</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(614, '0_3_83');
      "><br>
          - <span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.HIT.V.html#path_V_eqimg"><span class="id" title="lemma">path_V_eqimg</span></a> <span class="id" title="var">p'</span>) <span class="id" title="keyword">as</span> (<span class="id" title="var">H1</span>, <span class="id" title="var">H2</span>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(615, '0_3_83');
      "><br>
            <span class="id" title="tactic">generalize</span> (<span class="id" title="var">H2</span> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>); <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(616, '0_3_83');
      "><br>
            <span class="id" title="tactic">intros</span> [<span class="id" title="var">t</span> <span class="id" title="var">p''</span>]; <span class="id" title="tactic">destruct</span> <span class="id" title="var">t</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(617, '0_3_83');
      "><br>
            + <span class="id" title="tactic">left</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">p''</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(618, '0_3_83');
      "><br>
            + <span class="id" title="tactic">right</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">p''</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>. }<br>
        <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a> <span class="id" title="var">_</span> <span class="id" title="var">H</span>). </span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(619, '0_3_83');
      "><span class="id" title="tactic">intro</span> <span class="id" title="tactic">case</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="tactic">case</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">p'</span>| <span class="id" title="var">p'</span>].</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(620, '0_3_83');
      "><br>
        2: <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(621, '0_3_83');
      "><br>
        <span class="id" title="tactic">assert</span> (<span class="id" title="var">H'</span> : <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><span class="id" title="var">a</span><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a> <span class="id" title="var">b</span><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#V_singleton"><span class="id" title="definition">V_singleton</span></a> (<a class="idref" href="HoTT.HIT.V.html#V_singleton"><span class="id" title="definition">V_singleton</span></a> <span class="id" title="var">b</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(622, '0_3_83');
      "><br>
        { <span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.HIT.V.html#pair_eq_singleton"><span class="id" title="lemma">pair_eq_singleton</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(623, '0_3_83');
      "><br>
          <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(624, '0_3_83');
      "><br>
          - <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>; <span class="id" title="tactic">exact</span> (<span class="id" title="var">p1</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">p'</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(625, '0_3_83');
      "><br>
          - <span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.HIT.V.html#pair_eq_singleton"><span class="id" title="lemma">pair_eq_singleton</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(626, '0_3_83');
      "><br>
            <span class="id" title="tactic">split</span>; [<span class="id" title="tactic">exact</span> (<span class="id" title="var">p1</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">p'</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>) | <span class="id" title="tactic">reflexivity</span>]. }</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(627, '0_3_83');
      "><br>
        <span class="id" title="tactic">assert</span> (<span class="id" title="var">H''</span> : <a class="idref" href="HoTT.HIT.V.html#V_pair"><span class="id" title="definition">V_pair</span></a> <span class="id" title="var">c</span> <span class="id" title="var">d</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#V_singleton"><span class="id" title="definition">V_singleton</span></a> <span class="id" title="var">b</span>)<br>
          <span class="id" title="tactic">by</span> <span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.HIT.V.html#pair_eq_singleton"><span class="id" title="lemma">pair_eq_singleton</span></a> (<span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">H'</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(628, '0_3_83');
      "><br>
        <span class="id" title="tactic">symmetry</span>; <span class="id" title="tactic">apply</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.HIT.V.html#pair_eq_singleton"><span class="id" title="lemma">pair_eq_singleton</span></a> <span class="id" title="var">H''</span>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(629, '0_3_83');
      "><br>
  - <span class="id" title="tactic">intros</span> (<span class="id" title="var">p</span>, <span class="id" title="var">p'</span>).</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(630, '0_3_83');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#path_pair"><span class="id" title="lemma">path_pair</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(631, '0_3_83');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(632, '0_3_83');
      "><br>
    + <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>; <span class="id" title="tactic">exact</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(633, '0_3_83');
      "><br>
    + <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#path_pair"><span class="id" title="lemma">path_pair</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(634, '0_3_83');
      "><span class="id" title="tactic">split</span>; <span class="id" title="tactic">assumption</span>; <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(635, '0_3_83');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(636, '0_3_83');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_83"><pre><span></span></pre></div>
<div class="doc" scenenumber="85">
The cartesian product a × b 
</div>
<div scenenumber="87" class="code">
<span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(640, '0_3_87');
      ">
<span class="id" title="keyword">Definition</span> <a name="V_cart_prod"><span class="id" title="definition">V_cart_prod</span></a> (<span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><br>
:= <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">]</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">]</span></a> ⇒ <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>)<a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>)<a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(641, '0_3_87');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a name="c7797332d94cc7591d117bb1d3b33b33"><span class="id" title="notation">"</span></a> a × b " := (<a class="idref" href="HoTT.HIT.V.html#V_cart_prod"><span class="id" title="definition">V_cart_prod</span></a> <span class="id" title="var">a</span> <span class="id" title="var">b</span>) : <span class="id" title="var">set_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(642, '0_3_87');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_87"><pre><span></span></pre></div>
<div class="doc" scenenumber="89">
f is a function with domain a and codomain b 
</div>
<div scenenumber="91" class="code">
<span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(646, '0_3_91');
      ">
<span class="id" title="keyword">Definition</span> <a name="V_is_func"><span class="id" title="definition">V_is_func</span></a> (<span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) := <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#148945668c671cfec4e39166c697f7ca"><span class="id" title="notation">⊆</span></a> <a class="idref" href="HoTT.HIT.V.html#148945668c671cfec4e39166c697f7ca"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.HIT.V.html#c7797332d94cc7591d117bb1d3b33b33"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.HIT.V.html#148945668c671cfec4e39166c697f7ca"><span class="id" title="notation">)</span></a><br>
 <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a><a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a>)<a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a><br>
 <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">y'</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a><a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a><a class="idref" href="HoTT.HIT.V.html#y'"><span class="id" title="variable">y'</span></a><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#y'"><span class="id" title="variable">y'</span></a><a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(647, '0_3_91');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_91"><pre><span></span></pre></div>
<div class="doc" scenenumber="93">
The set of functions from a to b 
</div>
<div scenenumber="95" class="code">
<span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(651, '0_3_95');
      ">
<span class="id" title="keyword">Definition</span> <a name="V_func"><span class="id" title="definition">V_func</span></a> (<span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><br>
:= @<a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (<a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">]</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">]</span></a>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">f</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<a class="idref" href="HoTT.HIT.V.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>)<a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a> )).</span><span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(652, '0_3_95');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_95"><pre><span></span></pre></div>
<div class="doc" scenenumber="97">
The union of a set Uv 
</div>
<div scenenumber="99" class="code">
<span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(656, '0_3_99');
      ">
<span class="id" title="keyword">Definition</span> <a name="V_union"><span class="id" title="definition">V_union</span></a> (<span class="id" title="var">v</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) :=<br>
  @<a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (<a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><span class="id" title="var">x</span> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a><a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">]</span></a> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">]</span></a><a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(657, '0_3_99');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_99"><pre><span></span></pre></div>
<div class="doc" scenenumber="101">
The ordinal successor x ∪ {x} 
</div>
<div scenenumber="103" class="code">
<span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(661, '0_3_103');
      ">
<span class="id" title="keyword">Definition</span> <a name="V_succ"><span class="id" title="definition">V_succ</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(662, '0_3_103');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(663, '0_3_103');
      "><br>
  <span class="id" title="tactic">simple</span> <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_rec'"><span class="id" title="definition">V_rec'</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(664, '0_3_103');
      "><br>
  - <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(665, '0_3_103');
      "><br>
    <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (<span class="id" title="keyword">fun</span> (<span class="id" title="var">x</span> : <span class="id" title="var">A</span> <a class="idref" href="Coq.Init.Datatypes.html#e03f39daf98516fa530d3f6f5a1b4d92"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Basics.Overture.html#Unit"><span class="id" title="inductive">Unit</span></a>) ⇒ <span class="id" title="keyword">match</span> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="keyword">with</span> <a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">a</span> ⇒ <span class="id" title="var">f</span> <span class="id" title="var">a</span><br>
                                           | <a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> ⇒ <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> <span class="id" title="var">f</span> <span class="id" title="keyword">end</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(666, '0_3_103');
      "><br>
  - <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> <span class="id" title="var">eq_img</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>. </span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(667, '0_3_103');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#setext'"><span class="id" title="definition">setext'</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(668, '0_3_103');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(669, '0_3_103');
      "><br>
    + <span class="id" title="tactic">intro</span>. </span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(670, '0_3_103');
      "><span class="id" title="tactic">destruct</span> <span class="id" title="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(671, '0_3_103');
      "><br>
      × <span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">eq_img</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(672, '0_3_103');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(673, '0_3_103');
      "><br>
        <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(674, '0_3_103');
      "><span class="id" title="tactic">∃</span> (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">b</span>); <span class="id" title="tactic">exact</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(675, '0_3_103');
      "><br>
      × <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>). </span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(676, '0_3_103');
      "><span class="id" title="tactic">destruct</span> <span class="id" title="var">u</span>. </span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(677, '0_3_103');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#setext'"><span class="id" title="definition">setext'</span></a>; <span class="id" title="tactic">auto</span>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(678, '0_3_103');
      "><br>
    + <span class="id" title="tactic">intro</span>. </span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(679, '0_3_103');
      "><span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(680, '0_3_103');
      "><br>
      × <span class="id" title="tactic">generalize</span> (<a class="idref" href="Coq.Init.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">eq_img</span> <span class="id" title="var">b</span>). </span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(681, '0_3_103');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(682, '0_3_103');
      "><br>
        <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(683, '0_3_103');
      "><span class="id" title="tactic">∃</span> (<a class="idref" href="Coq.Init.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">a</span>); <span class="id" title="tactic">exact</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(684, '0_3_103');
      "><br>
      × <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> (<a class="idref" href="Coq.Init.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>). </span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(685, '0_3_103');
      "><span class="id" title="tactic">destruct</span> <span class="id" title="var">u</span>. </span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(686, '0_3_103');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#setext'"><span class="id" title="definition">setext'</span></a>; <span class="id" title="tactic">auto</span>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(687, '0_3_103');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(688, '0_3_103');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_103"><pre><span></span></pre></div>
<div class="doc" scenenumber="105">
The set of finite ordinals 
</div>
<div scenenumber="107" class="code">
<span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(692, '0_3_107');
      ">
<span class="id" title="keyword">Definition</span> <a name="V_omega"><span class="id" title="definition">V_omega</span></a> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><br>
:= <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (<span class="id" title="keyword">fix</span> <span class="id" title="var">I</span> <span class="id" title="var">n</span> := <span class="id" title="keyword">match</span> <a class="idref" href="HoTT.HIT.V.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">with</span> 0   ⇒ <a class="idref" href="HoTT.HIT.V.html#V_empty"><span class="id" title="definition">V_empty</span></a><br>
                              | <a class="idref" href="Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#V_succ"><span class="id" title="definition">V_succ</span></a> (<a class="idref" href="HoTT.HIT.V.html#I"><span class="id" title="variable">I</span></a> <a class="idref" href="HoTT.HIT.V.html#n"><span class="id" title="variable">n</span></a>) <span class="id" title="keyword">end</span>).</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(693, '0_3_107');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_107"><pre><span></span></pre></div>
<div class="doc" scenenumber="109">
<a name="lab440"></a><h2 class="section">Axioms of set theory (theorem 10.5.8)</h2>
</div>
<div scenenumber="111" class="code">
<span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(700, '0_3_111');
      ">
<br>
<span class="id" title="keyword">Lemma</span> <a name="not_mem_Vempty"><span class="id" title="lemma">not_mem_Vempty</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">¬</span></a> <a class="idref" href="HoTT.Basics.Overture.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#V_empty"><span class="id" title="definition">V_empty</span></a><a class="idref" href="HoTT.Basics.Overture.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(701, '0_3_111');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(702, '0_3_111');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">Hx</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(703, '0_3_111');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">Hx</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(704, '0_3_111');
      "><br>
  <span class="id" title="tactic">intros</span> [<span class="id" title="var">ff</span> <span class="id" title="var">_</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(705, '0_3_111');
      "><span class="id" title="tactic">exact</span> <span class="id" title="var">ff</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(706, '0_3_111');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(707, '0_3_111');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="pairing"><span class="id" title="lemma">pairing</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">u</span> <span class="id" title="var">v</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">w</span> ⇒ <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="Coq.Init.Datatypes.html#4bfb4f2d0721ba668e3a802ab1b745a1"><span class="id" title="notation">↔</span></a> <a class="idref" href="HoTT.Truncations.Core.html#hor"><span class="id" title="definition">hor</span></a> (<a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a>) (<a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(708, '0_3_111');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(709, '0_3_111');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">u</span> <span class="id" title="var">v</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(710, '0_3_111');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(711, '0_3_111');
      "><span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.HIT.V.html#V_pair"><span class="id" title="definition">V_pair</span></a> <span class="id" title="var">u</span> <span class="id" title="var">v</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(712, '0_3_111');
      "><br>
  <span class="id" title="tactic">intro</span>; <span class="id" title="tactic">split</span>; <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(713, '0_3_111');
      "><br>
  - <span class="id" title="tactic">intros</span> [[|] <span class="id" title="var">p</span>]; [<span class="id" title="tactic">left</span>|<span class="id" title="tactic">right</span>]; <span class="id" title="tactic">exact</span> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(714, '0_3_111');
      "><br>
  - <span class="id" title="tactic">intros</span> [<span class="id" title="var">p</span> | <span class="id" title="var">p</span>]; [<span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#true"><span class="id" title="constructor">true</span></a> | <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Types.Bool.html#false"><span class="id" title="constructor">false</span></a>]; <span class="id" title="tactic">exact</span> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(715, '0_3_111');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(716, '0_3_111');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="infinity"><span class="id" title="lemma">infinity</span></a> : <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#V_empty"><span class="id" title="definition">V_empty</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#V_omega"><span class="id" title="definition">V_omega</span></a><a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#V_omega"><span class="id" title="definition">V_omega</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V_succ"><span class="id" title="definition">V_succ</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#V_omega"><span class="id" title="definition">V_omega</span></a><a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(717, '0_3_111');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(718, '0_3_111');
      "><br>
  <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(719, '0_3_111');
      "><br>
  - <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> 0; <span class="id" title="tactic">auto</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(720, '0_3_111');
      "><br>
  - <span class="id" title="tactic">intro</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(721, '0_3_111');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(722, '0_3_111');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">n</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(723, '0_3_111');
      "><span class="id" title="tactic">∃</span> (<a class="idref" href="Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n</span>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(724, '0_3_111');
      "><span class="id" title="tactic">rewrite</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">auto</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(725, '0_3_111');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(726, '0_3_111');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="union"><span class="id" title="lemma">union</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">v</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">w</span> ⇒ <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="Coq.Init.Datatypes.html#4bfb4f2d0721ba668e3a802ab1b745a1"><span class="id" title="notation">↔</span></a> <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">u</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(727, '0_3_111');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(728, '0_3_111');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">v</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(729, '0_3_111');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.HIT.V.html#V_union"><span class="id" title="definition">V_union</span></a> <span class="id" title="var">v</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(730, '0_3_111');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(731, '0_3_111');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(732, '0_3_111');
      "><span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(733, '0_3_111');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(734, '0_3_111');
      "><br>
    <span class="id" title="tactic">intros</span> [[<span class="id" title="var">u'</span> <span class="id" title="var">x'</span>] <span class="id" title="var">p</span>]; <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(735, '0_3_111');
      "><br>
    <span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">u'</span>); <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(736, '0_3_111');
      "><br>
    + <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <span class="id" title="var">x</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#is_valid_presentation"><span class="id" title="definition">is_valid_presentation</span></a> (<a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">u'</span>)<a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(737, '0_3_111');
      "><br>
      <span class="id" title="tactic">simpl</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(738, '0_3_111');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">x'</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(739, '0_3_111');
      "><span class="id" title="tactic">exact</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(740, '0_3_111');
      "><br>
    + <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">u'</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#is_valid_presentation"><span class="id" title="definition">is_valid_presentation</span></a> <span class="id" title="var">v</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(741, '0_3_111');
      "><br>
      <span class="id" title="tactic">simpl</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(742, '0_3_111');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">u'</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(743, '0_3_111');
      "><br>
  - <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(744, '0_3_111');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">u</span> (<span class="id" title="var">Hx</span>, <span class="id" title="var">Hu</span>)].</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(745, '0_3_111');
      "><br>
    <span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <span class="id" title="var">u</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a>) (<a class="idref" href="HoTT.HIT.V.html#is_valid_presentation"><span class="id" title="definition">is_valid_presentation</span></a> <span class="id" title="var">v</span>) <span class="id" title="var">Hu</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(746, '0_3_111');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(747, '0_3_111');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">u'</span> <span class="id" title="var">pu</span>].</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(748, '0_3_111');
      "><br>
    <span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <span class="id" title="var">x</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a>) (<a class="idref" href="HoTT.HIT.V.html#is_valid_presentation"><span class="id" title="definition">is_valid_presentation</span></a> (<a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">u'</span>)) (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <span class="id" title="var">x</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a>) <span class="id" title="var">pu</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <span class="id" title="var">Hx</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(749, '0_3_111');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(750, '0_3_111');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">x'</span> <span class="id" title="var">px</span>].</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(751, '0_3_111');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(752, '0_3_111');
      "><span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">u'</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <span class="id" title="var">x'</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(753, '0_3_111');
      "><span class="id" title="tactic">exact</span> <span class="id" title="var">px</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(754, '0_3_111');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(755, '0_3_111');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="function"><span class="id" title="lemma">function</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">u</span> <span class="id" title="var">v</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">w</span> ⇒ <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="Coq.Init.Datatypes.html#4bfb4f2d0721ba668e3a802ab1b745a1"><span class="id" title="notation">↔</span></a> <a class="idref" href="HoTT.HIT.V.html#V_is_func"><span class="id" title="definition">V_is_func</span></a> <a class="idref" href="HoTT.HIT.V.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="HoTT.HIT.V.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(756, '0_3_111');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(757, '0_3_111');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">u</span> <span class="id" title="var">v</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(758, '0_3_111');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.HIT.V.html#V_func"><span class="id" title="definition">V_func</span></a> <span class="id" title="var">u</span> <span class="id" title="var">v</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(759, '0_3_111');
      "><br>
  <span class="id" title="tactic">assert</span> (<span class="id" title="var">memb_u</span> : <span class="id" title="var">u</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (@<a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">u</span>)) <span class="id" title="tactic">by</span> <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.HIT.V.html#is_valid_presentation"><span class="id" title="definition">is_valid_presentation</span></a> <span class="id" title="var">u</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(760, '0_3_111');
      "><br>
  <span class="id" title="tactic">assert</span> (<span class="id" title="var">memb_v</span> : <span class="id" title="var">v</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (@<a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">v</span>)) <span class="id" title="tactic">by</span> <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.HIT.V.html#is_valid_presentation"><span class="id" title="definition">is_valid_presentation</span></a> <span class="id" title="var">v</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(761, '0_3_111');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">phi</span>; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(762, '0_3_111');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(763, '0_3_111');
      "><span class="id" title="tactic">split</span>;[<span class="id" title="tactic">split</span>|].</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(764, '0_3_111');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">z</span> <span class="id" title="var">Hz</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(765, '0_3_111');
      "><span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> ×. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(766, '0_3_111');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">H</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(767, '0_3_111');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(768, '0_3_111');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">h</span> <span class="id" title="var">p_phi</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(769, '0_3_111');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">z</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="var">p_phi</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <span class="id" title="var">Hz</span>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(770, '0_3_111');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(771, '0_3_111');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(772, '0_3_111');
      "><span class="id" title="tactic">∃</span> <a class="idref" href="Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span><a class="idref" href="Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <span class="id" title="var">h</span> <span class="id" title="var">a</span><a class="idref" href="Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(773, '0_3_111');
      "><span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(774, '0_3_111');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">Hx</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(775, '0_3_111');
      "><span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> ⇒ <span class="id" title="var">x</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a>) <span class="id" title="var">memb_u</span> <span class="id" title="var">Hx</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(776, '0_3_111');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(777, '0_3_111');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(778, '0_3_111');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(779, '0_3_111');
      "><br>
      <span class="id" title="tactic">intros</span> [<span class="id" title="var">h</span> <span class="id" title="var">p_phi</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(780, '0_3_111');
      "><span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">a</span>)). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(781, '0_3_111');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(782, '0_3_111');
      "><br>
      × <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">a</span>) <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a>) <span class="id" title="var">memb_v</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">h</span> <span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> 1<a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(783, '0_3_111');
      "><br>
      × <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><span class="id" title="var">x</span><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">a</span>)<a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a>) <span class="id" title="var">p_phi</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(784, '0_3_111');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(785, '0_3_111');
      "><span class="id" title="tactic">rewrite</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(786, '0_3_111');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">y'</span> (<span class="id" title="var">Hy</span>, <span class="id" title="var">Hy'</span>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(787, '0_3_111');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(788, '0_3_111');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">h</span> <span class="id" title="var">p_phi</span>].</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(789, '0_3_111');
      "><br>
      <span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><span class="id" title="var">x</span><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a> <span class="id" title="var">y</span><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a>) <span class="id" title="var">p_phi</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <span class="id" title="var">Hy</span>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(790, '0_3_111');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(791, '0_3_111');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>].</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(792, '0_3_111');
      "><br>
      <span class="id" title="tactic">generalize</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><span class="id" title="var">x</span><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a> <span class="id" title="var">y'</span><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a>) <span class="id" title="var">p_phi</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <span class="id" title="var">Hy'</span>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(793, '0_3_111');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(794, '0_3_111');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">a'</span> <span class="id" title="var">p'</span>].</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(795, '0_3_111');
      "><br>
      <span class="id" title="tactic">destruct</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.HIT.V.html#path_pair_ord"><span class="id" title="lemma">path_pair_ord</span></a> <span class="id" title="var">p</span>) <span class="id" title="keyword">as</span> (<span class="id" title="var">px</span>, <span class="id" title="var">py</span>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(796, '0_3_111');
      "><span class="id" title="tactic">destruct</span> (<a class="idref" href="Coq.Init.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.HIT.V.html#path_pair_ord"><span class="id" title="lemma">path_pair_ord</span></a> <span class="id" title="var">p'</span>) <span class="id" title="keyword">as</span> (<span class="id" title="var">px'</span>, <span class="id" title="var">py'</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(797, '0_3_111');
      "><br>
      <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">a</span>)); <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">path_hints</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(798, '0_3_111');
      "><span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">a'</span>));<span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">path_hints</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(799, '0_3_111');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">_</span>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(800, '0_3_111');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">h</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(801, '0_3_111');
      "><br>
      <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HSet.html#isinj_embedding"><span class="id" title="lemma">isinj_embedding</span></a> <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <a class="idref" href="HoTT.HIT.V.html#IsEmbedding_funcofmembers"><span class="id" title="definition">IsEmbedding_funcofmembers</span></a> <span class="id" title="var">a</span> <span class="id" title="var">a'</span> (<span class="id" title="var">px</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">px'</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(802, '0_3_111');
      "><br>
  - <span class="id" title="tactic">intros</span> ((<span class="id" title="var">H1</span>, <span class="id" title="var">H2</span>), <span class="id" title="var">H3</span>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(803, '0_3_111');
      "><span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(804, '0_3_111');
      "><br>
    <span class="id" title="tactic">assert</span> (<span class="id" title="var">h</span> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">[</span></a><span class="id" title="var">u</span><a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">]</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><span class="id" title="var">b</span> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">[</span></a><span class="id" title="var">v</span><a class="idref" href="HoTT.HIT.V.html#9e940231d243ed642093049b7e46ee99"><span class="id" title="notation">]</span></a> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <a class="idref" href="HoTT.HIT.V.html#b"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <span class="id" title="var">phi</span><a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(805, '0_3_111');
      "><br>
    { <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(806, '0_3_111');
      "><span class="id" title="tactic">pose</span> (<span class="id" title="var">x</span> := <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">a</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(807, '0_3_111');
      "><br>
      <span class="id" title="var">transparent</span> <span class="id" title="tactic">assert</span> (<span class="id" title="var">H</span> : <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><span class="id" title="var">y</span> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <span class="id" title="var">v</span> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><span class="id" title="var">x</span><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <span class="id" title="var">phi</span><a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(808, '0_3_111');
      "><br>
      - <span class="id" title="tactic">refine</span> (@<a class="idref" href="HoTT.Truncations.Core.html#untrunc_istrunc"><span class="id" title="definition">untrunc_istrunc</span></a> (-1) <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><span class="id" title="var">y</span> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <span class="id" title="var">v</span> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><span class="id" title="var">x</span><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <span class="id" title="var">phi</span><a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a> <span class="id" title="var">_</span><br>
                                 (<span class="id" title="var">H2</span> <span class="id" title="var">x</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <span class="id" title="var">x</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a>) <span class="id" title="var">memb_u</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> 1<a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>)))).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(809, '0_3_111');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#hprop_allpath"><span class="id" title="lemma">hprop_allpath</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(810, '0_3_111');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">y</span> (<span class="id" title="var">H1_y</span>, <span class="id" title="var">H2_y</span>)] [<span class="id" title="var">y'</span> (<span class="id" title="var">H1_y'</span>, <span class="id" title="var">H2_y'</span>)].</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(811, '0_3_111');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Sigma.html#path_sigma_uncurried"><span class="id" title="definition">path_sigma_uncurried</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(812, '0_3_111');
      "><br>
        <span class="id" title="tactic">∃</span> (<span class="id" title="var">H3</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">y'</span> <a class="idref" href="Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><span class="id" title="var">H2_y</span><a class="idref" href="Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <span class="id" title="var">H2_y'</span><a class="idref" href="Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(813, '0_3_111');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(814, '0_3_111');
      "><br>
      - <span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">y</span> (<span class="id" title="var">H1_y</span>, <span class="id" title="var">H2_y</span>)].</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(815, '0_3_111');
      "><br>
        <span class="id" title="tactic">destruct</span> (@<a class="idref" href="HoTT.Truncations.Core.html#untrunc_istrunc"><span class="id" title="definition">untrunc_istrunc</span></a> (-1) <span class="id" title="var">_</span> (<a class="idref" href="HoTT.HIT.V.html#IsEmbedding_funcofmembers"><span class="id" title="definition">IsEmbedding_funcofmembers</span></a> <span class="id" title="var">y</span>) (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <span class="id" title="var">y</span> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a>) <span class="id" title="var">memb_v</span> <span class="id" title="var">H1_y</span>)) <span class="id" title="keyword">as</span> [<span class="id" title="var">b</span> <span class="id" title="var">Hb</span>].</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(816, '0_3_111');
      "><br>
        <span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(817, '0_3_111');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><span class="id" title="var">x</span><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <span class="id" title="var">phi</span>) <span class="id" title="var">Hb</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <span class="id" title="var">H2_y</span>). }</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(818, '0_3_111');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> (<span class="id" title="var">h</span> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a>)). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(819, '0_3_111');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.HIT.V.html#extensionality"><span class="id" title="lemma">extensionality</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(820, '0_3_111');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(821, '0_3_111');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">z</span> <span class="id" title="var">Hz</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(822, '0_3_111');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">Hz</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(823, '0_3_111');
      "><span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">Ha</span>].</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(824, '0_3_111');
      "><br>
      <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">w</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <span class="id" title="var">phi</span>) <span class="id" title="var">Ha</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">a</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(825, '0_3_111');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">z</span> <span class="id" title="var">Hz</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(826, '0_3_111');
      "><span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(827, '0_3_111');
      "><br>
      <span class="id" title="tactic">generalize</span> (<span class="id" title="var">H1</span> <span class="id" title="var">z</span> <span class="id" title="var">Hz</span>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(828, '0_3_111');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(829, '0_3_111');
      "><span class="id" title="tactic">intros</span> [(<span class="id" title="var">a</span>,<span class="id" title="var">b</span>) <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(830, '0_3_111');
      "><span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(831, '0_3_111');
      "><br>
      <span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(832, '0_3_111');
      "><span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">a</span><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">b</span><a class="idref" href="HoTT.HIT.V.html#5bd00e41e8e773c760ec63d09afefb5f"><span class="id" title="notation">]</span></a>); <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">path_hints</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(833, '0_3_111');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(834, '0_3_111');
      "><br>
      <span class="id" title="tactic">apply</span> <span class="id" title="var">H3</span> <span class="id" title="keyword">with</span> (<a class="idref" href="HoTT.HIT.V.html#func_of_members"><span class="id" title="definition">func_of_members</span></a> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(835, '0_3_111');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(836, '0_3_111');
      "><br>
      × <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr2"><span class="id" title="abbreviation">pr2</span></a> (<span class="id" title="var">h</span> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(837, '0_3_111');
      "><br>
      × <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">w</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <span class="id" title="var">phi</span>) <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <span class="id" title="var">Hz</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(838, '0_3_111');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(839, '0_3_111');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="replacement"><span class="id" title="lemma">replacement</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><span class="id" title="var">r</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a>) (<span class="id" title="var">x</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a><br>
  <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">w</span> ⇒ <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">y</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="Coq.Init.Datatypes.html#4bfb4f2d0721ba668e3a802ab1b745a1"><span class="id" title="notation">↔</span></a> <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> ⇒ <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#r"><span class="id" title="variable">r</span></a> <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.HIT.V.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(840, '0_3_111');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(841, '0_3_111');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">r</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(842, '0_3_111');
      "><span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(843, '0_3_111');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">_</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(844, '0_3_111');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(845, '0_3_111');
      "><span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (<span class="id" title="var">r</span> <a class="idref" href="HoTT.Basics.Overture.html#38b1404556adb9f3c135a0fea94b5bdf"><span class="id" title="notation">o</span></a> <span class="id" title="var">f</span>)). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(846, '0_3_111');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(847, '0_3_111');
      "><br>
  - <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(848, '0_3_111');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(849, '0_3_111');
      "><span class="id" title="tactic">∃</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span>). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(850, '0_3_111');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(851, '0_3_111');
      "><br>
    + <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">auto</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(852, '0_3_111');
      "><br>
    + <span class="id" title="tactic">assumption</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(853, '0_3_111');
      "><br>
  - <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(854, '0_3_111');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">z</span> [<span class="id" title="var">h</span> <span class="id" title="var">p</span>]]. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(855, '0_3_111');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">h</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(856, '0_3_111');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(857, '0_3_111');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p'</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(858, '0_3_111');
      "><span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(859, '0_3_111');
      "><span class="id" title="tactic">transitivity</span> (<span class="id" title="var">r</span> <span class="id" title="var">z</span>); <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">path_hints</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(860, '0_3_111');
      "><span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">r</span> <span class="id" title="var">p'</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(861, '0_3_111');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(862, '0_3_111');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a name="separation"><span class="id" title="lemma">separation</span></a> (<span class="id" title="var">C</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a> <a class="idref" href="Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Trunc.html#hProp"><span class="id" title="abbreviation">hProp</span></a>) : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">a</span> : <a class="idref" href="HoTT.HIT.V.html#V"><span class="id" title="inductive">V</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a><br>
  <a class="idref" href="HoTT.Truncations.Core.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">w</span> ⇒ <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="Coq.Init.Datatypes.html#4bfb4f2d0721ba668e3a802ab1b745a1"><span class="id" title="notation">↔</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.HIT.V.html#f1e0358be34e82c32d105a13122b22b3"><span class="id" title="notation">∈</span></a> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.HIT.V.html#C"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.HIT.V.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(863, '0_3_111');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(864, '0_3_111');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.HIT.V.html#V_ind_hprop"><span class="id" title="definition">V_ind_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(865, '0_3_111');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">_</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(866, '0_3_111');
      "><span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(867, '0_3_111');
      "><span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.HIT.V.html#set"><span class="id" title="constructor">set</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> : <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><span class="id" title="var">a</span> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <span class="id" title="var">A</span> <a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <span class="id" title="var">C</span> (<span class="id" title="var">f</span> <a class="idref" href="HoTT.HIT.V.html#a"><span class="id" title="variable">a</span></a>)<a class="idref" href="Coq.Init.Specif.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a> ⇒ <span class="id" title="var">f</span> (<a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> <a class="idref" href="HoTT.HIT.V.html#z"><span class="id" title="variable">z</span></a>))). </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(868, '0_3_111');
      "><span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(869, '0_3_111');
      "><br>
  - <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(870, '0_3_111');
      "><br>
    <span class="id" title="tactic">intros</span> [[<span class="id" title="var">a</span> <span class="id" title="var">h</span>] <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(871, '0_3_111');
      "><span class="id" title="tactic">split</span>. + <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>; <span class="id" title="tactic">∃</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">assumption</span>. + <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <span class="id" title="var">C</span> <span class="id" title="var">p</span> <span class="id" title="var">h</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(872, '0_3_111');
      "><br>
  - <span class="id" title="tactic">intros</span> [<span class="id" title="var">H1</span> <span class="id" title="var">H2</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(873, '0_3_111');
      "><span class="id" title="tactic">generalize</span> <span class="id" title="var">H1</span>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(874, '0_3_111');
      "><span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc_functor"><span class="id" title="definition">Trunc_functor</span></a> (-1)).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(875, '0_3_111');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">p</span>]. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(876, '0_3_111');
      "><span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <span class="id" title="var">C</span> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <span class="id" title="var">H2</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(877, '0_3_111');
      "><span class="id" title="tactic">exact</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(878, '0_3_111');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(879, '0_3_111');
      "><br>
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.HIT.V.html#AssumingUA"><span class="id" title="section">AssumingUA</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(880, '0_3_111');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_111"><pre><span></span></pre></div>
</div>
<div id="footer" scenenumber="5" class="doc">
<hr>
<a href="index.html">Index</a><hr>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>
</div></body>
</html>
